{"version":3,"file":"routes.js","sourceRoot":"","sources":["../src/routes.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\n/// <reference types=\"urlpattern-polyfill\" />\n\nimport type {ReactiveController, ReactiveControllerHost} from 'lit';\n\nexport interface BaseRouteConfig {\n  name?: string | undefined;\n  render?: (params: {[key: string]: string | undefined}) => unknown;\n  enter?: (params: {\n    [key: string]: string | undefined;\n  }) => Promise<boolean> | boolean;\n}\n\n/**\n * A RouteConfig that matches against a `path` string. `path` must be a\n * [`URLPattern` compatible pathname pattern](https://developer.mozilla.org/en-US/docs/Web/API/URLPattern/pathname).\n */\nexport interface PathRouteConfig extends BaseRouteConfig {\n  path: string;\n}\n\n/**\n * A RouteConfig that matches against a given [`URLPattern`](https://developer.mozilla.org/en-US/docs/Web/API/URLPattern)\n *\n * While `URLPattern` can match against protocols, hostnames, and ports,\n * routes will only be checked for matches if they're part of the current\n * origin. This means that the pattern is limited to checking `pathname` and\n * `search`.\n */\nexport interface URLPatternRouteConfig extends BaseRouteConfig {\n  pattern: URLPattern;\n}\n\n/**\n * A description of a route, which path or pattern to match against, and a\n * render() callback used to render a match to the outlet.\n */\nexport type RouteConfig = PathRouteConfig | URLPatternRouteConfig;\n\n// A cache of URLPatterns created for PathRouteConfig.\n// Rather than converting all given RoutConfigs to URLPatternRouteConfig, this\n// lets us make `routes` mutable so users can add new PathRouteConfigs\n// dynamically.\nconst patternCache = new WeakMap<PathRouteConfig, URLPattern>();\n\nconst isPatternConfig = (route: RouteConfig): route is URLPatternRouteConfig =>\n  (route as URLPatternRouteConfig).pattern !== undefined;\n\nconst getPattern = (route: RouteConfig) => {\n  if (isPatternConfig(route)) {\n    return route.pattern;\n  }\n  let pattern = patternCache.get(route);\n  if (pattern === undefined) {\n    patternCache.set(route, (pattern = new URLPattern({pathname: route.path})));\n  }\n  return pattern;\n};\n\n/**\n * A reactive controller that performs location-based routing using a\n * configuration of URL patterns and associated render callbacks.\n */\nexport class Routes implements ReactiveController {\n  private readonly _host: ReactiveControllerHost & HTMLElement;\n\n  /*\n   * The currently installed set of routes in precedence order.\n   *\n   * This array is mutable. To dynamically add a new route you can write:\n   *\n   * ```ts\n   * this._routes.routes.push({\n   *   path: '/foo',\n   *   render: () => html`<p>Foo</p>`,\n   * });\n   * ```\n   *\n   * Mutating this property does not trigger any route transitions. If the\n   * changes may result is a different route matching for the current path, you\n   * must instigate a route update with `goto()`.\n   */\n  routes: Array<RouteConfig> = [];\n\n  /**\n   * A default fallback route which will always be matched if none of the\n   * {@link routes} match. Implicitly matches to the path \"/*\".\n   */\n  fallback?: BaseRouteConfig;\n\n  /*\n   * The current set of child Routes controllers. These are connected via\n   * the routes-connected event.\n   */\n  private readonly _childRoutes: Array<Routes> = [];\n\n  private _parentRoutes: Routes | undefined;\n\n  /*\n   * State related to the current matching route.\n   *\n   * We keep this so that consuming code can access current parameters, and so\n   * that we can propagate tail matches to child routes if they are added after\n   * navigation / matching.\n   */\n  private _currentPathname: string | undefined;\n  private _currentRoute: RouteConfig | undefined;\n  private _currentParams: {\n    [key: string]: string | undefined;\n  } = {};\n\n  /**\n   * Callback to call when this controller is disconnected.\n   *\n   * It's critical to call this immediately in hostDisconnected so that this\n   * controller instance doesn't receive a tail match meant for another route.\n   */\n  // TODO (justinfagnani): Do we need this now that we have a direct reference\n  // to the parent? We can call `this._parentRoutes.disconnect(this)`.\n  private _onDisconnect: (() => void) | undefined;\n\n  constructor(\n    host: ReactiveControllerHost & HTMLElement,\n    routes: Array<RouteConfig>,\n    options?: {fallback?: BaseRouteConfig}\n  ) {\n    (this._host = host).addController(this);\n    this.routes = [...routes];\n    this.fallback = options?.fallback;\n  }\n\n  /**\n   * Returns a URL string of the current route, including parent routes,\n   * optionally replacing the local path with `pathname`.\n   */\n  link(pathname?: string): string {\n    if (pathname?.startsWith('/')) {\n      return pathname;\n    }\n    if (pathname?.startsWith('.')) {\n      throw new Error('Not implemented');\n    }\n    pathname ??= this._currentPathname;\n    return (this._parentRoutes?.link() ?? '') + pathname;\n  }\n\n  /**\n   * Navigates this routes controller to `pathname`.\n   *\n   * This does not navigate parent routes, so it isn't (yet) a general page\n   * navigation API. It does navigate child routes if pathname matches a\n   * pattern with a tail wildcard pattern (`/*`).\n   */\n  async goto(pathname: string) {\n    // TODO (justinfagnani): handle absolute vs relative paths separately.\n    // TODO (justinfagnani): do we need to detect when goto() is called while\n    // a previous goto() call is still pending?\n\n    // TODO (justinfagnani): generalize this to handle query params and\n    // fragments. It currently only handles path names because it's easier to\n    // completely disregard the origin for now. The click handler only does\n    // an in-page navigation if the origin matches anyway.\n    let tailGroup: string | undefined;\n\n    if (this.routes.length === 0 && this.fallback === undefined) {\n      // If a routes controller has none of its own routes it acts like it has\n      // one route of `/*` so that it passes the whole pathname as a tail\n      // match.\n      tailGroup = pathname;\n      this._currentPathname = '';\n      // Simulate a tail group with the whole pathname\n      this._currentParams = {0: tailGroup};\n    } else {\n      const route = this._getRoute(pathname);\n      if (route === undefined) {\n        throw new Error(`No route found for ${pathname}`);\n      }\n      const pattern = getPattern(route);\n      const result = pattern.exec({pathname});\n      const params = result?.pathname.groups ?? {};\n      tailGroup = getTailGroup(params);\n      if (typeof route.enter === 'function') {\n        const success = await route.enter(params);\n        // If enter() returns false, cancel this navigation\n        if (success === false) {\n          return;\n        }\n      }\n      // Only update route state if the enter handler completes successfully\n      this._currentRoute = route;\n      this._currentParams = params;\n      this._currentPathname =\n        tailGroup === undefined\n          ? pathname\n          : pathname.substring(0, pathname.length - tailGroup.length);\n    }\n\n    // Propagate the tail match to children\n    if (tailGroup !== undefined) {\n      for (const childRoutes of this._childRoutes) {\n        childRoutes.goto(tailGroup);\n      }\n    }\n    this._host.requestUpdate();\n  }\n\n  /**\n   * The result of calling the current route's render() callback.\n   */\n  outlet() {\n    return this._currentRoute?.render?.(this._currentParams);\n  }\n\n  /**\n   * The current parsed route parameters.\n   */\n  get params() {\n    return this._currentParams;\n  }\n\n  /**\n   * Matches `url` against the installed routes and returns the first match.\n   */\n  private _getRoute(pathname: string): RouteConfig | undefined {\n    const matchedRoute = this.routes.find((r) =>\n      getPattern(r).test({pathname: pathname})\n    );\n    if (matchedRoute || this.fallback === undefined) {\n      return matchedRoute;\n    }\n    if (this.fallback) {\n      // The fallback route behaves like it has a \"/*\" path. This is hidden from\n      // the public API but is added here to return a valid RouteConfig.\n      return {...this.fallback, path: '/*'};\n    }\n    return undefined;\n  }\n\n  hostConnected() {\n    this._host.addEventListener(\n      RoutesConnectedEvent.eventName,\n      this._onRoutesConnected\n    );\n    const event = new RoutesConnectedEvent(this);\n    this._host.dispatchEvent(event);\n    this._onDisconnect = event.onDisconnect;\n  }\n\n  hostDisconnected() {\n    // When this child routes controller is disconnected because a parent\n    // outlet rendered a different template, disconnecting will ensure that\n    // this controller doesn't receive a tail match meant for another route.\n    this._onDisconnect?.();\n    this._parentRoutes = undefined;\n  }\n\n  private _onRoutesConnected = (e: RoutesConnectedEvent) => {\n    // Don't handle the event fired by this routes controller, which we get\n    // because we do this.dispatchEvent(...)\n    if (e.routes === this) {\n      return;\n    }\n\n    const childRoutes = e.routes;\n    this._childRoutes.push(childRoutes);\n    childRoutes._parentRoutes = this;\n\n    e.stopImmediatePropagation();\n    e.onDisconnect = () => {\n      // Remove route from this._childRoutes:\n      // `>>> 0` converts -1 to 2**32-1\n      this._childRoutes?.splice(\n        this._childRoutes.indexOf(childRoutes) >>> 0,\n        1\n      );\n    };\n\n    const tailGroup = getTailGroup(this._currentParams);\n    if (tailGroup !== undefined) {\n      childRoutes.goto(tailGroup);\n    }\n  };\n}\n\n/**\n * Returns the tail of a pathname groups object. This is the match from a\n * wildcard at the end of a pathname pattern, like `/foo/*`\n */\nconst getTailGroup = (groups: {[key: string]: string | undefined}) => {\n  let tailKey: string | undefined;\n  for (const key of Object.keys(groups)) {\n    if (/\\d+/.test(key) && (tailKey === undefined || key > tailKey!)) {\n      tailKey = key;\n    }\n  }\n  return tailKey && groups[tailKey];\n};\n\n/**\n * This event is fired from Routes controllers when their host is connected to\n * announce the child route and potentially connect to a parent routes controller.\n */\nexport class RoutesConnectedEvent extends Event {\n  static readonly eventName = 'lit-routes-connected';\n  readonly routes: Routes;\n  onDisconnect?: () => void;\n\n  constructor(routes: Routes) {\n    super(RoutesConnectedEvent.eventName, {\n      bubbles: true,\n      composed: true,\n      cancelable: false,\n    });\n    this.routes = routes;\n  }\n}\n\ndeclare global {\n  interface HTMLElementEventMap {\n    [RoutesConnectedEvent.eventName]: RoutesConnectedEvent;\n  }\n}\n"]}