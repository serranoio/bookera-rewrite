{"version":3,"file":"routes.js","sources":["src/routes.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\n/// <reference types=\"urlpattern-polyfill\" />\n\nimport type {ReactiveController, ReactiveControllerHost} from 'lit';\n\nexport interface BaseRouteConfig {\n  name?: string | undefined;\n  render?: (params: {[key: string]: string | undefined}) => unknown;\n  enter?: (params: {\n    [key: string]: string | undefined;\n  }) => Promise<boolean> | boolean;\n}\n\n/**\n * A RouteConfig that matches against a `path` string. `path` must be a\n * [`URLPattern` compatible pathname pattern](https://developer.mozilla.org/en-US/docs/Web/API/URLPattern/pathname).\n */\nexport interface PathRouteConfig extends BaseRouteConfig {\n  path: string;\n}\n\n/**\n * A RouteConfig that matches against a given [`URLPattern`](https://developer.mozilla.org/en-US/docs/Web/API/URLPattern)\n *\n * While `URLPattern` can match against protocols, hostnames, and ports,\n * routes will only be checked for matches if they're part of the current\n * origin. This means that the pattern is limited to checking `pathname` and\n * `search`.\n */\nexport interface URLPatternRouteConfig extends BaseRouteConfig {\n  pattern: URLPattern;\n}\n\n/**\n * A description of a route, which path or pattern to match against, and a\n * render() callback used to render a match to the outlet.\n */\nexport type RouteConfig = PathRouteConfig | URLPatternRouteConfig;\n\n// A cache of URLPatterns created for PathRouteConfig.\n// Rather than converting all given RoutConfigs to URLPatternRouteConfig, this\n// lets us make `routes` mutable so users can add new PathRouteConfigs\n// dynamically.\nconst patternCache = new WeakMap<PathRouteConfig, URLPattern>();\n\nconst isPatternConfig = (route: RouteConfig): route is URLPatternRouteConfig =>\n  (route as URLPatternRouteConfig).pattern !== undefined;\n\nconst getPattern = (route: RouteConfig) => {\n  if (isPatternConfig(route)) {\n    return route.pattern;\n  }\n  let pattern = patternCache.get(route);\n  if (pattern === undefined) {\n    patternCache.set(route, (pattern = new URLPattern({pathname: route.path})));\n  }\n  return pattern;\n};\n\n/**\n * A reactive controller that performs location-based routing using a\n * configuration of URL patterns and associated render callbacks.\n */\nexport class Routes implements ReactiveController {\n  private readonly _host: ReactiveControllerHost & HTMLElement;\n\n  /*\n   * The currently installed set of routes in precedence order.\n   *\n   * This array is mutable. To dynamically add a new route you can write:\n   *\n   * ```ts\n   * this._routes.routes.push({\n   *   path: '/foo',\n   *   render: () => html`<p>Foo</p>`,\n   * });\n   * ```\n   *\n   * Mutating this property does not trigger any route transitions. If the\n   * changes may result is a different route matching for the current path, you\n   * must instigate a route update with `goto()`.\n   */\n  routes: Array<RouteConfig> = [];\n\n  /**\n   * A default fallback route which will always be matched if none of the\n   * {@link routes} match. Implicitly matches to the path \"/*\".\n   */\n  fallback?: BaseRouteConfig;\n\n  /*\n   * The current set of child Routes controllers. These are connected via\n   * the routes-connected event.\n   */\n  private readonly _childRoutes: Array<Routes> = [];\n\n  private _parentRoutes: Routes | undefined;\n\n  /*\n   * State related to the current matching route.\n   *\n   * We keep this so that consuming code can access current parameters, and so\n   * that we can propagate tail matches to child routes if they are added after\n   * navigation / matching.\n   */\n  private _currentPathname: string | undefined;\n  private _currentRoute: RouteConfig | undefined;\n  private _currentParams: {\n    [key: string]: string | undefined;\n  } = {};\n\n  /**\n   * Callback to call when this controller is disconnected.\n   *\n   * It's critical to call this immediately in hostDisconnected so that this\n   * controller instance doesn't receive a tail match meant for another route.\n   */\n  // TODO (justinfagnani): Do we need this now that we have a direct reference\n  // to the parent? We can call `this._parentRoutes.disconnect(this)`.\n  private _onDisconnect: (() => void) | undefined;\n\n  constructor(\n    host: ReactiveControllerHost & HTMLElement,\n    routes: Array<RouteConfig>,\n    options?: {fallback?: BaseRouteConfig}\n  ) {\n    (this._host = host).addController(this);\n    this.routes = [...routes];\n    this.fallback = options?.fallback;\n  }\n\n  /**\n   * Returns a URL string of the current route, including parent routes,\n   * optionally replacing the local path with `pathname`.\n   */\n  link(pathname?: string): string {\n    if (pathname?.startsWith('/')) {\n      return pathname;\n    }\n    if (pathname?.startsWith('.')) {\n      throw new Error('Not implemented');\n    }\n    pathname ??= this._currentPathname;\n    return (this._parentRoutes?.link() ?? '') + pathname;\n  }\n\n  /**\n   * Navigates this routes controller to `pathname`.\n   *\n   * This does not navigate parent routes, so it isn't (yet) a general page\n   * navigation API. It does navigate child routes if pathname matches a\n   * pattern with a tail wildcard pattern (`/*`).\n   */\n  async goto(pathname: string) {\n    // TODO (justinfagnani): handle absolute vs relative paths separately.\n    // TODO (justinfagnani): do we need to detect when goto() is called while\n    // a previous goto() call is still pending?\n\n    // TODO (justinfagnani): generalize this to handle query params and\n    // fragments. It currently only handles path names because it's easier to\n    // completely disregard the origin for now. The click handler only does\n    // an in-page navigation if the origin matches anyway.\n    let tailGroup: string | undefined;\n\n    if (this.routes.length === 0 && this.fallback === undefined) {\n      // If a routes controller has none of its own routes it acts like it has\n      // one route of `/*` so that it passes the whole pathname as a tail\n      // match.\n      tailGroup = pathname;\n      this._currentPathname = '';\n      // Simulate a tail group with the whole pathname\n      this._currentParams = {0: tailGroup};\n    } else {\n      const route = this._getRoute(pathname);\n      if (route === undefined) {\n        throw new Error(`No route found for ${pathname}`);\n      }\n      const pattern = getPattern(route);\n      const result = pattern.exec({pathname});\n      const params = result?.pathname.groups ?? {};\n      tailGroup = getTailGroup(params);\n      if (typeof route.enter === 'function') {\n        const success = await route.enter(params);\n        // If enter() returns false, cancel this navigation\n        if (success === false) {\n          return;\n        }\n      }\n      // Only update route state if the enter handler completes successfully\n      this._currentRoute = route;\n      this._currentParams = params;\n      this._currentPathname =\n        tailGroup === undefined\n          ? pathname\n          : pathname.substring(0, pathname.length - tailGroup.length);\n    }\n\n    // Propagate the tail match to children\n    if (tailGroup !== undefined) {\n      for (const childRoutes of this._childRoutes) {\n        childRoutes.goto(tailGroup);\n      }\n    }\n    this._host.requestUpdate();\n  }\n\n  /**\n   * The result of calling the current route's render() callback.\n   */\n  outlet() {\n    return this._currentRoute?.render?.(this._currentParams);\n  }\n\n  /**\n   * The current parsed route parameters.\n   */\n  get params() {\n    return this._currentParams;\n  }\n\n  /**\n   * Matches `url` against the installed routes and returns the first match.\n   */\n  private _getRoute(pathname: string): RouteConfig | undefined {\n    const matchedRoute = this.routes.find((r) =>\n      getPattern(r).test({pathname: pathname})\n    );\n    if (matchedRoute || this.fallback === undefined) {\n      return matchedRoute;\n    }\n    if (this.fallback) {\n      // The fallback route behaves like it has a \"/*\" path. This is hidden from\n      // the public API but is added here to return a valid RouteConfig.\n      return {...this.fallback, path: '/*'};\n    }\n    return undefined;\n  }\n\n  hostConnected() {\n    this._host.addEventListener(\n      RoutesConnectedEvent.eventName,\n      this._onRoutesConnected\n    );\n    const event = new RoutesConnectedEvent(this);\n    this._host.dispatchEvent(event);\n    this._onDisconnect = event.onDisconnect;\n  }\n\n  hostDisconnected() {\n    // When this child routes controller is disconnected because a parent\n    // outlet rendered a different template, disconnecting will ensure that\n    // this controller doesn't receive a tail match meant for another route.\n    this._onDisconnect?.();\n    this._parentRoutes = undefined;\n  }\n\n  private _onRoutesConnected = (e: RoutesConnectedEvent) => {\n    // Don't handle the event fired by this routes controller, which we get\n    // because we do this.dispatchEvent(...)\n    if (e.routes === this) {\n      return;\n    }\n\n    const childRoutes = e.routes;\n    this._childRoutes.push(childRoutes);\n    childRoutes._parentRoutes = this;\n\n    e.stopImmediatePropagation();\n    e.onDisconnect = () => {\n      // Remove route from this._childRoutes:\n      // `>>> 0` converts -1 to 2**32-1\n      this._childRoutes?.splice(\n        this._childRoutes.indexOf(childRoutes) >>> 0,\n        1\n      );\n    };\n\n    const tailGroup = getTailGroup(this._currentParams);\n    if (tailGroup !== undefined) {\n      childRoutes.goto(tailGroup);\n    }\n  };\n}\n\n/**\n * Returns the tail of a pathname groups object. This is the match from a\n * wildcard at the end of a pathname pattern, like `/foo/*`\n */\nconst getTailGroup = (groups: {[key: string]: string | undefined}) => {\n  let tailKey: string | undefined;\n  for (const key of Object.keys(groups)) {\n    if (/\\d+/.test(key) && (tailKey === undefined || key > tailKey!)) {\n      tailKey = key;\n    }\n  }\n  return tailKey && groups[tailKey];\n};\n\n/**\n * This event is fired from Routes controllers when their host is connected to\n * announce the child route and potentially connect to a parent routes controller.\n */\nexport class RoutesConnectedEvent extends Event {\n  static readonly eventName = 'lit-routes-connected';\n  readonly routes: Routes;\n  onDisconnect?: () => void;\n\n  constructor(routes: Routes) {\n    super(RoutesConnectedEvent.eventName, {\n      bubbles: true,\n      composed: true,\n      cancelable: false,\n    });\n    this.routes = routes;\n  }\n}\n\ndeclare global {\n  interface HTMLElementEventMap {\n    [RoutesConnectedEvent.eventName]: RoutesConnectedEvent;\n  }\n}\n"],"names":["patternCache","WeakMap","getPattern","route","undefined","pattern","isPatternConfig","get","set","URLPattern","pathname","path","Routes","constructor","host","routes","options","this","_childRoutes","_currentParams","_onRoutesConnected","e","childRoutes","push","_parentRoutes","stopImmediatePropagation","onDisconnect","splice","indexOf","tailGroup","getTailGroup","goto","_host","addController","fallback","link","startsWith","Error","_currentPathname","length","_getRoute","result","exec","params","groups","enter","_currentRoute","substring","requestUpdate","outlet","render","matchedRoute","find","r","test","hostConnected","addEventListener","RoutesConnectedEvent","eventName","event","dispatchEvent","_onDisconnect","hostDisconnected","tailKey","key","Object","keys","Event","super","bubbles","composed","cancelable"],"mappings":"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"}