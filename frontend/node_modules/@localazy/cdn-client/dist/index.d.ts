export declare class Api {
    protected context: Context;
    constructor(context: Context);
    fetchLocale(options: ApiLocaleRequest): Promise<object | string>;
    fetchMetafile(): Promise<IMetafile>;
}

export declare type ApiLocaleRequest = ILocalesCacheItem;

export declare type CacheGetLocalesRequest = ILocalesCacheItem;

export declare type CacheHasLocalesRequest = ILocalesCacheItem;

export declare type CacheKeyMetafileOptions = ILocalesCacheItem;

export declare type CacheStoreLocalesRequest = ILocalesCacheItem & {
    data: object | string;
};

export declare abstract class CdnBase {
    protected context: Context;
    constructor(context: Context);
}

export declare class CdnCache extends CdnBase {
    flush: () => void;
}

export declare class CdnClient {
    metafile: CdnMetafile;
    cache: CdnCache;
    protected context: Context;
    static version: string;
    protected constructor(options: CdnClientOptions);
    fetch: (options?: CdnFetchOptions) => Promise<CdnResponse>;
    static create(options: CdnClientOptions): Promise<CdnClient>;
}

export declare type CdnClientOptions = {
    /**
     * Project metafile URL.
     */
    metafile: string;
};

export declare type CdnFetchOptions = {
    /**
     * Select single or multiple files to fetch from the CDN.
     *
     * Default: all files in the metafile.
     */
    files?: (CdnFile | string)[] | CdnFile | string;
    /**
     * Select single or multiple locales to fetch from the CDN.
     *
     * Default: all locales in the metafile.
     */
    locales?: string[] | string;
    /**
     * Exclude the base locale from the list of locales to fetch.
     */
    excludeBaseLocale?: boolean;
};

export declare type CdnFile = {
    /**
     * File ID.
     */
    id: string;
    /**
     * File name.
     */
    file: string;
    /**
     * File path.
     */
    path: string;
    /**
     * File library.
     */
    library: string;
    /**
     * File module.
     */
    module: string;
    /**
     * File build type.
     */
    buildType: string;
    /**
     * File product flavors.
     */
    productFlavors: string[];
    /**
     * File locales.
     */
    locales: CdnFileLocale[];
};

export declare type CdnFileLocale = {
    /**
     * Locale code.
     */
    locale: string;
    /**
     * Boolean indicating if this is the base locale.
     */
    isBaseLocale: boolean;
    /**
     * File URI.
     */
    uri: string;
};

export declare type CdnLocale = {
    /**
     * Locale code.
     */
    locale: string;
    /**
     * Boolean indicating if this is the base locale.
     */
    isBaseLocale: boolean;
    /**
     * Language code.
     */
    language: string;
    /**
     * Region code.
     */
    region?: string;
    /**
     * Script code.
     */
    script?: string;
    /**
     * Boolean indicating if the locale is right-to-left.
     */
    isRtl: boolean;
    /**
     * Locale name.
     */
    name: string;
    /**
     * Localized locale name.
     */
    localizedName: string;
};

export declare type CdnLocalesOptions = {
    /**
     * Exclude the base locale from the list of locales.
     */
    excludeBaseLocale?: boolean;
};

export declare class CdnMetafile extends CdnBase {
    get projectUrl(): string;
    get baseLocale(): CdnLocale;
    get url(): string;
    get files(): CdnFile[];
    locales: (options?: CdnLocalesOptions) => CdnLocale[];
    refresh: () => Promise<void>;
    switch: (options: CdnClientOptions) => Promise<void>;
}

export declare type CdnResponse = 
/**
* Map of file IDs with locales map as value.
*/
    {
    [fileId: string]: {
        /**
         * Map of locales with file content as value.
         */
        [locale: string]: object | string;
    };
}
/**
* Map of locales with file content as value.
*/
| {
    [locale: string]: object | string;
}
/**
* File content.
*/
| object
/**
* File content as string for non-JSON files.
*/
| string;

export declare class Context {
    metafile: MetafileContext;
    cdn: CdnClient;
    client: IHttpAdapter;
    api: Api;
    cache: LocalesCache;
    responseFactory: ResponseFactory;
    constructor(options: ContextOptions);
}

export declare type ContextOptions = {
    metafileContext: MetafileContext;
    cdn: CdnClient;
    client: IHttpAdapter;
};

export declare class FetchHttpAdapter implements IHttpAdapter {
    protected baseUrl: string;
    constructor(baseUrl: string);
    get(url: string): Promise<string | object>;
}

export declare type FilesMap = {
    [id: string]: MetafileFile;
};

export declare interface ICacheAdapter<K, V> {
    has: (key: K) => boolean;
    get: (key: K) => V | undefined;
    set: (key: K, value: V) => void;
    flush: () => void;
}

export declare interface IHttpAdapter<T = object> {
    get: (url: string, config?: T) => Promise<object | string>;
}

export declare interface ILocalesCacheItem {
    metafileFile: MetafileFile;
    metafileLocale: MetafileLocale;
}

export declare interface IMetafile {
    projectUrl: string;
    baseLocale: string;
    timestamp: number;
    files: IMetafileFiles;
}

export declare interface IMetafileFile {
    file: string;
    path: string;
    library: string;
    module: string;
    buildType: string;
    timestamp: number;
    productFlavors: string[];
    locales: IMetafileFileLocale[];
}

export declare interface IMetafileFileLocale {
    language: string;
    region: string;
    script: string;
    isRtl: boolean;
    name: string;
    localizedName: string;
    uri: string;
    timestamp: number;
}

export declare interface IMetafileFiles {
    [id: string]: IMetafileFile;
}

export declare interface IMetafileParams {
    url: string;
    baseUrl: string;
    cdnId: string;
    jsonPath: string;
}

export declare interface IRequestBuilder {
    addFiles(request?: (CdnFile | string)[] | CdnFile | string): IRequestBuilder;
    addLocales(request?: string[] | string, excludeBaseLocale?: boolean): IRequestBuilder;
    getCdnRequest(): Request_2;
}

export declare const isArray: <T>(value: unknown) => value is T[];

export declare const isPlainObject: (value: unknown) => value is Record<string, unknown>;

export declare const isString: (value: unknown) => value is string;

export declare const isUndefined: (value: unknown) => value is undefined;

export declare type JsonResponse = {
    [key: string]: Record<string, object>;
};

export declare type LocaleResponse = {
    [locale: string]: JsonResponse;
};

export declare class LocalesCache {
    protected context: Context;
    protected cacheAdapter: ICacheAdapter<string, object | string>;
    constructor(context: Context);
    setIfMissed(options: CacheStoreLocalesRequest): void;
    has(options: CacheHasLocalesRequest): boolean;
    get(options: CacheGetLocalesRequest): object | string | undefined;
    flush(): void;
    protected keyFromMetafile(options: CacheKeyMetafileOptions): string;
}

export declare class LocalesMap {
    data: LocalesMapData;
    protected context: Context;
    constructor(options: LocalesMapOptions);
}

export declare type LocalesMapData = {
    [key: string]: MetafileLocale[];
};

export declare type LocalesMapOptions = {
    context: Context;
    data?: LocalesMapData;
};

export declare class MemoryCacheAdapter<K, V> implements ICacheAdapter<K, V> {
    protected map: Map<K, V>;
    constructor();
    get(key: K): V | undefined;
    has(key: K): boolean;
    set(key: K, value: V): void;
    flush(): void;
}

export declare class MetafileContext {
    params: MetafileParams;
    parsedData: IMetafile | null;
    data: MetafileData;
    constructor(options: CdnClientOptions);
    setMetafile(metafile: IMetafile): void;
}

export declare class MetafileData implements Omit<IMetafile, 'files' | 'baseLocale'> {
    projectUrl: string;
    baseLocale: CdnLocale;
    locales: CdnLocale[];
    timestamp: number;
    files: MetafileFile[];
    filesMap: FilesMap;
    constructor(options: MetafileOptions, params: MetafileParams);
    static createEmpty(params: MetafileParams): MetafileData;
    protected static filesFactory(files: IMetafileFiles, baseLocale: string, params: MetafileParams): MetafileFile[];
    protected static filesMapFactory(files: MetafileFile[]): FilesMap;
    protected static localesFactory(files: MetafileFile[]): CdnLocale[];
}

export declare class MetafileFile implements Omit<IMetafileFile, 'locales'> {
    id: string;
    file: string;
    path: string;
    library: string;
    module: string;
    buildType: string;
    timestamp: number;
    productFlavors: string[];
    locales: MetafileLocale[];
    protected baseUrl: string;
    constructor(options: MetafileFileOptions);
    toCdnFile(): CdnFile;
}

export declare type MetafileFileOptions = Omit<IMetafileFile, 'locales'> & {
    id: string;
    locales: MetafileLocale[];
    baseUrl: string;
};

export declare class MetafileLocale implements IMetafileFileLocale {
    language: string;
    region: string;
    script: string;
    isRtl: boolean;
    name: string;
    localizedName: string;
    uri: string;
    timestamp: number;
    protected baseLocale: string;
    constructor(options: IMetafileFileLocale, baseLocale: string);
    get locale(): string;
    get isBaseLocale(): boolean;
    toCdnLocale(): CdnLocale;
}

export declare type MetafileOptions = IMetafile;

export declare class MetafileParams implements IMetafileParams {
    protected options: IMetafileParams;
    constructor(metafileUrl: string);
    get url(): string;
    get baseUrl(): string;
    get cdnId(): string;
    get jsonPath(): string;
    protected static parseMetafileUrl(metafileUrl: string): IMetafileParams;
}

declare class Request_2 {
    files: MetafileFile[];
    localesMap: LocalesMap;
    hasSingleFileResponse: boolean;
    hasSingleLocaleResponse: boolean;
    protected context: Context;
    constructor(context: Context);
    execute(): Promise<CdnResponse>;
    protected getPromises(): [Promise<string | object>, ApiLocaleRequest][];
}
export { Request_2 as Request }

export declare class RequestBuilder implements IRequestBuilder {
    protected context: Context;
    protected request: Request_2;
    constructor(context: Context);
    addFiles(files?: (CdnFile | string)[] | CdnFile | string): RequestBuilder;
    addLocales(locales?: string[] | string, excludeBaseLocale?: boolean): RequestBuilder;
    getCdnRequest(): Request_2;
}

export declare class ResponseFactory {
    protected context: Context;
    constructor(context: Context);
    createCdnResponse(options: ResponseFactoryOptions): CdnResponse;
    protected cacheResponses(requests: ApiLocaleRequest[], responses: (object | string)[]): void;
    protected static transformResponses(options: ResponseFactoryOptions): CdnResponse;
}

export declare type ResponseFactoryOptions = {
    requests: ApiLocaleRequest[];
    responses: (string | object)[];
    localesMap: LocalesMap;
    hasSingleFileResponse: boolean;
    hasSingleLocaleResponse: boolean;
};

export declare const uniq: <T>(array: T[]) => T[];

export declare const uniqBy: <T>(array: T[], predicate: (item: T) => string) => T[];

export { }
