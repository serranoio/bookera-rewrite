const e = "bags", b = "saddlebag";
class g {
  _bags;
  _stateful;
  _db;
  constructor(s) {
    this._bags = /* @__PURE__ */ new Map(), this._stateful = s;
  }
  loadStatefulBags() {
    return new Promise((s) => {
      const t = indexedDB.open(b, 1);
      t.onupgradeneeded = () => {
        this._db = t.result, this._db.createObjectStore(e);
      }, t.onsuccess = () => {
        if (this._db = t.result, this._db) {
          const a = this._db.transaction(e).objectStore(e).openCursor();
          a.onsuccess = (c) => {
            let r = c.target.result;
            if (r) {
              let h = r.primaryKey, l = r.value;
              const _ = this.createBag(h);
              _.populate(l), this._bags.set(h, _), r.continue();
            } else
              s({ db: this._db });
          };
        }
      };
    });
  }
  get db() {
    return this._db ? this._db : null;
  }
  createBag(s) {
    const t = d(s, this._stateful);
    return t.db = this._db, this._bags.set(s, t), t;
  }
  getBag(s) {
    return this._bags.has(s) ? this._bags.get(s) : this.createBag(s);
  }
  resetBags() {
    this._bags.forEach((s) => {
      s.reset();
    });
  }
}
let u;
function p(n) {
  return u || (u = new g(n || !1)), u;
}
function S() {
  return p();
}
function d(n, s) {
  return new f(n, s);
}
class o {
  _allChangesBit;
  _key;
  _subFunction;
  _allChangesFunction;
  _populatedFunction;
  _bag;
  constructor(s, t) {
    this._bag = s, this._allChangesBit = t, this._key = "", this._subFunction = void 0, this._allChangesFunction = void 0, this._populatedFunction = void 0;
  }
  set allChangeFunction(s) {
    this._allChangesFunction = s;
  }
  set populatedFunction(s) {
    this._populatedFunction = s;
  }
  set subscriptionFunction(s) {
    this._subFunction = s;
  }
  set key(s) {
    this._key = s;
  }
  unsubscribe() {
    switch (this._allChangesBit) {
      case 0:
        const s = this._bag._subscriptions.get(this._key);
        s && this._bag._subscriptions.set(
          this._key,
          s.filter((t) => t !== this._subFunction)
        );
        break;
      case 1:
        this._bag._allChangesSubscriptions = this._bag._allChangesSubscriptions.filter((t) => t !== this._allChangesFunction);
        break;
      case 2:
        this._bag._storePopulatedSubscriptions = this._bag._storePopulatedSubscriptions.filter((t) => t !== this._populatedFunction);
    }
  }
}
class f {
  _id;
  _stateful;
  _values;
  _db;
  _subscriptions;
  _allChangesSubscriptions;
  _storePopulatedSubscriptions;
  constructor(s, t) {
    this._values = /* @__PURE__ */ new Map(), this._subscriptions = /* @__PURE__ */ new Map(), this._allChangesSubscriptions = [], this._storePopulatedSubscriptions = [], this._stateful = t || !1, this._id = s;
  }
  set(s, t) {
    this._values.set(s, structuredClone(t)), this.alertSubscribers(s, t), this._stateful && this._db && this._db.transaction([e], "readwrite").objectStore(e).put(this._values, this._id);
  }
  get id() {
    return this._id;
  }
  set db(s) {
    this._db = s;
  }
  reset() {
    this._values.forEach((s, t) => {
      this.alertSubscribers(t, void 0);
    }), this._values = /* @__PURE__ */ new Map(), this._stateful && this._db && this._db.transaction([e], "readwrite").objectStore(e).delete(this._id);
  }
  alertSubscribers(s, t) {
    this._subscriptions.has(s) && this._subscriptions.get(s)?.forEach(
      (i) => i(t)
    ), this._allChangesSubscriptions.length > 0 && this._allChangesSubscriptions.forEach(
      (i) => i(s, t)
    );
  }
  get(s) {
    return this._values.get(s);
  }
  populate(s) {
    s && s.size > 0 && (this._values = structuredClone(s), this._storePopulatedSubscriptions.length > 0 && this._storePopulatedSubscriptions.forEach(
      (t) => t(s)
    ));
  }
  export() {
    return this._values;
  }
  subscribe(s, t) {
    if (!this._subscriptions.has(s))
      this._subscriptions.set(s, [t]);
    else {
      const a = this._subscriptions.get(s);
      a && this._subscriptions.set(s, [...a, t]);
    }
    const i = new o(this, 0);
    return i.key = s, i.subscriptionFunction = t, i;
  }
  onAllChanges(s) {
    this._allChangesSubscriptions.push(s);
    const t = new o(this, 1);
    return t.allChangeFunction = s, t;
  }
  onPopulated(s) {
    this._storePopulatedSubscriptions.push(s);
    const t = new o(this, 2);
    return t.populatedFunction = s, t;
  }
}
export {
  b as BAG_DB_NAME,
  e as BAG_OBJECT_STORE,
  o as BagSubscription,
  d as CreateBag,
  p as CreateBagManager,
  S as GetBagManager
};
