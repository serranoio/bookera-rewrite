import type { ClassLike } from 'utilium/types.js';
import type * as primitive from 'utilium/internal/primitives.js';
declare global {
    interface SymbolConstructor {
        readonly struct_init: unique symbol;
        readonly struct_metadata: unique symbol;
    }
}
export interface MemberInit {
    name: string;
    type: string | ClassLike;
    length?: number;
}
/** @deprecated */
export declare const init: typeof Symbol.struct_init;
/**
 * Options for struct initialization
 */
export interface Options {
    align: number;
    bigEndian: boolean;
}
export interface Member {
    type: primitive.Type | Static;
    offset: number;
    length?: number;
}
export interface Metadata {
    options: Partial<Options>;
    members: Map<string, Member>;
    size: number;
}
/** @deprecated */
export declare const metadata: typeof Symbol.struct_metadata;
export interface _DecoratorMetadata<T extends Metadata = Metadata> extends DecoratorMetadata {
    [Symbol.struct_metadata]?: T;
    [Symbol.struct_init]?: MemberInit[];
}
export interface DecoratorContext<T extends Metadata = Metadata> {
    metadata: _DecoratorMetadata<T>;
}
export type MemberContext = ClassMemberDecoratorContext & DecoratorContext;
export interface Static<T extends Metadata = Metadata> {
    [Symbol.metadata]: DecoratorMetadata & {
        [Symbol.struct_metadata]: T;
    };
    new (): Instance<T>;
    prototype: Instance<T>;
}
export interface StaticLike<T extends Metadata = Metadata> extends ClassLike {
    [Symbol.metadata]?: _DecoratorMetadata<T> | null;
}
export declare function isValidMetadata<T extends Metadata = Metadata>(arg: unknown): arg is DecoratorMetadata & {
    [Symbol.struct_metadata]: T;
};
/**
 * Polyfill context.metadata
 * @see https://github.com/microsoft/TypeScript/issues/53461
 */
export declare function _polyfill_contextMetadata(target: object): void;
/**
 * Gets a reference to Symbol.metadata, even on platforms that do not expose it globally (like Node)
 */
export declare function symbol_metadata(arg: ClassLike): typeof Symbol.metadata;
export declare function isStatic<T extends Metadata = Metadata>(arg: unknown): arg is Static<T>;
export interface Instance<T extends Metadata = Metadata> {
    constructor: Static<T>;
}
export interface InstanceLike<T extends Metadata = Metadata> {
    constructor: StaticLike<T>;
}
export declare function isInstance<T extends Metadata = Metadata>(arg: unknown): arg is Instance<T>;
export declare function checkInstance<T extends Metadata = Metadata>(arg: unknown): asserts arg is Instance<T>;
export declare function isStruct<T extends Metadata = Metadata>(arg: unknown): arg is Instance<T> | Static<T>;
export declare function checkStruct<T extends Metadata = Metadata>(arg: unknown): asserts arg is Instance<T> | Static<T>;
export type Like<T extends Metadata = Metadata> = InstanceLike<T> | StaticLike<T>;
export type Size<T extends primitive.Valid | StaticLike | InstanceLike> = T extends primitive.Valid ? primitive.Size<T> : T extends Like<infer M> ? M['size'] : number;
