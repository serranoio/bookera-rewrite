import "./chunk-2TUXWMP5.js";

// node_modules/@lit/localize/internal/locale-status-event.js
var LOCALE_STATUS_EVENT = "lit-localize-status";

// node_modules/@lit/localize/internal/str-tag.js
var _str = (strings, ...values) => ({
  strTag: true,
  strings,
  values
});
var str = _str;
var isStrTagged = (val) => typeof val !== "string" && "strTag" in val;
var joinStringsAndValues = (strings, values, valueOrder) => {
  let concat = strings[0];
  for (let i = 1; i < strings.length; i++) {
    concat += values[valueOrder ? valueOrder[i - 1] : i - 1];
    concat += strings[i];
  }
  return concat;
};

// node_modules/@lit/localize/internal/default-msg.js
var defaultMsg = (template) => isStrTagged(template) ? joinStringsAndValues(template.strings, template.values) : template;

// node_modules/@lit/localize/init/install.js
var msg = defaultMsg;
var installed = false;
function _installMsgImplementation(impl) {
  if (installed) {
    throw new Error("lit-localize can only be configured once");
  }
  msg = impl;
  installed = true;
}

// node_modules/@lit/localize/internal/localized-controller.js
var LocalizeController = class {
  constructor(host) {
    this.__litLocalizeEventHandler = (event) => {
      if (event.detail.status === "ready") {
        this.host.requestUpdate();
      }
    };
    this.host = host;
  }
  hostConnected() {
    window.addEventListener(LOCALE_STATUS_EVENT, this.__litLocalizeEventHandler);
  }
  hostDisconnected() {
    window.removeEventListener(LOCALE_STATUS_EVENT, this.__litLocalizeEventHandler);
  }
};
var _updateWhenLocaleChanges = (host) => host.addController(new LocalizeController(host));
var updateWhenLocaleChanges = _updateWhenLocaleChanges;

// node_modules/@lit/localize/internal/localized-decorator.js
var localized = () => (clazz, _context) => {
  clazz.addInitializer(updateWhenLocaleChanges);
  return clazz;
};

// node_modules/@lit/localize/internal/deferred.js
var Deferred = class {
  constructor() {
    this.settled = false;
    this.promise = new Promise((resolve, reject) => {
      this._resolve = resolve;
      this._reject = reject;
    });
  }
  resolve(value) {
    this.settled = true;
    this._resolve(value);
  }
  reject(error) {
    this.settled = true;
    this._reject(error);
  }
};

// node_modules/@lit/localize/internal/fnv1a64.js
var hl = [];
for (let i = 0; i < 256; i++) {
  hl[i] = (i >> 4 & 15).toString(16) + (i & 15).toString(16);
}
function fnv1a64(str2) {
  let t0 = 0, v0 = 8997, t1 = 0, v1 = 33826, t2 = 0, v2 = 40164, t3 = 0, v3 = 52210;
  for (let i = 0; i < str2.length; i++) {
    v0 ^= str2.charCodeAt(i);
    t0 = v0 * 435;
    t1 = v1 * 435;
    t2 = v2 * 435;
    t3 = v3 * 435;
    t2 += v0 << 8;
    t3 += v1 << 8;
    t1 += t0 >>> 16;
    v0 = t0 & 65535;
    t2 += t1 >>> 16;
    v1 = t1 & 65535;
    v3 = t3 + (t2 >>> 16) & 65535;
    v2 = t2 & 65535;
  }
  return hl[v3 >> 8] + hl[v3 & 255] + hl[v2 >> 8] + hl[v2 & 255] + hl[v1 >> 8] + hl[v1 & 255] + hl[v0 >> 8] + hl[v0 & 255];
}

// node_modules/@lit/localize/internal/id-generation.js
var HASH_DELIMITER = "";
var HTML_PREFIX = "h";
var STRING_PREFIX = "s";
function generateMsgId(strings, isHtmlTagged) {
  return (isHtmlTagged ? HTML_PREFIX : STRING_PREFIX) + fnv1a64(typeof strings === "string" ? strings : strings.join(HASH_DELIMITER));
}

// node_modules/@lit/localize/internal/runtime-msg.js
var expressionOrders = /* @__PURE__ */ new WeakMap();
var hashCache = /* @__PURE__ */ new Map();
function runtimeMsg(templates2, template, options) {
  if (templates2) {
    const id = (options == null ? void 0 : options.id) ?? generateId(template);
    const localized2 = templates2[id];
    if (localized2) {
      if (typeof localized2 === "string") {
        return localized2;
      } else if ("strTag" in localized2) {
        return joinStringsAndValues(
          localized2.strings,
          // Cast `template` because its type wasn't automatically narrowed (but
          // we know it must be the same type as `localized`).
          template.values,
          localized2.values
        );
      } else {
        let order = expressionOrders.get(localized2);
        if (order === void 0) {
          order = localized2.values;
          expressionOrders.set(localized2, order);
        }
        return {
          ...localized2,
          values: order.map((i) => template.values[i])
        };
      }
    }
  }
  return defaultMsg(template);
}
function generateId(template) {
  const strings = typeof template === "string" ? template : template.strings;
  let id = hashCache.get(strings);
  if (id === void 0) {
    id = generateMsgId(strings, typeof template !== "string" && !("strTag" in template));
    hashCache.set(strings, id);
  }
  return id;
}

// node_modules/@lit/localize/init/runtime.js
function dispatchStatusEvent(detail) {
  window.dispatchEvent(new CustomEvent(LOCALE_STATUS_EVENT, { detail }));
}
var activeLocale = "";
var loadingLocale;
var sourceLocale;
var validLocales;
var loadLocale;
var templates;
var loading = new Deferred();
loading.resolve();
var requestId = 0;
var configureLocalization = (config) => {
  _installMsgImplementation((template, options) => runtimeMsg(templates, template, options));
  activeLocale = sourceLocale = config.sourceLocale;
  validLocales = new Set(config.targetLocales);
  validLocales.add(config.sourceLocale);
  loadLocale = config.loadLocale;
  return { getLocale, setLocale };
};
var getLocale = () => {
  return activeLocale;
};
var setLocale = (newLocale) => {
  if (newLocale === (loadingLocale ?? activeLocale)) {
    return loading.promise;
  }
  if (!validLocales || !loadLocale) {
    throw new Error("Internal error");
  }
  if (!validLocales.has(newLocale)) {
    throw new Error("Invalid locale code");
  }
  requestId++;
  const thisRequestId = requestId;
  loadingLocale = newLocale;
  if (loading.settled) {
    loading = new Deferred();
  }
  dispatchStatusEvent({ status: "loading", loadingLocale: newLocale });
  const localePromise = newLocale === sourceLocale ? (
    // We could switch to the source locale synchronously, but we prefer to
    // queue it on a microtask so that switching locales is consistently
    // asynchronous.
    Promise.resolve({ templates: void 0 })
  ) : loadLocale(newLocale);
  localePromise.then((mod) => {
    if (requestId === thisRequestId) {
      activeLocale = newLocale;
      loadingLocale = void 0;
      templates = mod.templates;
      dispatchStatusEvent({ status: "ready", readyLocale: newLocale });
      loading.resolve();
    }
  }, (err) => {
    if (requestId === thisRequestId) {
      dispatchStatusEvent({
        status: "error",
        errorLocale: newLocale,
        errorMessage: err.toString()
      });
      loading.reject(err);
    }
  });
  return loading.promise;
};

// node_modules/@lit/localize/init/transform.js
var configureTransformLocalization = (config) => {
  _installMsgImplementation(defaultMsg);
  const sourceLocale2 = config.sourceLocale;
  return {
    getLocale: () => sourceLocale2
  };
};
export {
  LOCALE_STATUS_EVENT,
  configureLocalization,
  configureTransformLocalization,
  isStrTagged,
  joinStringsAndValues,
  localized,
  msg,
  str,
  updateWhenLocaleChanges
};
/*! Bundled license information:

@lit/localize/internal/locale-status-event.js:
  (**
   * @license
   * Copyright 2021 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/localize/internal/str-tag.js:
  (**
   * @license
   * Copyright 2021 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/localize/internal/types.js:
  (**
   * @license
   * Copyright 2021 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/localize/internal/default-msg.js:
  (**
   * @license
   * Copyright 2021 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/localize/internal/localized-controller.js:
  (**
   * @license
   * Copyright 2021 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/localize/internal/localized-decorator.js:
  (**
   * @license
   * Copyright 2021 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/localize/internal/deferred.js:
  (**
   * @license
   * Copyright 2020 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/localize/internal/fnv1a64.js:
  (**
   * @license
   * Copyright 2014 Travis Webb
   * SPDX-License-Identifier: MIT
   *)

@lit/localize/internal/id-generation.js:
  (**
   * @license
   * Copyright 2020 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/localize/internal/runtime-msg.js:
  (**
   * @license
   * Copyright 2021 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/localize/init/runtime.js:
  (**
   * @license
   * Copyright 2021 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/localize/init/transform.js:
  (**
   * @license
   * Copyright 2021 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/localize/lit-localize.js:
  (**
   * @license
   * Copyright 2020 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)
*/
//# sourceMappingURL=@lit_localize.js.map
