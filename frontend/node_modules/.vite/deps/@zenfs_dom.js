import {
  Async,
  AsyncTransaction,
  Errno,
  ErrnoError,
  FileSystem,
  InMemory,
  IndexFS,
  Inode,
  S_IFDIR,
  S_IFMT,
  StoreFS,
  Sync,
  SyncMapTransaction,
  _inode_fields,
  _throw,
  basename,
  constants_exports,
  decodeASCII,
  dirname,
  encodeASCII,
  join,
  log_exports
} from "./chunk-GPHIYM5K.js";
import "./chunk-I3SQSCW2.js";
import "./chunk-2TUXWMP5.js";

// node_modules/@zenfs/dom/dist/utils.js
function errnoForDOMException(ex) {
  switch (ex.name) {
    case "TypeMismatchError":
      return "EPERM";
    case "IndexSizeError":
    case "HierarchyRequestError":
    case "InvalidCharacterError":
    case "InvalidStateError":
    case "SyntaxError":
    case "NamespaceError":
    case "ConstraintError":
    case "VersionError":
    case "URLMismatchError":
    case "InvalidNodeTypeError":
      return "EINVAL";
    case "WrongDocumentError":
      return "EXDEV";
    case "NoModificationAllowedError":
    case "InvalidModificationError":
    case "InvalidAccessError":
    case "SecurityError":
    case "NotAllowedError":
      return "EACCES";
    case "NotFoundError":
      return "ENOENT";
    case "NotSupportedError":
      return "ENOTSUP";
    case "InUseAttributeError":
      return "EBUSY";
    case "NetworkError":
      return "ENETDOWN";
    case "AbortError":
      return "EINTR";
    case "QuotaExceededError":
      return "ENOSPC";
    case "TimeoutError":
      return "ETIMEDOUT";
    case "ReadOnlyError":
      return "EROFS";
    case "DataCloneError":
    case "EncodingError":
    case "NotReadableError":
    case "DataError":
    case "TransactionInactiveError":
    case "OperationError":
    case "UnknownError":
    default:
      return "EIO";
  }
}
function convertException(ex, path, syscall) {
  if (ex instanceof ErrnoError)
    return ex;
  const code = ex instanceof DOMException ? Errno[errnoForDOMException(ex)] : Errno.EIO;
  const error = new ErrnoError(code, ex.message, path, syscall);
  error.stack = ex.stack;
  error.cause = ex.cause;
  return error;
}

// node_modules/@zenfs/dom/dist/access.js
function isResizable(buffer) {
  if (buffer instanceof ArrayBuffer)
    return buffer.resizable;
  if (buffer instanceof SharedArrayBuffer)
    return buffer.growable;
  return false;
}
function isKind(handle, kind) {
  return handle.kind == kind;
}
var WebAccessFS = class extends Async(IndexFS) {
  /**
   * Loads all of the handles.
   * @internal @hidden
   */
  async _loadHandles(path, handle) {
    for await (const [key, child] of handle.entries()) {
      const p = join(path, key);
      this._handles.set(p, child);
      if (isKind(child, "directory"))
        await this._loadHandles(p, child);
    }
  }
  /**
   * Loads metadata
   * @internal @hidden
   */
  async _loadMetadata(metadataPath) {
    if (metadataPath) {
      const handle = this.get("file", metadataPath);
      const file = await handle.getFile();
      const raw = await file.text();
      const data = JSON.parse(raw);
      this.index.fromJSON(data);
      return;
    }
    for (const [path, handle] of this._handles) {
      if (isKind(handle, "file")) {
        const { lastModified, size } = await handle.getFile();
        this.index.set(path, new Inode({ mode: 420 | constants_exports.S_IFREG, size, mtimeMs: lastModified }));
        continue;
      }
      if (!isKind(handle, "directory"))
        throw new ErrnoError(Errno.EIO, "Invalid handle", path);
      this.index.set(path, new Inode({ mode: 511 | constants_exports.S_IFDIR, size: 0 }));
    }
  }
  constructor(handle) {
    super(2003133025, "webaccessfs");
    this._handles = /* @__PURE__ */ new Map();
    this._sync = InMemory.create({ label: "accessfs-cache" });
    this.attributes.set("no_buffer_resize");
    this._handles.set("/", handle);
  }
  async remove(path) {
    const handle = this.get("directory", dirname(path));
    await handle.removeEntry(basename(path), { recursive: true }).catch((ex) => _throw(convertException(ex, path)));
  }
  removeSync(path) {
    throw log_exports.crit(ErrnoError.With("ENOSYS", path));
  }
  async read(path, buffer, offset, end) {
    if (end <= offset)
      return;
    const handle = this.get("file", path, "write");
    const file = await handle.getFile();
    const data = await file.arrayBuffer();
    if (data.byteLength < end - offset)
      throw ErrnoError.With("ENODATA", path, "read");
    buffer.set(new Uint8Array(data, offset, end - offset));
  }
  async write(path, buffer, offset) {
    if (isResizable(buffer.buffer)) {
      const newBuffer = new Uint8Array(new ArrayBuffer(buffer.byteLength), buffer.byteOffset, buffer.byteLength);
      newBuffer.set(buffer);
      buffer = newBuffer;
    }
    const inode = this.index.get(path);
    if (!inode)
      throw ErrnoError.With("ENOENT", path, "write");
    const isDir = (inode.mode & S_IFMT) == S_IFDIR;
    let handle;
    try {
      handle = this.get(isDir ? "directory" : "file", path, "write");
    } catch {
      const parent = this.get("directory", dirname(path), "write");
      handle = await parent[isDir ? "getDirectoryHandle" : "getFileHandle"](basename(path), { create: true }).catch((ex) => _throw(convertException(ex, path)));
      this._handles.set(path, handle);
    }
    if (isDir)
      return;
    if (isKind(handle, "directory")) {
      log_exports.crit(new ErrnoError(Errno.EIO, "Mismatch in entry kind on write", path, "write"));
      return;
    }
    const writable = await handle.createWritable();
    try {
      await writable.seek(offset);
    } catch {
      await writable.write({ type: "seek", position: offset });
    }
    await writable.write(buffer);
    await writable.close();
    const { size, lastModified } = await handle.getFile();
    inode.update({ size, mtimeMs: lastModified });
    this.index.set(path, inode);
  }
  /**
   * Do not use!
   * @deprecated @internal @hidden
   */
  async writeFile(path, data) {
    return this.write(path, data, 0);
  }
  async mkdir(path, options) {
    const inode = await super.mkdir(path, options);
    const handle = this.get("directory", dirname(path), "mkdir");
    const dir = await handle.getDirectoryHandle(basename(path), { create: true }).catch((ex) => _throw(convertException(ex, path)));
    this._handles.set(path, dir);
    return inode;
  }
  get(kind = null, path, syscall) {
    const handle = this._handles.get(path);
    if (!handle)
      throw ErrnoError.With("ENODATA", path, syscall);
    if (kind && !isKind(handle, kind))
      throw ErrnoError.With(kind == "directory" ? "ENOTDIR" : "EISDIR", path, syscall);
    return handle;
  }
};
var _WebAccess = {
  name: "WebAccess",
  options: {
    handle: { type: "object", required: true },
    metadata: { type: "string", required: false }
  },
  async create(options) {
    const fs = new WebAccessFS(options.handle);
    await fs._loadHandles("/", options.handle);
    await fs._loadMetadata(options.metadata);
    return fs;
  }
};
var WebAccess = _WebAccess;

// node_modules/@zenfs/dom/dist/IndexedDB.js
function wrap(request) {
  return new Promise((resolve, reject) => {
    request.onsuccess = () => resolve(request.result);
    request.onerror = (e) => {
      e.preventDefault();
      reject(convertException(request.error));
    };
  });
}
var IndexedDBTransaction = class extends AsyncTransaction {
  constructor(tx, store) {
    super(store);
    this.tx = tx;
    this.store = store;
    this._idb = tx.objectStore(store.name);
  }
  async keys() {
    return (await wrap(this._idb.getAllKeys())).filter((k) => typeof k == "string").map((k) => Number(k));
  }
  async get(id) {
    const data = await wrap(this._idb.get(id.toString()));
    if (data)
      this._cached(id, { size: data.byteLength }).add(data, 0);
    return data;
  }
  async set(id, data) {
    this._cached(id, { size: data.byteLength }).add(data, 0);
    await wrap(this._idb.put(data, id.toString()));
  }
  remove(id) {
    this.store.cache.delete(id);
    return wrap(this._idb.delete(id.toString()));
  }
  async commit() {
    const { promise, resolve, reject } = Promise.withResolvers();
    this.tx.oncomplete = () => resolve();
    this.tx.onerror = () => reject(convertException(this.tx.error));
    this.tx.commit();
    return promise;
  }
  async abort() {
    const { promise, resolve, reject } = Promise.withResolvers();
    this.tx.onabort = () => resolve();
    this.tx.onerror = () => reject(convertException(this.tx.error));
    this.tx.abort();
    return promise;
  }
};
async function createDB(name, indexedDB = globalThis.indexedDB) {
  const req = indexedDB.open(name);
  req.onupgradeneeded = () => {
    const db = req.result;
    if (db.objectStoreNames.contains(name)) {
      log_exports.warn("Found unexpected object store: " + name);
      db.deleteObjectStore(name);
    }
    db.createObjectStore(name);
  };
  return await wrap(req);
}
var IndexedDBStore = class {
  constructor(db) {
    this.db = db;
    this.cache = /* @__PURE__ */ new Map();
  }
  sync() {
    return Promise.resolve();
  }
  get name() {
    return this.db.name;
  }
  transaction() {
    const tx = this.db.transaction(this.name, "readwrite");
    return new IndexedDBTransaction(tx, this);
  }
};
var _IndexedDB = {
  name: "IndexedDB",
  options: {
    storeName: { type: "string", required: false },
    idbFactory: { type: "object", required: false }
  },
  async isAvailable({ idbFactory = globalThis.indexedDB }) {
    try {
      if (!(idbFactory instanceof IDBFactory))
        return false;
      const req = idbFactory.open("__zenfs_test");
      await wrap(req);
      return true;
    } catch {
      return false;
    } finally {
      idbFactory == null ? void 0 : idbFactory.deleteDatabase("__zenfs_test");
    }
  },
  async create(options) {
    const db = await createDB(options.storeName || "zenfs", options.idbFactory);
    const store = new IndexedDBStore(db);
    const fs = new StoreFS(store);
    if (options == null ? void 0 : options.disableAsyncCache) {
      log_exports.notice("Async preloading disabled for IndexedDB");
      return fs;
    }
    const tx = store.transaction();
    for (const id of await tx.keys()) {
      await tx.get(id);
    }
    return fs;
  }
};
var IndexedDB = _IndexedDB;

// node_modules/@zenfs/dom/dist/storage.js
var WebStorageStore = class {
  get name() {
    return WebStorage.name;
  }
  constructor(storage) {
    this.storage = storage;
  }
  /* node:coverage ignore next 10 */
  clear() {
    this.storage.clear();
  }
  clearSync() {
    this.storage.clear();
  }
  async sync() {
  }
  transaction() {
    return new SyncMapTransaction(this);
  }
  keys() {
    return Object.keys(this.storage).map((k) => Number(k));
  }
  get(key) {
    const data = this.storage.getItem(key.toString());
    if (typeof data != "string") {
      return;
    }
    return encodeASCII(data);
  }
  set(key, data) {
    try {
      this.storage.setItem(key.toString(), decodeASCII(data));
    } catch {
      throw new ErrnoError(Errno.ENOSPC, "Storage is full.");
    }
  }
  delete(key) {
    try {
      this.storage.removeItem(key.toString());
    } catch (e) {
      throw new ErrnoError(Errno.EIO, "Unable to delete key " + key + ": " + e);
    }
  }
};
var _WebStorage = {
  name: "WebStorage",
  options: {
    storage: { type: "object", required: false }
  },
  /**
   * @todo Consider replacing `instanceof` with a duck-typing check?
   */
  isAvailable(config) {
    return ((config == null ? void 0 : config.storage) ?? globalThis.localStorage) instanceof globalThis.Storage;
  },
  create({ storage = globalThis.localStorage }) {
    return new StoreFS(new WebStorageStore(storage));
  }
};
var WebStorage = _WebStorage;

// node_modules/@zenfs/dom/dist/xml.js
function get_stats(node) {
  const stats = {};
  for (const key of _inode_fields) {
    const value = node.getAttribute(key);
    if (value !== null && value !== void 0)
      stats[key] = parseInt(value, 16);
  }
  return new Inode(stats);
}
function set_stats(node, stats) {
  for (const key of Object.keys(stats)) {
    if (!(key in _inode_fields) || stats[key] === void 0)
      continue;
    node.setAttribute(key, stats[key].toString(16));
  }
}
function get_paths(node, contents = false) {
  let paths;
  try {
    const raw = contents ? node.textContent : node.getAttribute("paths");
    paths = JSON.parse(raw || "[]");
  } catch {
    paths = [];
  }
  return paths;
}
var XMLFS = class extends Sync(FileSystem) {
  constructor(root = new DOMParser().parseFromString("<fs></fs>", "application/xml").documentElement) {
    super(544763244, "xmltmpfs");
    this.root = root;
    try {
      this.mkdirSync("/", { uid: 0, gid: 0, mode: 511 });
    } catch (e) {
      const error = e;
      if (error.code != "EEXIST")
        throw error;
    }
  }
  renameSync(oldPath, newPath) {
    const node = this.get("rename", oldPath);
    this.remove("rename", node, oldPath);
    this.add("rename", node, newPath);
  }
  statSync(path) {
    return get_stats(this.get("stat", path));
  }
  createFileSync(path, options) {
    const parent = this.statSync(dirname(path));
    const inode = new Inode({
      mode: options.mode | constants_exports.S_IFREG,
      uid: parent.mode & constants_exports.S_ISUID ? parent.uid : options.uid,
      gid: parent.mode & constants_exports.S_ISGID ? parent.gid : options.gid
    });
    this.create("createFile", path, inode);
    return inode;
  }
  unlinkSync(path) {
    const node = this.get("unlink", path);
    if (get_stats(node).mode & constants_exports.S_IFDIR)
      throw ErrnoError.With("EISDIR", path, "unlink");
    this.remove("unlink", node, path);
  }
  rmdirSync(path) {
    var _a;
    const node = this.get("rmdir", path);
    if ((_a = node.textContent) == null ? void 0 : _a.length)
      throw ErrnoError.With("ENOTEMPTY", path, "rmdir");
    if (!(get_stats(node).mode & constants_exports.S_IFDIR))
      throw ErrnoError.With("ENOTDIR", path, "rmdir");
    this.remove("rmdir", node, path);
  }
  mkdirSync(path, options) {
    const parent = this.statSync(dirname(path));
    const inode = new Inode({
      mode: options.mode | constants_exports.S_IFDIR,
      uid: parent.mode & constants_exports.S_ISUID ? parent.uid : options.uid,
      gid: parent.mode & constants_exports.S_ISGID ? parent.gid : options.gid
    });
    this.create("mkdir", path, inode).textContent = "[]";
    return inode;
  }
  readdirSync(path) {
    const node = this.get("readdir", path);
    if (!(get_stats(node).mode & constants_exports.S_IFDIR))
      throw ErrnoError.With("ENOTDIR", path, "rmdir");
    try {
      return JSON.parse(node.textContent);
    } catch (e) {
      throw new ErrnoError(Errno.EIO, "Invalid directory listing: " + e, path, "readdir");
    }
  }
  linkSync(target, link) {
    const node = this.get("link", target);
    this.add("link", node, link);
  }
  touchSync(path, metadata) {
    const node = this.get("touch", path);
    set_stats(node, metadata);
  }
  syncSync() {
  }
  readSync(path, buffer, offset, end) {
    const node = this.get("read", path);
    const raw = encodeASCII(node.textContent.slice(offset, end));
    buffer.set(raw);
  }
  writeSync(path, buffer, offset) {
    const node = this.get("write", path);
    const data = decodeASCII(buffer);
    const after = node.textContent.slice(offset + data.length);
    node.textContent = node.textContent.slice(0, offset) + data + after;
  }
  toString() {
    return new XMLSerializer().serializeToString(this.root);
  }
  get(syscall, path) {
    const nodes = this.root.children;
    if (!nodes)
      throw ErrnoError.With("EIO", path, syscall);
    for (let i = 0; i < nodes.length; i++) {
      if (get_paths(nodes[i]).includes(path))
        return nodes[i];
    }
    throw ErrnoError.With("ENOENT", path, syscall);
  }
  create(syscall, path, stats) {
    if (this.existsSync(path))
      throw ErrnoError.With("EEXIST", path, syscall);
    const node = document.createElement("file");
    this.add(syscall, node, path);
    set_stats(node, new Inode({
      ...stats,
      uid: stats.mode
    }));
    this.root.append(node);
    return node;
  }
  add(syscall, node, path, contents = false) {
    const paths = get_paths(node, contents);
    paths.push(path);
    if (contents) {
      node.textContent = JSON.stringify(paths);
      return;
    }
    node.setAttribute("paths", JSON.stringify(paths));
    node.setAttribute("nlink", paths.length.toString(16));
    if (path != "/") {
      const parent = this.get(syscall, dirname(path));
      this.add(syscall, parent, basename(path), true);
    }
  }
  remove(syscall, node, path, contents = false) {
    const paths = get_paths(node, contents);
    const i = paths.indexOf(path);
    if (i == -1)
      return;
    paths.splice(i, 1);
    if (contents) {
      node.textContent = JSON.stringify(paths);
      return;
    }
    if (!paths.length) {
      node.remove();
    } else {
      node.setAttribute("paths", JSON.stringify(paths));
      node.setAttribute("nlink", paths.length.toString(16));
    }
    if (path != "/") {
      const parent = this.get(syscall, dirname(path));
      this.remove(syscall, parent, basename(path), true);
    }
  }
};
var _XML = {
  name: "XML",
  options: {
    root: { type: "object", required: false }
  },
  isAvailable() {
    return true;
  },
  create(options) {
    return new XMLFS(options.root);
  }
};
var XML = _XML;
export {
  IndexedDB,
  IndexedDBStore,
  IndexedDBTransaction,
  WebAccess,
  WebAccessFS,
  WebStorage,
  WebStorageStore,
  XML,
  XMLFS
};
//# sourceMappingURL=@zenfs_dom.js.map
