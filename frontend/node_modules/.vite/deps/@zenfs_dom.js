import {
  Async,
  AsyncTransaction,
  Errno,
  ErrnoError,
  FileSystem,
  InMemory,
  PreloadFile,
  SimpleTransaction,
  Stats,
  StoreFS,
  Sync,
  basename,
  constants_exports,
  decodeRaw,
  dirname,
  encodeRaw,
  join
} from "./chunk-HW2WK2AC.js";
import "./chunk-JV5O2B6D.js";
import "./chunk-2TUXWMP5.js";

// node_modules/@zenfs/dom/dist/utils.js
function errnoForDOMException(ex) {
  switch (ex.name) {
    case "IndexSizeError":
    case "HierarchyRequestError":
    case "InvalidCharacterError":
    case "InvalidStateError":
    case "SyntaxError":
    case "NamespaceError":
    case "TypeMismatchError":
    case "ConstraintError":
    case "VersionError":
    case "URLMismatchError":
    case "InvalidNodeTypeError":
      return "EINVAL";
    case "WrongDocumentError":
      return "EXDEV";
    case "NoModificationAllowedError":
    case "InvalidModificationError":
    case "InvalidAccessError":
    case "SecurityError":
    case "NotAllowedError":
      return "EACCES";
    case "NotFoundError":
      return "ENOENT";
    case "NotSupportedError":
      return "ENOTSUP";
    case "InUseAttributeError":
      return "EBUSY";
    case "NetworkError":
      return "ENETDOWN";
    case "AbortError":
      return "EINTR";
    case "QuotaExceededError":
      return "ENOSPC";
    case "TimeoutError":
      return "ETIMEDOUT";
    case "ReadOnlyError":
      return "EROFS";
    case "DataCloneError":
    case "EncodingError":
    case "NotReadableError":
    case "DataError":
    case "TransactionInactiveError":
    case "OperationError":
    case "UnknownError":
    default:
      return "EIO";
  }
}
function convertException(ex, path, syscall) {
  if (ex instanceof ErrnoError) {
    return ex;
  }
  const code = ex instanceof DOMException ? Errno[errnoForDOMException(ex)] : Errno.EIO;
  const error = new ErrnoError(code, ex.message, path, syscall);
  error.stack = ex.stack;
  error.cause = ex.cause;
  return error;
}

// node_modules/@zenfs/dom/dist/access.js
function isResizable(buffer) {
  if (buffer instanceof ArrayBuffer)
    return buffer.resizable;
  if (buffer instanceof SharedArrayBuffer)
    return buffer.growable;
  return false;
}
var WebAccessFS = class extends Async(FileSystem) {
  constructor(handle) {
    super();
    this._handles = /* @__PURE__ */ new Map();
    this._sync = InMemory.create({ name: "accessfs-cache" });
    this._handles.set("/", handle);
  }
  metadata() {
    return {
      ...super.metadata(),
      name: "WebAccess",
      noResizableBuffers: true,
      // Not really, but we don't support opening directories so this prevent the VFS from trying
      features: ["setid"]
    };
  }
  async sync(path, data) {
    await this.writeFile(path, data);
  }
  async rename(oldPath, newPath) {
    const handle = await this.getHandle(oldPath);
    if (handle instanceof FileSystemDirectoryHandle) {
      const files = await this.readdir(oldPath);
      await this.mkdir(newPath);
      if (!files.length) {
        await this.unlink(oldPath);
        return;
      }
      for (const file of files) {
        await this.rename(join(oldPath, file), join(newPath, file));
        await this.unlink(oldPath);
      }
      return;
    }
    if (!(handle instanceof FileSystemFileHandle)) {
      throw new ErrnoError(Errno.ENOTSUP, "Not a file or directory handle", oldPath, "rename");
    }
    const oldFile = await handle.getFile().catch((ex) => {
      throw convertException(ex, oldPath, "rename");
    }), destFolder = await this.getHandle(dirname(newPath));
    if (!(destFolder instanceof FileSystemDirectoryHandle)) {
      return;
    }
    const newFile = await destFolder.getFileHandle(basename(newPath), { create: true }).catch((ex) => {
      throw convertException(ex, newPath, "rename");
    });
    const writable = await newFile.createWritable();
    await writable.write(await oldFile.arrayBuffer());
    await writable.close();
    await this.unlink(oldPath);
  }
  async writeFile(path, data) {
    if (isResizable(data.buffer)) {
      throw new ErrnoError(Errno.EINVAL, "Resizable buffers can not be written", path, "write");
    }
    const handle = await this.getHandle(dirname(path));
    if (!(handle instanceof FileSystemDirectoryHandle)) {
      return;
    }
    const file = await handle.getFileHandle(basename(path), { create: true });
    const writable = await file.createWritable();
    await writable.write(data);
    await writable.close();
  }
  async createFile(path, flag) {
    await this.writeFile(path, new Uint8Array());
    return this.openFile(path, flag);
  }
  async stat(path) {
    const handle = await this.getHandle(path);
    if (!handle) {
      throw ErrnoError.With("ENOENT", path, "stat");
    }
    if (handle instanceof FileSystemDirectoryHandle) {
      return new Stats({ mode: 511 | constants_exports.S_IFDIR, size: 4096 });
    }
    if (handle instanceof FileSystemFileHandle) {
      const { lastModified, size } = await handle.getFile();
      return new Stats({ mode: 511 | constants_exports.S_IFREG, size, mtimeMs: lastModified });
    }
    throw new ErrnoError(Errno.EBADE, "Handle is not a directory or file", path, "stat");
  }
  async openFile(path, flag) {
    const handle = await this.getHandle(path);
    if (!(handle instanceof FileSystemFileHandle)) {
      throw ErrnoError.With("EISDIR", path, "openFile");
    }
    const file = await handle.getFile().catch((ex) => {
      throw convertException(ex, path, "openFile");
    });
    const data = new Uint8Array(await file.arrayBuffer());
    const stats = new Stats({ mode: 511 | constants_exports.S_IFREG, size: file.size, mtimeMs: file.lastModified });
    return new PreloadFile(this, path, flag, stats, data);
  }
  async unlink(path) {
    const handle = await this.getHandle(dirname(path));
    if (!(handle instanceof FileSystemDirectoryHandle)) {
      throw ErrnoError.With("ENOTDIR", dirname(path), "unlink");
    }
    await handle.removeEntry(basename(path), { recursive: true }).catch((ex) => {
      throw convertException(ex, path, "unlink");
    });
  }
  // eslint-disable-next-line @typescript-eslint/require-await
  async link(srcpath) {
    return;
  }
  async rmdir(path) {
    return this.unlink(path);
  }
  async mkdir(path, mode, options) {
    const existingHandle = await this.getHandle(path).catch((ex) => {
      if (ex.code != "ENOENT") {
        throw ex;
      }
    });
    if (existingHandle) {
      throw ErrnoError.With("EEXIST", path, "mkdir");
    }
    const handle = await this.getHandle(dirname(path));
    if (!(handle instanceof FileSystemDirectoryHandle)) {
      throw ErrnoError.With("ENOTDIR", path, "mkdir");
    }
    await handle.getDirectoryHandle(basename(path), { create: true });
  }
  async readdir(path) {
    const handle = await this.getHandle(path);
    if (!(handle instanceof FileSystemDirectoryHandle)) {
      throw ErrnoError.With("ENOTDIR", path, "readdir");
    }
    const entries = [];
    for await (const k of handle.keys()) {
      entries.push(k);
    }
    return entries;
  }
  async getHandle(path) {
    if (this._handles.has(path)) {
      return this._handles.get(path);
    }
    let walked = "/";
    for (const part of path.split("/").slice(1)) {
      const handle = this._handles.get(walked);
      if (!(handle instanceof FileSystemDirectoryHandle)) {
        throw ErrnoError.With("ENOTDIR", walked, "getHandle");
      }
      walked = join(walked, part);
      const child = await handle.getDirectoryHandle(part).catch((ex) => {
        switch (ex.name) {
          case "TypeMismatchError":
            return handle.getFileHandle(part).catch((ex2) => {
            });
          case "TypeError":
            throw new ErrnoError(Errno.ENOENT, ex.message, walked, "getHandle");
          default:
            throw convertException(ex, walked, "getHandle");
        }
      });
      if (child)
        this._handles.set(walked, child);
    }
    return this._handles.get(path);
  }
};
var _WebAccess = {
  name: "WebAccess",
  options: {
    handle: { type: "object", required: true }
  },
  isAvailable() {
    return typeof FileSystemHandle == "function";
  },
  create(options) {
    return new WebAccessFS(options.handle);
  }
};
var WebAccess = _WebAccess;

// node_modules/@zenfs/dom/dist/IndexedDB.js
function wrap(request) {
  return new Promise((resolve, reject) => {
    request.onsuccess = () => resolve(request.result);
    request.onerror = (e) => {
      e.preventDefault();
      reject(convertException(request.error));
    };
  });
}
var IndexedDBTransaction = class extends AsyncTransaction {
  constructor(tx, store) {
    super(store);
    this.tx = tx;
    this.store = store;
    this._idb = tx.objectStore(store.name);
  }
  async keys() {
    return (await wrap(this._idb.getAllKeys())).filter((k) => typeof k == "string").map((k) => BigInt(k));
  }
  get(key) {
    return wrap(this._idb.get(key.toString()));
  }
  async set(key, data) {
    await wrap(this._idb.put(data, key.toString()));
  }
  remove(key) {
    return wrap(this._idb.delete(key.toString()));
  }
  async commit() {
    if (this.done) {
      return;
    }
    const { promise, resolve, reject } = Promise.withResolvers();
    this.done = true;
    this.tx.oncomplete = () => resolve();
    this.tx.onerror = () => reject(convertException(this.tx.error));
    this.tx.commit();
    return promise;
  }
  async abort() {
    if (this.done) {
      return;
    }
    this.done = true;
    const { promise, resolve, reject } = Promise.withResolvers();
    this.tx.onabort = () => resolve();
    this.tx.onerror = () => reject(convertException(this.tx.error));
    this.tx.abort();
    return promise;
  }
};
async function createDB(name, indexedDB = globalThis.indexedDB) {
  const req = indexedDB.open(name);
  req.onupgradeneeded = () => {
    const db = req.result;
    if (db.objectStoreNames.contains(name)) {
      db.deleteObjectStore(name);
    }
    db.createObjectStore(name);
  };
  const result = await wrap(req);
  return result;
}
var IndexedDBStore = class {
  constructor(db) {
    this.db = db;
  }
  sync() {
    throw ErrnoError.With("ENOSYS", void 0, "IndexedDBStore.sync");
  }
  get name() {
    return this.db.name;
  }
  clear() {
    return wrap(this.db.transaction(this.name, "readwrite").objectStore(this.name).clear());
  }
  clearSync() {
    throw ErrnoError.With("ENOSYS", void 0, "IndexedDBStore.clearSync");
  }
  transaction() {
    const tx = this.db.transaction(this.name, "readwrite");
    return new IndexedDBTransaction(tx, this);
  }
};
var _IndexedDB = {
  name: "IndexedDB",
  options: {
    storeName: {
      type: "string",
      required: false
    },
    idbFactory: {
      type: "object",
      required: false
    }
  },
  async isAvailable(idbFactory = globalThis.indexedDB) {
    try {
      if (!(idbFactory instanceof IDBFactory)) {
        return false;
      }
      const req = idbFactory.open("__zenfs_test");
      await wrap(req);
      return true;
    } catch {
      return false;
    } finally {
      idbFactory.deleteDatabase("__zenfs_test");
    }
  },
  async create(options) {
    const db = await createDB(options.storeName || "zenfs", options.idbFactory);
    const store = new IndexedDBStore(db);
    const fs = new (Async(StoreFS))(store);
    if (!(options == null ? void 0 : options.disableAsyncCache)) {
      fs._sync = InMemory.create({ name: "idb-cache" });
    }
    return fs;
  }
};
var IndexedDB = _IndexedDB;

// node_modules/@zenfs/dom/dist/storage.js
var WebStorageStore = class {
  get name() {
    return WebStorage.name;
  }
  constructor(storage) {
    this.storage = storage;
  }
  /* node:coverage ignore next 10 */
  clear() {
    this.storage.clear();
  }
  clearSync() {
    this.storage.clear();
  }
  async sync() {
  }
  transaction() {
    return new SimpleTransaction(this);
  }
  keys() {
    return Object.keys(this.storage).map((k) => BigInt(k));
  }
  get(key) {
    const data = this.storage.getItem(key.toString());
    if (typeof data != "string") {
      return;
    }
    return encodeRaw(data);
  }
  set(key, data) {
    try {
      this.storage.setItem(key.toString(), decodeRaw(data));
    } catch {
      throw new ErrnoError(Errno.ENOSPC, "Storage is full.");
    }
  }
  delete(key) {
    try {
      this.storage.removeItem(key.toString());
    } catch (e) {
      throw new ErrnoError(Errno.EIO, "Unable to delete key " + key + ": " + e);
    }
  }
};
var _WebStorage = {
  name: "WebStorage",
  options: {
    storage: { type: "object", required: false }
  },
  /**
   * @todo Consider replacing `instanceof` with a duck-typing check?
   */
  isAvailable(storage = globalThis.localStorage) {
    return storage instanceof globalThis.Storage;
  },
  create({ storage = globalThis.localStorage }) {
    return new StoreFS(new WebStorageStore(storage));
  }
};
var WebStorage = _WebStorage;

// node_modules/@zenfs/dom/dist/xml.js
var statsLikeKeys = ["size", "mode", "atimeMs", "mtimeMs", "ctimeMs", "birthtimeMs", "uid", "gid", "ino", "nlink"];
function get_stats(node) {
  const stats = {};
  for (const key of statsLikeKeys) {
    const value = node.getAttribute(key);
    stats[key] = value != null ? parseInt(value, 16) : void 0;
  }
  return new Stats(stats);
}
function set_stats(node, stats) {
  for (const key of statsLikeKeys) {
    if (stats[key] != void 0) {
      node.setAttribute(key, stats[key].toString(16));
    }
  }
}
function get_paths(node, contents = false) {
  let paths;
  try {
    const raw = contents ? node.textContent : node.getAttribute("paths");
    paths = JSON.parse(raw || "[]");
  } catch {
    paths = [];
  }
  return paths;
}
var XMLFS = class extends Sync(FileSystem) {
  constructor(root = new DOMParser().parseFromString("<fs></fs>", "application/xml").documentElement) {
    super();
    this.root = root;
    try {
      this.mkdirSync("/", 511, { uid: 0, gid: 0 });
    } catch (e) {
      const error = e;
      if (error.code != "EEXIST")
        throw error;
    }
  }
  metadata() {
    return { ...super.metadata(), features: ["setid"] };
  }
  renameSync(oldPath, newPath) {
    const node = this.get("rename", oldPath);
    this.remove("rename", node, oldPath);
    this.add("rename", node, newPath);
  }
  statSync(path) {
    return get_stats(this.get("stat", path));
  }
  openFileSync(path, flag) {
    const node = this.get("openFile", path);
    return new PreloadFile(this, path, flag, get_stats(node), encodeRaw(node.textContent));
  }
  createFileSync(path, flag, mode, { uid, gid }) {
    const parent = this.statSync(dirname(path));
    const stats = new Stats({
      mode: mode | constants_exports.S_IFREG,
      uid: parent.mode & constants_exports.S_ISUID ? parent.uid : uid,
      gid: parent.mode & constants_exports.S_ISGID ? parent.gid : gid
    });
    this.create("createFile", path, stats);
    return new PreloadFile(this, path, flag, stats);
  }
  unlinkSync(path) {
    const node = this.get("unlink", path);
    if (get_stats(node).isDirectory())
      throw ErrnoError.With("EISDIR", path, "unlink");
    this.remove("unlink", node, path);
  }
  rmdirSync(path) {
    var _a;
    const node = this.get("rmdir", path);
    if ((_a = node.textContent) == null ? void 0 : _a.length)
      throw ErrnoError.With("ENOTEMPTY", path, "rmdir");
    if (!get_stats(node).isDirectory())
      throw ErrnoError.With("ENOTDIR", path, "rmdir");
    this.remove("rmdir", node, path);
  }
  mkdirSync(path, mode, { uid, gid }) {
    const parent = this.statSync(dirname(path));
    const node = this.create("mkdir", path, {
      mode: mode | constants_exports.S_IFDIR,
      uid: parent.mode & constants_exports.S_ISUID ? parent.uid : uid,
      gid: parent.mode & constants_exports.S_ISGID ? parent.gid : gid
    });
    node.textContent = "[]";
  }
  readdirSync(path) {
    const node = this.get("readdir", path);
    if (!get_stats(node).isDirectory())
      throw ErrnoError.With("ENOTDIR", path, "rmdir");
    try {
      return JSON.parse(node.textContent);
    } catch (e) {
      throw new ErrnoError(Errno.EIO, "Invalid directory listing: " + e, path, "readdir");
    }
  }
  linkSync(target, link) {
    const node = this.get("link", target);
    this.add("link", node, link);
  }
  syncSync(path, data, stats) {
    const node = this.get("sync", path);
    node.textContent = decodeRaw(data);
    set_stats(node, stats);
  }
  toString() {
    return new XMLSerializer().serializeToString(this.root);
  }
  get(syscall, path) {
    const nodes = this.root.children;
    if (!nodes)
      throw ErrnoError.With("EIO", path, syscall);
    for (let i = 0; i < nodes.length; i++) {
      if (get_paths(nodes[i]).includes(path))
        return nodes[i];
    }
    throw ErrnoError.With("ENOENT", path, syscall);
  }
  create(syscall, path, stats) {
    if (this.existsSync(path))
      throw ErrnoError.With("EEXIST", path, syscall);
    const node = document.createElement("file");
    this.add(syscall, node, path);
    set_stats(node, new Stats({
      ...stats,
      uid: stats.mode
    }));
    this.root.append(node);
    return node;
  }
  add(syscall, node, path, contents = false) {
    const paths = get_paths(node, contents);
    paths.push(path);
    if (contents) {
      node.textContent = JSON.stringify(paths);
      return;
    }
    node.setAttribute("paths", JSON.stringify(paths));
    node.setAttribute("nlink", paths.length.toString(16));
    if (path != "/") {
      const parent = this.get(syscall, dirname(path));
      this.add(syscall, parent, basename(path), true);
    }
  }
  remove(syscall, node, path, contents = false) {
    const paths = get_paths(node, contents);
    const i = paths.indexOf(path);
    if (i == -1)
      return;
    paths.splice(i, 1);
    if (contents) {
      node.textContent = JSON.stringify(paths);
      return;
    }
    if (!paths.length) {
      node.remove();
    } else {
      node.setAttribute("paths", JSON.stringify(paths));
      node.setAttribute("nlink", paths.length.toString(16));
    }
    if (path != "/") {
      const parent = this.get(syscall, dirname(path));
      this.remove(syscall, parent, basename(path), true);
    }
  }
};
var _XML = {
  name: "XML",
  options: {
    root: { type: "object", required: false }
  },
  isAvailable() {
    return true;
  },
  create(options) {
    return new XMLFS(options.root);
  }
};
var XML = _XML;
export {
  IndexedDB,
  IndexedDBStore,
  IndexedDBTransaction,
  WebAccess,
  WebAccessFS,
  WebStorage,
  WebStorageStore,
  XML,
  XMLFS
};
//# sourceMappingURL=@zenfs_dom.js.map
