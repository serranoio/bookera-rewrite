{
  "version": 3,
  "sources": ["../../@twind/src/internal/to-class-name.ts", "../../@twind/src/runtime.ts", "../../@twind/src/internal/format.ts", "../../@twind/src/utils.ts", "../../@twind/src/internal/precedence.ts", "../../@twind/src/internal/registry.ts", "../../@twind/src/internal/stringify.ts", "../../@twind/src/internal/sorted-insertion-index.ts", "../../@twind/src/colors.ts", "../../@twind/src/internal/serialize.ts", "../../@twind/src/internal/merge.ts", "../../@twind/src/internal/translate.ts", "../../@twind/src/internal/define.ts", "../../@twind/src/parse.ts", "../../@twind/src/internal/interleave.ts", "../../@twind/src/internal/interpolate.ts", "../../@twind/src/alias.ts", "../../@twind/src/internal/astish.ts", "../../@twind/src/css.ts", "../../@twind/src/animation.ts", "../../@twind/src/rules.ts", "../../@twind/src/autocomplete.ts", "../../@twind/src/cx.ts", "../../@twind/src/define-config.ts", "../../@twind/src/internal/warn.ts", "../../@twind/src/internal/context.ts", "../../@twind/src/twind.ts", "../../@twind/src/internal/theme.ts", "../../@twind/src/internal/changed.ts", "../../@twind/src/observe.ts", "../../@twind/src/sheets.ts", "../../@twind/src/inject-global.ts", "../../@twind/src/install.ts", "../../@twind/src/keyframes.ts", "../../@twind/src/ssr.ts", "../../@twind/src/internal/parse-html.ts", "../../@twind/src/style.ts", "../../@twind/src/tx.ts"],
  "sourcesContent": ["import type { ParsedRule } from '../parse'\n\nexport function toClassName(rule: ParsedRule): string {\n  return [...rule.v, (rule.i ? '!' : '') + rule.n].join(':')\n}\n", "import type {\n  Twind,\n  BaseTheme,\n  TwindConfig,\n  Sheet,\n  TwindUserConfig,\n  ExtractThemes,\n  Preset,\n} from './types'\n\nimport { twind } from './twind'\nimport { observe } from './observe'\nimport { getSheet } from './sheets'\nimport { noop } from './utils'\nimport { DEV } from 'distilt/env'\n\n/**\n * @group Runtime\n * @param install\n * @returns\n */\nexport function auto(install: () => void): () => void {\n  // If we run in the browser we call install at latest when the body is inserted\n  // This algorith works well for _normal_ scripts (`<script src=\"...\"></script>`)\n  // but not for modules because those are executed __after__ the DOM is ready\n  // and we would have FOUC\n  if (typeof document != 'undefined' && document.currentScript) {\n    const cancelAutoInstall = () => observer.disconnect()\n\n    const observer: MutationObserver = new MutationObserver((mutationsList) => {\n      for (const { target } of mutationsList) {\n        // If we reach the body we immediately run the install to prevent FOUC\n        if (target === document.body) {\n          install()\n          return cancelAutoInstall()\n        }\n      }\n    })\n\n    observer.observe(document.documentElement, {\n      childList: true,\n      subtree: true,\n    })\n\n    return cancelAutoInstall\n  }\n\n  return noop\n}\n\nlet active: Twind\n\nfunction assertActive() {\n  if (DEV && !active) {\n    throw new Error(\n      `No active twind instance found. Make sure to call setup or install before accessing tw.`,\n    )\n  }\n}\n\n/**\n * A proxy to the currently active Twind instance.\n * @group Style Injectors\n */\nexport const tw: Twind<any, any> = /* #__PURE__ */ new Proxy(\n  // just exposing the active as tw should work with most bundlers\n  // as ES module export can be re-assigned BUT some bundlers to not honor this\n  // -> using a delegation proxy here\n  noop as unknown as Twind<any, any>,\n  {\n    apply(_target, _thisArg, args) {\n      if (DEV) assertActive()\n\n      return active(args[0])\n    },\n    get(target, property) {\n      if (DEV) {\n        // Workaround webpack accessing the prototype in dev mode\n        if (!active && property in target) {\n          // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n          return (target as any)[property]\n        }\n\n        assertActive()\n      }\n\n      const value = active[property as keyof Twind]\n\n      if (typeof value === 'function') {\n        return function () {\n          if (DEV) assertActive()\n\n          // eslint-disable-next-line prefer-rest-params\n          return value.apply(active, arguments)\n        }\n      }\n\n      return value\n    },\n  },\n)\n\nexport type SheetFactory<SheetTarget = unknown> = () => Sheet<SheetTarget>\n\n/**\n * Manages a single Twind instance — works in browser, Node.js, Deno, workers...\n *\n * @group Runtime\n * @param config\n * @param sheet\n * @param target\n * @returns\n */\nexport function setup<Theme extends BaseTheme = BaseTheme, SheetTarget = unknown>(\n  config?: TwindConfig<Theme>,\n  sheet?: Sheet<SheetTarget> | SheetFactory<SheetTarget>,\n  target?: HTMLElement,\n): Twind<Theme, SheetTarget>\n\nexport function setup<\n  Theme = BaseTheme,\n  Presets extends Preset<any>[] = Preset[],\n  SheetTarget = unknown,\n>(\n  config?: TwindUserConfig<Theme, Presets>,\n  sheet?: Sheet<SheetTarget> | SheetFactory<SheetTarget>,\n  target?: HTMLElement,\n): Twind<BaseTheme & ExtractThemes<Theme, Presets>, SheetTarget>\n\nexport function setup<Theme extends BaseTheme = BaseTheme, SheetTarget = unknown>(\n  config: TwindConfig<any> | TwindUserConfig<any> = {},\n  sheet: Sheet<SheetTarget> | SheetFactory<SheetTarget> = getSheet as SheetFactory<SheetTarget>,\n  target?: HTMLElement,\n): Twind<Theme, SheetTarget> {\n  active?.destroy()\n\n  active = observe(\n    twind(config as TwindUserConfig, typeof sheet == 'function' ? sheet() : sheet),\n    target,\n  )\n\n  return active as unknown as Twind<Theme, SheetTarget>\n}\n", "import type { ParsedRule } from '../parse'\nimport { toClassName } from './to-class-name'\n\nexport function format(rules: ParsedRule[], seperator = ','): string {\n  return rules.map(toClassName).join(seperator)\n}\n", "import type { MaybeArray, ScreenValue } from './types'\n\n/**\n * @internal\n */\nexport const escape =\n  (typeof CSS !== 'undefined' && CSS.escape) ||\n  // Simplified: escaping only special characters\n  // Needed for NodeJS and Edge <79 (https://caniuse.com/mdn-api_css_escape)\n  ((className: string): string =>\n    className\n      // Simplifed escape testing only for chars that we know happen to be in tailwind directives\n      .replace(/[!\"'`*+.,;:\\\\/<=>?@#$%&^|~()[\\]{}]/g, '\\\\$&')\n      // If the character is the first character and is in the range [0-9] (2xl, ...)\n      // https://drafts.csswg.org/cssom/#escape-a-character-as-code-point\n      .replace(/^\\d/, '\\\\3$& '))\n\n// Based on https://stackoverflow.com/a/52171480\n/**\n * @group Configuration\n * @param value\n * @returns\n */\nexport function hash(value: string): string {\n  // eslint-disable-next-line no-var\n  for (var h = 9, index = value.length; index--; ) {\n    h = Math.imul(h ^ value.charCodeAt(index), 0x5f356495)\n  }\n\n  return '#' + ((h ^ (h >>> 9)) >>> 0).toString(36)\n}\n\n/**\n * @internal\n * @param screen\n * @param prefix\n * @returns\n */\nexport function mql(screen: MaybeArray<ScreenValue>, prefix = '@media '): string {\n  return (\n    prefix +\n    asArray(screen)\n      .map((screen) => {\n        if (typeof screen == 'string') {\n          screen = { min: screen }\n        }\n\n        return (\n          (screen as { raw?: string }).raw ||\n          Object.keys(screen)\n            .map((feature) => `(${feature}-width:${(screen as Record<string, string>)[feature]})`)\n            .join(' and ')\n        )\n      })\n      .join(',')\n  )\n}\n\n/**\n * @internal\n * @param value\n * @returns\n */\nexport function asArray<T>(value: T = [] as unknown as T): T extends Array<any> ? T : T[] {\n  return (Array.isArray(value) ? value : value == null ? [] : [value]) as T extends Array<any>\n    ? T\n    : T[]\n}\n\n/**\n * @internal\n * @param value\n * @returns\n */\nexport function identity<T>(value: T): T {\n  return value\n}\n\n/**\n * @internal\n */\nexport function noop(): void {\n  // no-op\n}\n", "import type { BaseTheme, Context } from '../types'\nimport type { ParsedRule } from '../parse'\nimport { asArray, mql } from '../utils'\nimport { toClassName } from './to-class-name'\n\n// Based on https://github.com/kripod/otion\n// License MIT\n\n// export const enum Shifts {\n//   darkMode = 30,\n//   layer = 27,\n//   screens = 26,\n//   responsive = 22,\n//   atRules = 18,\n//   variants = 0,\n// }\n\nexport const Layer = {\n  /**\n   * 1. `default` (public)\n   */\n  d /* efaults */: 0b000 << 27 /* Shifts.layer */,\n\n  /**\n   * 2. `base` (public) — for things like reset rules or default styles applied to plain HTML elements.\n   */\n  b /* ase */: 0b001 << 27 /* Shifts.layer */,\n\n  /**\n   * 3. `components` (public, used by `style()`) — is for class-based styles that you want to be able to override with utilities.\n   */\n  c /* omponents */: 0b010 << 27 /* Shifts.layer */,\n  // reserved for style():\n  // - props: 0b011\n  // - when: 0b100\n\n  /**\n   * 6. `aliases` (public, used by `apply()`) — `~(...)`\n   */\n  a /* liases */: 0b101 << 27 /* Shifts.layer */,\n\n  /**\n   * 6. `utilities` (public) — for small, single-purpose classes\n   */\n  u /* tilities */: 0b110 << 27 /* Shifts.layer */,\n\n  /**\n   * 7. `overrides` (public, used by `css()`)\n   */\n  o /* verrides */: 0b111 << 27 /* Shifts.layer */,\n} as const\n\n/*\nTo have a predictable styling the styles must be ordered.\n\nThis order is represented by a precedence number. The lower values\nare inserted before higher values. Meaning higher precedence styles\noverwrite lower precedence styles.\n\nEach rule has some traits that are put into a bit set which form\nthe precedence:\n\n| bits | trait                                                |\n| ---- | ---------------------------------------------------- |\n| 1    | dark mode                                            |\n| 2    | layer: preflight, global, components, utilities, css |\n| 1    | screens: is this a responsive variation of a rule    |\n| 5    | responsive based on min-width                        |\n| 4    | at-rules                                             |\n| 18   | pseudo and group variants                            |\n| 4    | number of declarations (descending)                  |\n| 4    | greatest precedence of properties                    |\n\n**Dark Mode: 1 bit**\n\nFlag for dark mode rules.\n\n**Layer: 3 bits**\n\n- defaults = 0: The preflight styles and any base styles registered by plugins.\n- base = 1: The global styles registered by plugins.\n- components = 2\n- variants = 3\n- compounds = 4\n- aliases = 5\n- utilities = 6: Utility classes and any utility classes registered by plugins.\n- css = 7: Styles generated by css\n\n**Screens: 1 bit**\n\nFlag for screen variants. They may not always have a `min-width` to be detected by _Responsive_ below.\n\n**Responsive: 4 bits**\n\nBased on extracted `min-width` value:\n\n- 576px -> 3\n- 1536px -> 10\n- 36rem -> 3\n- 96rem -> 9\n\n**At-Rules: 4 bits**\n\nBased on the count of special chars (`-:,`) within the at-rule.\n\n**Pseudo and group variants: 18 bits**\n\nEnsures predictable order of pseudo classes.\n\n- https://bitsofco.de/when-do-the-hover-focus-and-active-pseudo-classes-apply/#orderofstyleshoverthenfocusthenactive\n- https://developer.mozilla.org/docs/Web/CSS/:active#Active_links\n- https://github.com/tailwindlabs/tailwindcss/blob/master/stubs/defaultConfig.stub.js#L718\n\n**Number of declarations (descending): 4 bits**\n\nAllows single declaration styles to overwrite styles from multi declaration styles.\n\n**Greatest precedence of properties: 4 bits**\n\nEnsure shorthand properties are inserted before longhand properties; eg longhand override shorthand\n*/\n\nexport function moveToLayer(precedence: number, layer: number): number {\n  // Set layer (first reset, than set)\n  return (precedence & ~Layer.o) | layer\n}\n\n/*\nTo set a bit: n |= mask;\nTo clear a bit: n &= ~mask;\nTo test if a bit is set: (n & mask)\n\nBit shifts for the primary bits:\n\n| bits | trait                                                   | shift |\n| ---- | ------------------------------------------------------- | ----- |\n| 1    | dark mode                                               | 30    |\n| 3    | layer: preflight, global, components, utilities, css    | 27    |\n| 1    | screens: is this a responsive variation of a rule       | 26    |\n| 4    | responsive based on min-width, max-width or width       | 22    |\n| 4    | at-rules                                                | 18    |\n| 18   | pseudo and group variants                               | 0     |\n\nLayer: 0 - 7: 3 bits\n  - defaults: 0 << 27\n  - base: 1 << 27\n  - components: 2 << 27\n  - variants: 3 << 27\n  - joints: 4 << 27\n  - aliases: 5 << 27\n  - utilities: 6 << 27\n  - overrides: 7 << 27\n\nThese are calculated by serialize and added afterwards:\n\n| bits | trait                               |\n| ---- | ----------------------------------- |\n| 4    | number of selectors (descending)    |\n| 4    | number of declarations (descending) |\n| 4    | greatest precedence of properties   |\n\nThese are added by shifting the primary bits using multiplication as js only\nsupports bit shift up to 32 bits.\n*/\n\n// Colon and dash count of string (ascending)\nexport function seperatorPrecedence(string: string): number {\n  return string.match(/[-=:;]/g)?.length || 0\n}\n\nexport function atRulePrecedence(css: string): number {\n  // 0 - 15: 4 bits (max 144rem or 2304px)\n  // rem -> bit\n  // <20 ->  0 (<320px)\n  //  20 ->  1 (320px)\n  //  24 ->  2 (384px)\n  //  28 ->  3 (448px)\n  //  32 ->  4 (512px)\n  //  36 ->  5 (576px)\n  //  42 ->  6 (672px)\n  //  48 ->  7 (768px)\n  //  56 ->  8 (896px)\n  //  64 ->  9 (1024px)\n  //  72 -> 10 (1152px)\n  //  80 -> 11 (1280px)\n  //  96 -> 12 (1536px)\n  // 112 -> 13 (1792px)\n  // 128 -> 14 (2048px)\n  // 144 -> 15 (2304px)\n  // https://www.dcode.fr/function-equation-finder\n  return (\n    (Math.min(\n      /(?:^|width[^\\d]+)(\\d+(?:.\\d+)?)(p)?/.test(css)\n        ? Math.max(0, 29.63 * (+RegExp.$1 / (RegExp.$2 ? 15 : 1)) ** 0.137 - 43)\n        : 0,\n      15,\n    ) <<\n      22) /* Shifts.responsive */ |\n    (Math.min(seperatorPrecedence(css), 15) << 18) /* Shifts.atRules */\n  )\n}\n\n// Pesudo variant presedence\n// Chars 3 - 8: Uniquely identifies a pseudo selector\n// represented as a bit set for each relevant value\n// 18 bits: one for each variant plus one for unknown variants\n//\n// ':group-*' variants are normalized to their native pseudo class (':group-hover' -> ':hover')\n// as they already have a higher selector presedence due to the add '.group' ('.group:hover .group-hover:...')\n\n// Sources:\n// - https://bitsofco.de/when-do-the-hover-focus-and-active-pseudo-classes-apply/#orderofstyleshoverthenfocusthenactive\n// - https://developer.mozilla.org/docs/Web/CSS/:active#Active_links\n// - https://github.com/tailwindlabs/tailwindcss/blob/master/stubs/defaultConfig.stub.js#L931\n\nconst PRECEDENCES_BY_PSEUDO_CLASS = [\n  /* fi */ 'rst-c' /* hild: 0 */,\n  /* la */ 'st-ch' /* ild: 1 */,\n  // even and odd use: nth-child\n  /* nt */ 'h-chi' /* ld: 2 */,\n  /* an */ 'y-lin' /* k: 3 */,\n  /* li */ 'nk' /* : 4 */,\n  /* vi */ 'sited' /* : 5 */,\n  /* ch */ 'ecked' /* : 6 */,\n  /* em */ 'pty' /* : 7 */,\n  /* re */ 'ad-on' /* ly: 8 */,\n  /* fo */ 'cus-w' /* ithin : 9 */,\n  /* ho */ 'ver' /* : 10 */,\n  /* fo */ 'cus' /* : 11 */,\n  /* fo */ 'cus-v' /* isible : 12 */,\n  /* ac */ 'tive' /* : 13 */,\n  /* di */ 'sable' /* d : 14 */,\n  /* op */ 'tiona' /* l: 15 */,\n  /* re */ 'quire' /* d: 16 */,\n]\n\nfunction pseudoPrecedence(selector: string): number {\n  // use first found pseudo-class\n\n  return (\n    1 <<\n    ~(\n      (/:([a-z-]+)/.test(selector) &&\n        ~PRECEDENCES_BY_PSEUDO_CLASS.indexOf(RegExp.$1.slice(2, 7))) ||\n      ~17\n    )\n  )\n}\n\n// https://github.com/kripod/otion/blob/main/packages/otion/src/propertyMatchers.ts\n// \"+1\": [\n// \t/* ^border-.*(w|c|sty) */\n// \t\"border-.*(width,color,style)\",\n\n// \t/* ^[tlbr].{2,4}m?$ */\n// \t\"top\",\n// \t\"left\",\n// \t\"bottom\",\n// \t\"right\",\n\n// \t/* ^c.{7}$ */\n// \t\"continue\",\n\n// \t/* ^c.{8}$ */\n// \t\"container\",\n// ],\n\n// \"-1\": [\n// \t/* ^[fl].{5}l */\n// \t\"flex-flow\",\n// \t\"line-clamp\",\n\n// \t/* ^g.{8}$ */\n// \t\"grid-area\",\n\n// \t/* ^pl */\n// \t\"place-content\",\n// \t\"place-items\",\n// \t\"place-self\",\n\n// ],\n\n// group: 1 => +1\n// group: 2 => -1\n\n// 0 - 15 => 4 bits\n// Ignore vendor prefixed and custom properties\nexport function declarationPropertyPrecedence(property: string): number {\n  return property[0] == '-'\n    ? 0\n    : seperatorPrecedence(property) +\n        (/^(?:(border-(?!w|c|sty)|[tlbr].{2,4}m?$|c.{7,8}$)|([fl].{5}l|g.{8}$|pl))/.test(property)\n          ? +!!RegExp.$1 /* +1 */ || -!!RegExp.$2 /* -1 */\n          : 0) +\n        1\n}\n\nexport interface ConvertedRule {\n  /** The name to use for `&` expansion in selectors. Maybe empty for at-rules like `@import`, `@font-face`, `@media`, ... */\n  n?: string | undefined\n\n  /** The calculated precedence taking all variants into account. */\n  p: number\n\n  /** The rulesets (selectors and at-rules). expanded variants `@media ...`, `@supports ...`, `&:focus`, `.dark &` */\n  r?: string[]\n\n  /** Is this rule `!important` eg something like `!underline` or `!bg-red-500` or `!red-500` */\n  i?: boolean | undefined\n}\n\nexport function convert<Theme extends BaseTheme = BaseTheme>(\n  { n: name, i: important, v: variants = [] }: Partial<ParsedRule>,\n  context: Context<Theme>,\n  precedence: number,\n  conditions?: string[],\n): ConvertedRule {\n  if (name) {\n    name = toClassName({ n: name, i: important, v: variants })\n  }\n\n  conditions = [...asArray(conditions)]\n\n  for (const variant of variants) {\n    const screen = context.theme('screens', variant)\n\n    for (const condition of asArray((screen && mql(screen)) || context.v(variant))) {\n      conditions.push(condition)\n\n      precedence |= screen\n        ? (1 << 26) /* Shifts.screens */ | atRulePrecedence(condition)\n        : variant == 'dark'\n        ? 1 << 30 /* Shifts.darkMode */\n        : condition[0] == '@'\n        ? atRulePrecedence(condition)\n        : pseudoPrecedence(condition)\n    }\n  }\n\n  return { n: name, p: precedence, r: conditions, i: important }\n}\n", "import type { BaseTheme, Context, Falsey, RuleResult, TwindRule } from '../types'\nimport type { ParsedRule } from '../parse'\n\nconst registry = new Map<string, RegisterCallback>()\n\nexport type RegisterCallback = (rule: ParsedRule, context: Context) => Falsey | TwindRule[]\n\nexport function register(className: string, factory: RegisterCallback): string {\n  registry.set(className, factory)\n  return className\n}\n\nexport function resolve<Theme extends BaseTheme = BaseTheme>(\n  rule: ParsedRule,\n  context: Context<Theme>,\n): RuleResult | TwindRule[] {\n  const factory = registry.get(rule.n)\n\n  return factory ? factory(rule, context as any) : context.r(rule.n, rule.v[0] == 'dark')\n}\n", "import type { TwindRule } from '../types'\nimport { escape } from '../utils'\n\nexport function stringify(rule: TwindRule): string | undefined {\n  if (rule.d) {\n    const groups: string[] = []\n\n    const selector = replaceEach(\n      // merge all conditions into a selector string\n      rule.r.reduce((selector, condition) => {\n        if (condition[0] == '@') {\n          groups.push(condition)\n          return selector\n        }\n\n        // Go over the selector and replace the matching multiple selectors if any\n        return condition ? merge(selector, condition) : selector\n      }, '&'),\n      // replace '&' with rule name or an empty string\n      (selectorPart) => replaceReference(selectorPart, rule.n ? '.' + escape(rule.n) : ''),\n    )\n\n    if (selector) {\n      groups.push(selector.replace(/:merge\\((.+?)\\)/g, '$1'))\n    }\n\n    return groups.reduceRight((body, grouping) => grouping + '{' + body + '}', rule.d)\n  }\n}\n\nfunction replaceEach(selector: string, iteratee: (selectorPart: string) => string): string {\n  return selector.replace(\n    / *((?:\\(.+?\\)|\\[.+?\\]|[^,])+) *(,|$)/g,\n    (_, selectorPart: string, comma: string) => iteratee(selectorPart) + comma,\n  )\n}\n\nfunction replaceReference(selector: string, reference: string): string {\n  return selector.replace(/&/g, reference)\n}\n\nfunction merge(selector: string, condition: string): string {\n  return replaceEach(selector, (selectorPart) =>\n    replaceEach(\n      condition,\n      // If the current condition has a nested selector replace it\n      (conditionPart) => {\n        const mergeMatch = /(:merge\\(.+?\\))(:[a-z-]+|\\\\[.+])/.exec(conditionPart)\n\n        if (mergeMatch) {\n          const selectorIndex = selectorPart.indexOf(mergeMatch[1])\n\n          if (~selectorIndex) {\n            // [':merge(.group):hover .rule', ':merge(.group):focus &'] -> ':merge(.group):focus:hover .rule'\n            // ':merge(.group)' + ':focus' + ':hover .rule'\n            return (\n              selectorPart.slice(0, selectorIndex) +\n              mergeMatch[0] +\n              selectorPart.slice(selectorIndex + mergeMatch[1].length)\n            )\n          }\n\n          // [':merge(.peer):focus~&', ':merge(.group):hover &'] -> ':merge(.peer):focus~:merge(.group):hover &'\n          return replaceReference(selectorPart, conditionPart)\n        }\n\n        // Return the current selector with the key matching multiple selectors if any\n        return replaceReference(conditionPart, selectorPart)\n      },\n    ),\n  )\n}\n", "import { Layer } from './precedence'\n\nconst collator = new Intl.Collator('en', { numeric: true })\n\nexport interface SortableRule {\n  /** The calculated precedence taking all variants into account. */\n  p: number\n\n  /* The precedence of the properties within {@link d}. */\n  o: number\n\n  /** The name to use for `&` expansion in selectors. Maybe empty for at-rules like `@import`, `@font-face`, `@media`, ... */\n  n?: string | null\n}\n\n/**\n * Find the array index of where to add an element to keep it sorted.\n *\n * @returns The insertion index\n */\nexport function sortedInsertionIndex(\n  array: readonly SortableRule[],\n  element: SortableRule,\n): number {\n  // Find position using binary search\n  // eslint-disable-next-line no-var\n  for (var low = 0, high = array.length; low < high; ) {\n    const pivot = (high + low) >> 1\n\n    // Less-Then-Equal to add new equal element after all existing equal elements (stable sort)\n    if (compareTwindRules(array[pivot], element) <= 0) {\n      low = pivot + 1\n    } else {\n      high = pivot\n    }\n  }\n\n  return high\n}\n\nexport function compareTwindRules(a: SortableRule, b: SortableRule): number {\n  // base and overrides (css) layers are kept in order they are declared\n  const layer = a.p & Layer.o\n\n  if (layer == (b.p & Layer.o) && (layer == Layer.b || layer == Layer.o)) {\n    return 0\n  }\n\n  return (\n    a.p - b.p ||\n    a.o - b.o ||\n    collator.compare(byModifier(a.n), byModifier(b.n)) ||\n    collator.compare(byName(a.n), byName(b.n))\n  )\n}\n\nfunction byModifier(s: string | null | undefined) {\n  return ((s || '').split(/:/).pop() as string).split('/').pop() || '\\x00'\n}\n\nfunction byName(s: string | null | undefined) {\n  return (s || '').replace(/\\W/g, (c) => String.fromCharCode(127 + c.charCodeAt(0))) + '\\x00'\n}\n", "import type { ColorValue, ColorFunctionOptions, Context, Falsey } from './types'\n\nfunction parseColorComponent(chars: string, factor: number): number {\n  return Math.round(parseInt(chars, 16) * factor)\n}\n\n/**\n * @internal\n * @param color\n * @param options\n * @returns\n */\nexport function toColorValue(color: ColorValue, options: ColorFunctionOptions = {}): string {\n  if (typeof color == 'function') {\n    return color(options)\n  }\n\n  const { opacityValue = '1', opacityVariable } = options\n  const opacity = opacityVariable ? `var(${opacityVariable})` : opacityValue\n\n  if (color.includes('<alpha-value>')) {\n    return color.replace('<alpha-value>', opacity)\n  }\n\n  // rgb hex: #0123 and #001122\n  if (color[0] == '#' && (color.length == 4 || color.length == 7)) {\n    const size = (color.length - 1) / 3\n    const factor = [17, 1, 0.062272][size - 1]\n\n    return `rgba(${[\n      parseColorComponent(color.substr(1, size), factor),\n      parseColorComponent(color.substr(1 + size, size), factor),\n      parseColorComponent(color.substr(1 + 2 * size, size), factor),\n      opacity,\n    ]})`\n  }\n\n  if (opacity == '1') return color\n  if (opacity == '0') return '#0000'\n\n  // convert rgb and hsl to alpha variant\n  return color.replace(/^(rgb|hsl)(\\([^)]+)\\)$/, `$1a$2,${opacity})`)\n}\n\n/**\n * Looks for a matching dark color within a [tailwind color palette](https://tailwindcss.com/docs/customizing-colors) (`50`, `100`, `200`, ..., `800`, `900`).\n *\n * ```js\n * defineConfig({\n *   darkColor: autoDarkColor,\n * })\n * ```\n *\n * **Note**: Does not work for arbitrary values like `[theme(colors.gray.500)]` or `[theme(colors.gray.500, #ccc)]`.\n *\n * @group Configuration\n * @param section within theme to use\n * @param key of the light color or an arbitrary value\n * @param context to use\n * @returns the dark color if found\n */\nexport function autoDarkColor(\n  section: string,\n  key: string,\n  { theme }: Context<any>,\n): ColorValue | Falsey {\n  // 50 -> 900, 100 -> 800, ..., 800 -> 100, 900 -> 50\n  // key: gray-50, gray.50\n  key = key.replace(\n    /\\d+$/,\n    (shade) =>\n      // ~~(parseInt(shade, 10) / 100): 50 -> 0, 900 -> 9\n      // (9 - 0) -> 900, (9 - 9) -> 50\n      ((9 - ~~(parseInt(shade, 10) / 100) || 0.5) * 100) as any,\n  )\n\n  return theme(section as 'colors', key)\n}\n", "import type {\n  CSSObject,\n  Falsey,\n  Context,\n  TwindRule,\n  BaseTheme,\n  MaybeArray,\n  ColorValue,\n} from '../types'\nimport type { ParsedRule } from '../parse'\nimport type { ConvertedRule } from './precedence'\nimport { Layer, moveToLayer } from './precedence'\nimport { mql, hash, asArray } from '../utils'\n\nimport { atRulePrecedence, declarationPropertyPrecedence, convert } from './precedence'\nimport { stringify } from './stringify'\nimport { translateWith } from './translate'\nimport { parse } from '../parse'\nimport { compareTwindRules } from './sorted-insertion-index'\nimport { toColorValue } from '../colors'\n\nexport function serialize<Theme extends BaseTheme = BaseTheme>(\n  style: CSSObject | Falsey,\n  rule: Partial<ParsedRule>,\n  context: Context<Theme>,\n  precedence: number,\n  conditions: string[] = [],\n): TwindRule[] {\n  return serialize$(style, convert(rule, context, precedence, conditions), context)\n}\n\nfunction serialize$<Theme extends BaseTheme = BaseTheme>(\n  style: CSSObject | Falsey,\n  { n: name, p: precedence, r: conditions = [], i: important }: ConvertedRule,\n  context: Context<Theme>,\n): TwindRule[] {\n  const rules: TwindRule[] = []\n\n  // The generated declaration block eg body of the css rule\n  let declarations = ''\n\n  // This ensures that 'border-top-width' has a higher precedence than 'border-top'\n  let maxPropertyPrecedence = 0\n\n  // More specific utilities have less declarations and a higher precedence\n  let numberOfDeclarations = 0\n\n  for (let key in style || {}) {\n    const value = (style as Record<string, unknown>)[key]\n\n    if (key[0] == '@') {\n      // at rules: https://developer.mozilla.org/en-US/docs/Web/CSS/At-rule\n      if (!value) continue\n\n      // @apply ...;\n      if (key[1] == 'a') {\n        rules.push(\n          ...translateWith(\n            name as string,\n            precedence,\n            parse('' + value),\n            context,\n            precedence,\n            conditions,\n            important,\n            true /* useOrderOfRules */,\n          ),\n        )\n        continue\n      }\n\n      // @layer <layer>\n      if (key[1] == 'l') {\n        for (const css of asArray(value as MaybeArray<CSSObject>)) {\n          rules.push(\n            ...serialize$(\n              css,\n              {\n                n: name,\n                p: moveToLayer(precedence, Layer[key[7] as 'b']),\n                r: key[7] == 'd' ? [] : conditions,\n                i: important,\n              },\n              context,\n            ),\n          )\n        }\n\n        continue\n      }\n\n      // @import\n      if (key[1] == 'i') {\n        rules.push(\n          ...asArray(value).map((value) => ({\n            // before all layers\n            p: -1,\n            o: 0,\n            r: [],\n            d: key + ' ' + (value as string),\n          })),\n        )\n        continue\n      }\n\n      // @keyframes\n      if (key[1] == 'k') {\n        // Use defaults layer\n        rules.push({\n          p: Layer.d,\n          o: 0,\n          r: [key],\n          d: serialize$(value as CSSObject, { p: Layer.d }, context)\n            .map(stringify)\n            .join(''),\n        })\n        continue\n      }\n\n      // @font-face\n      // TODO @font-feature-values\n      if (key[1] == 'f') {\n        // Use defaults layer\n        rules.push(\n          ...asArray(value).map((value) => ({\n            p: Layer.d,\n            o: 0,\n            r: [key],\n            d: serialize$(value as CSSObject, { p: Layer.d }, context)\n              .map(stringify)\n              .join(''),\n          })),\n        )\n        continue\n      }\n      // -> All other are handled below; same as selector\n    }\n\n    // @media\n    // @supports\n    // selector\n    if (typeof value == 'object' && !Array.isArray(value)) {\n      // at-rule or non-global selector\n      if (key[0] == '@' || key.includes('&')) {\n        let rulePrecedence = precedence\n        if (key[0] == '@') {\n          // Handle `@media screen(sm)` and `@media (screen(sm) or ...)`\n          key = key.replace(/\\bscreen\\(([^)]+)\\)/g, (_, screenKey) => {\n            const screen = context.theme('screens', screenKey)\n\n            if (screen) {\n              rulePrecedence |= 1 << 26 /* Shifts.screens */\n              return mql(screen, '')\n            }\n\n            return _\n          })\n\n          rulePrecedence |= atRulePrecedence(key)\n        }\n\n        rules.push(\n          ...serialize$(\n            value as CSSObject,\n            {\n              n: name,\n              p: rulePrecedence,\n              r: [...conditions, key],\n              i: important,\n            },\n            context,\n          ),\n        )\n      } else {\n        // global selector\n        rules.push(\n          ...serialize$(value as CSSObject, { p: precedence, r: [...conditions, key] }, context),\n        )\n      }\n    } else if (key == 'label' && value) {\n      name = (value as string) + hash(JSON.stringify([precedence, important, style]))\n    } else if (value || value === 0) {\n      // property -> hyphenate\n      key = key.replace(/[A-Z]/g, (_) => '-' + _.toLowerCase())\n\n      // Update precedence\n      numberOfDeclarations += 1\n      maxPropertyPrecedence = Math.max(maxPropertyPrecedence, declarationPropertyPrecedence(key))\n\n      declarations +=\n        (declarations ? ';' : '') +\n        asArray(value)\n          .map((value) =>\n            context.s(\n              key,\n              // support theme(...) function in values\n              // calc(100vh - theme('spacing.12'))\n              resolveThemeFunction('' + value, context.theme) + (important ? ' !important' : ''),\n            ),\n          )\n          .join(';')\n    }\n  }\n\n  // PERF: prevent unshift using `rules = [{}]` above and then `rules[0] = {...}`\n  rules.unshift({\n    n: name,\n\n    p: precedence,\n\n    o:\n      // number of declarations (descending)\n      Math.max(0, 15 - numberOfDeclarations) +\n      // greatest precedence of properties\n      // if there is no property precedence this is most likely a custom property only declaration\n      // these have the highest precedence\n      Math.min(maxPropertyPrecedence || 15, 15) * 1.5,\n\n    r: conditions,\n\n    // stringified declarations\n    d: declarations,\n  })\n\n  return rules.sort(compareTwindRules)\n}\n\nexport function resolveThemeFunction<Theme extends BaseTheme = BaseTheme>(\n  value: string,\n  theme: Context<Theme>['theme'],\n): string {\n  // support theme(...) function in values\n  // calc(100vh - theme('spacing.12'))\n  // theme('borderColor.DEFAULT', 'currentColor')\n\n  // PERF: check for theme before running the regexp\n  // if (value.includes('theme')) {\n  return value.replace(\n    /theme\\(([\"'`])?(.+?)\\1(?:\\s*,\\s*([\"'`])?(.+?)\\3)?\\)/g,\n    (_, __, key: string, ___, defaultValue = '') => {\n      const value = theme(key, defaultValue)\n\n      if (typeof value == 'function' && /color|fill|stroke/i.test(key)) {\n        return toColorValue(value as ColorValue)\n      }\n\n      return '' + asArray(value as unknown).filter((v) => Object(v) !== v)\n    },\n  )\n  // }\n\n  // return value\n}\n", "import type { TwindRule } from '../types'\n\nexport function merge(rules: TwindRule[], name: string): TwindRule[] {\n  // merge:\n  // - same conditions\n  // - replace name with hash of name + condititions + declarations\n  // - precedence:\n  //   - combine bits or use max precendence\n  //   - set layer bit to merged\n  const result: TwindRule[] = []\n\n  let current: TwindRule | undefined\n\n  for (const rule of rules) {\n    // only merge rules with declarations and names (eg no global rules)\n    if (!(rule.d && rule.n)) {\n      result.push({ ...rule, n: rule.n && name })\n    } else if (current?.p == rule.p && '' + current.r == '' + rule.r) {\n      current.c = [current.c, rule.c].filter(Boolean).join(' ')\n      current.d = current.d + ';' + rule.d\n    } else {\n      // only set name for named rules eg not for global or className propagation rules\n      result.push((current = { ...rule, n: rule.n && name }))\n    }\n  }\n\n  return result\n}\n", "import type { TwindRule, Context, BaseTheme } from '../types'\nimport type { ParsedRule } from '../parse'\n\nimport { parse } from '../parse'\nimport { convert, Layer, moveToLayer } from './precedence'\n\nimport { resolve } from './registry'\nimport { serialize } from './serialize'\nimport { sortedInsertionIndex } from './sorted-insertion-index'\nimport { toClassName } from './to-class-name'\nimport { asArray } from '../utils'\nimport { merge } from './merge'\n\nexport function translate<Theme extends BaseTheme = BaseTheme>(\n  rules: readonly ParsedRule[],\n  context: Context<Theme>,\n  precedence = Layer.u,\n  conditions?: string[],\n  important?: boolean,\n): TwindRule[] {\n  // Sorted by precedence\n  const result: TwindRule[] = []\n\n  for (const rule of rules) {\n    for (const cssRule of translate$(rule, context, precedence, conditions, important)) {\n      result.splice(sortedInsertionIndex(result, cssRule), 0, cssRule)\n    }\n  }\n\n  return result\n}\n\nfunction translate$<Theme extends BaseTheme = BaseTheme>(\n  rule: ParsedRule,\n  context: Context<Theme>,\n  precedence: number,\n  conditions?: string[],\n  important?: boolean,\n): TwindRule[] {\n  rule = { ...rule, i: rule.i || important }\n\n  const resolved = resolve(rule, context)\n\n  if (!resolved) {\n    // propagate className as is\n    return [{ c: toClassName(rule), p: 0, o: 0, r: [] }]\n  }\n\n  // a list of class names\n  if (typeof resolved == 'string') {\n    ;({ r: conditions, p: precedence } = convert(rule, context, precedence, conditions))\n\n    return merge(translate(parse(resolved), context, precedence, conditions, rule.i), rule.n)\n  }\n\n  if (Array.isArray(resolved)) {\n    return resolved.map((rule) => ({\n      o: 0,\n      ...rule,\n      r: [...asArray(conditions), ...asArray(rule.r)],\n      p: moveToLayer(precedence, rule.p ?? precedence),\n    }))\n  }\n\n  return serialize(resolved, rule, context, precedence, conditions)\n}\n\nexport function translateWith<Theme extends BaseTheme = BaseTheme>(\n  name: string,\n  layer: number,\n  rules: ParsedRule[],\n  context: Context<Theme>,\n  precedence: number,\n  conditions?: string[] | undefined,\n  important?: boolean | undefined,\n  useOrderOfRules?: boolean,\n) {\n  return merge(\n    (useOrderOfRules\n      ? rules.flatMap((rule) => translate([rule], context, precedence, conditions, important))\n      : translate(rules, context, precedence, conditions, important)\n    ).map((rule) =>\n      // do not move defaults\n      // move only rules with a name unless they are in the base layer\n      rule.p & Layer.o && (rule.n || layer == Layer.b)\n        ? { ...rule, p: moveToLayer(rule.p, layer), o: 0 }\n        : rule,\n    ),\n    name,\n  )\n}\n", "import type { Falsey } from '../types'\nimport type { ParsedRule } from '../parse'\nimport { convert } from './precedence'\nimport { register } from './registry'\nimport { translateWith } from './translate'\n\nexport function define(\n  className: string,\n  layer: number,\n  rules: Falsey | ParsedRule[],\n  useOrderOfRules?: boolean,\n): string {\n  return register(className, (rule, context) => {\n    const { n: name, p: precedence, r: conditions, i: important } = convert(rule, context, layer)\n\n    return (\n      rules &&\n      translateWith(\n        name as string,\n        layer,\n        rules,\n        context,\n        precedence,\n        conditions,\n        important,\n        useOrderOfRules,\n      )\n    )\n  })\n}\n", "import { DEV } from 'distilt/env'\n\nimport { hash } from './utils'\nimport { define } from './internal/define'\nimport { format } from './internal/format'\nimport { Layer } from './internal/precedence'\n\nexport interface ParsedRule {\n  /**\n   * The utility name including `-` if set, but without `!` and variants\n   */\n  readonly n: string\n\n  /**\n   * All variants without trailing colon: `hover`, `after:`, `[...]`\n   */\n  readonly v: string[]\n\n  /**\n   * Something like `!underline` or `!bg-red-500` or `!red-500`\n   */\n  readonly i?: boolean\n}\n\nexport interface ParsedDevRule extends ParsedRule {\n  readonly a: string[]\n  readonly l: [start: number, end: number]\n}\n\nfunction createRule(\n  active: string[],\n  current: ParsedRule[][],\n  loc?: ParsedDevRule['l'] | false,\n): void {\n  if (active[active.length - 1] != '(') {\n    const variants: string[] = []\n    let important = false\n    let negated = false\n    let name = ''\n\n    for (let value of active) {\n      if (value == '(' || /[~@]$/.test(value)) continue\n\n      if (value[0] == '!') {\n        value = value.slice(1)\n        important = !important\n      }\n\n      if (value.endsWith(':')) {\n        variants[value == 'dark:' ? 'unshift' : 'push'](value.slice(0, -1))\n        continue\n      }\n\n      if (value[0] == '-') {\n        value = value.slice(1)\n        negated = !negated\n      }\n\n      if (value.endsWith('-')) {\n        value = value.slice(0, -1)\n      }\n\n      if (value && value != '&') {\n        name += (name && '-') + value\n      }\n    }\n\n    if (name) {\n      if (negated) name = '-' + name\n\n      current[0].push(\n        DEV\n          ? Object.defineProperties(\n              { n: name, v: variants.filter(uniq), i: important },\n              {\n                a: { value: [...active] },\n                l: { value: loc },\n              },\n            )\n          : { n: name, v: variants.filter(uniq), i: important },\n      )\n    }\n  }\n}\n\nfunction uniq<T>(value: T, index: number, values: T[]): boolean {\n  return values.indexOf(value) == index\n}\n\nconst cache = new Map<string, ParsedRule[]>()\n\n/**\n * @internal\n * @param token\n * @returns\n */\nexport function parse(token: string): ParsedRule[] {\n  let parsed = cache.get(token)\n\n  if (!parsed) {\n    // Stack of active groupings (`(`), variants, or nested (`~` or `@`)\n    const active: string[] = []\n\n    // Stack of current rule list to put new rules in\n    // the first `0` element is the current list\n    const current: ParsedRule[][] = [[]]\n\n    let startIndex = 0\n    let skip = 0\n    let comment: RegExp | null = null\n    let position = 0\n\n    // eslint-disable-next-line no-inner-declarations\n    const commit = (isRule?: boolean, endOffset = 0) => {\n      if (startIndex != position) {\n        active.push(token.slice(startIndex, position + endOffset))\n\n        if (isRule) {\n          createRule(active, current, DEV && [startIndex, position + endOffset])\n        }\n      }\n      startIndex = position + 1\n    }\n\n    for (; position < token.length; position++) {\n      const char = token[position]\n\n      if (skip) {\n        // within [...]\n        // skip over until not skipping\n        // ignore escaped chars\n        if (token[position - 1] != '\\\\') {\n          skip += +(char == '[') || -(char == ']')\n        }\n      } else if (char == '[') {\n        // start to skip\n        skip += 1\n      } else if (comment) {\n        if (token[position - 1] != '\\\\' && comment.test(token.slice(position))) {\n          comment = null\n          startIndex = position + RegExp.lastMatch.length\n        }\n      } else if (\n        char == '/' &&\n        token[position - 1] != '\\\\' &&\n        (token[position + 1] == '*' || token[position + 1] == '/')\n      ) {\n        // multiline or single line comment\n        comment = token[position + 1] == '*' ? /^\\*\\// : /^[\\r\\n]/\n      } else if (char == '(') {\n        // hover:(...) or utilitity-(...)\n        commit()\n        active.push(char)\n      } else if (char == ':') {\n        // hover: or after::\n        if (token[position + 1] != ':') {\n          commit(false, 1)\n        }\n      } else if (/[\\s,)]/.test(char)) {\n        // whitespace, comma or closing brace\n        commit(true)\n\n        let lastGroup = active.lastIndexOf('(')\n\n        if (char == ')') {\n          // Close nested block\n          const nested = active[lastGroup - 1]\n\n          if (/[~@]$/.test(nested)) {\n            const rules = current.shift() as ParsedRule[]\n\n            active.length = lastGroup\n\n            // remove variants that are already applied through active\n            createRule([...active, '#'], current, DEV && [startIndex, position])\n            const { v } = current[0].pop() as ParsedRule\n\n            for (const rule of rules) {\n              // if a rule has dark we need to splice after the first entry eg dark\n              rule.v.splice(+(rule.v[0] == 'dark') - +(v[0] == 'dark'), v.length)\n            }\n\n            createRule(\n              [\n                ...active,\n                define(\n                  // named nested\n                  nested.length > 1\n                    ? nested.slice(0, -1) + hash(JSON.stringify([nested, rules]))\n                    : nested + '(' + format(rules) + ')',\n                  Layer.a,\n                  rules,\n                  /@$/.test(nested),\n                ),\n              ],\n              current,\n              DEV && [startIndex, position],\n            )\n          }\n\n          lastGroup = active.lastIndexOf('(', lastGroup - 1)\n        }\n\n        active.length = lastGroup + 1\n      } else if (/[~@]/.test(char) && token[position + 1] == '(') {\n        // start nested block\n        // ~(...) or button~(...)\n        // @(...) or button@(...)\n        current.unshift([])\n      }\n    }\n\n    // Consume remaining stack\n    commit(true)\n\n    cache.set(token, (parsed = current[0]))\n  }\n\n  return parsed\n}\n", "export function interleave<Interpolations>(\n  strings: TemplateStringsArray,\n  interpolations: readonly Interpolations[],\n  handle: (interpolation: Interpolations) => string,\n): string {\n  return interpolations.reduce(\n    (result: string, interpolation, index) => result + handle(interpolation) + strings[index + 1],\n    strings[0],\n  )\n}\n", "import type { Class } from '../types'\nimport { interleave } from './interleave'\n\n// based on https://github.com/lukeed/clsx and https://github.com/jorgebucaran/classcat\nexport function interpolate(\n  strings: TemplateStringsArray | Class,\n  interpolations: Class[],\n): string {\n  return Array.isArray(strings) && Array.isArray((strings as unknown as TemplateStringsArray).raw)\n    ? interleave(strings as unknown as TemplateStringsArray, interpolations, (value) =>\n        toString(value).trim(),\n      )\n    : interpolations\n        .filter(Boolean)\n        .reduce(\n          (result: string, value) => result + toString(value),\n          strings ? toString(strings as Class) : '',\n        )\n}\n\nfunction toString(value: Class): string {\n  let result = ''\n  let tmp: string\n\n  if (value && typeof value == 'object') {\n    if (Array.isArray(value)) {\n      if ((tmp = interpolate(value[0], value.slice(1)))) {\n        result += ' ' + tmp\n      }\n    } else {\n      for (const key in value) {\n        if (value[key]) result += ' ' + key\n      }\n    }\n  } else if (value != null && typeof value != 'boolean') {\n    result += ' ' + value\n  }\n\n  return result\n}\n", "import type { Class, Nested } from './types'\nimport { format } from './internal/format'\nimport { parse } from './parse'\nimport { interpolate } from './internal/interpolate'\n\n/**\n * @group Class Name Generators\n */\nexport const apply = /* #__PURE__ */ alias('@')\n\n/**\n * @group Class Name Generators\n */\nexport const shortcut = /* #__PURE__ */ alias('~')\n\nfunction alias(marker: string): Nested {\n  return new Proxy(\n    function alias(strings: TemplateStringsArray | Class, ...interpolations: Class[]): string {\n      return alias$('', strings, interpolations)\n    } as Nested,\n    {\n      get(target, name) {\n        if (name in target) return target[name as string]\n\n        return function namedAlias(\n          strings: TemplateStringsArray | Class,\n          ...interpolations: Class[]\n        ): string {\n          return alias$(name as string, strings, interpolations)\n        }\n      },\n    },\n  )\n\n  function alias$(\n    name: string,\n    strings: TemplateStringsArray | Class,\n    interpolations: Class[],\n  ): string {\n    return format(parse(name + marker + '(' + interpolate(strings, interpolations) + ')'))\n  }\n}\n", "import type { CSSObject, CSSValue } from '../types'\nimport { interleave } from './interleave'\n\nexport function astish(\n  strings: CSSObject | string | TemplateStringsArray,\n  interpolations: readonly CSSValue[],\n): CSSObject[] {\n  return Array.isArray(strings)\n    ? astish$(\n        interleave(strings as TemplateStringsArray, interpolations, (interpolation) =>\n          interpolation != null && typeof interpolation != 'boolean'\n            ? (interpolation as unknown as string)\n            : '',\n        ),\n      )\n    : typeof strings == 'string'\n    ? astish$(strings)\n    : [strings as CSSObject]\n}\n\n// Based on https://github.com/cristianbote/goober/blob/master/src/core/astish.js\nconst newRule = / *(?:(?:([\\u0080-\\uFFFF\\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}))/g\n\n/**\n * Convert a css style string into a object\n */\nfunction astish$(css: string): CSSObject[] {\n  css = removeComments(css)\n\n  const tree: CSSObject[] = [{}]\n  const rules: CSSObject[] = [tree[0]]\n  const conditions: string[] = []\n  let block: RegExpExecArray | null\n\n  while ((block = newRule.exec(css))) {\n    // Remove the current entry\n    if (block[4]) {\n      tree.shift()\n      conditions.shift()\n    }\n\n    if (block[3]) {\n      // new nested\n      conditions.unshift(block[3])\n      tree.unshift({})\n      rules.push(conditions.reduce((body, condition) => ({ [condition]: body }), tree[0]))\n    } else if (!block[4]) {\n      // if we already have that property — start a new CSSObject\n      if (tree[0][block[1]]) {\n        tree.unshift({})\n        rules.push(conditions.reduce((body, condition) => ({ [condition]: body }), tree[0]))\n      }\n      tree[0][block[1]] = block[2]\n    }\n  }\n\n  // console.log(rules)\n  return rules\n}\n\n// Remove comments (multiline and single line)\nfunction removeComments(css: string): string {\n  return css.replace(/\\/\\*[^]*?\\*\\/|\\s\\s+|\\n/gm, ' ')\n}\n", "import type { CSSObject, CSSValue } from './types'\n\nimport { register } from './internal/registry'\nimport { serialize } from './internal/serialize'\nimport { hash } from './utils'\nimport { Layer } from './internal/precedence'\nimport { merge } from './internal/merge'\nimport { astish } from './internal/astish'\n\n/**\n * @group Class Name Generators\n * @param strings\n * @param interpolations\n */\nexport function css(strings: TemplateStringsArray, ...interpolations: readonly CSSValue[]): string\n\nexport function css(style: CSSObject | string): string\n\nexport function css(\n  strings: CSSObject | string | TemplateStringsArray,\n  ...interpolations: readonly CSSValue[]\n): string {\n  const ast = astish(strings, interpolations)\n\n  const className = (ast.find((o) => o.label)?.label || 'css') + hash(JSON.stringify(ast))\n\n  return register(className, (rule, context) =>\n    merge(\n      ast.flatMap((css) => serialize(css, rule, context, Layer.o)),\n      className,\n    ),\n  )\n}\n", "import type { CSSObject, CSSProperties, StringLike } from './types'\n\nimport { css } from './css'\n\nexport interface AnimationFunction {\n  (animation: string | CSSProperties, waypoints: StringLike): StringLike\n}\n\nexport type Animation = AnimationFunction & {\n  [label: string]: AnimationFunction\n}\n\n/**\n * @group Class Name Generators\n */\nexport const animation = /* #__PURE__ */ new Proxy(\n  function animation(animation: string | CSSProperties, waypoints: StringLike): StringLike {\n    return animation$('animation', animation, waypoints)\n  } as Animation,\n  {\n    get(target, name) {\n      if (name in target) return target[name as string]\n\n      return function namedAnimation(\n        animation: string | CSSProperties,\n        waypoints: StringLike,\n      ): StringLike {\n        return animation$(name as string, animation, waypoints)\n      }\n    },\n  },\n)\n\nfunction animation$(\n  label: string,\n  animation: string | CSSProperties,\n  waypoints: StringLike,\n): StringLike {\n  return {\n    toString() {\n      return css({\n        label,\n        '@layer components': {\n          ...(typeof animation == 'object' ? animation : { animation }),\n          animationName: '' + waypoints,\n        },\n      } as CSSObject)\n    },\n  } as StringLike\n}\n", "import { DEV } from 'distilt/env'\n\nimport type {\n  Context,\n  ColorValue,\n  ColorFunction,\n  BaseTheme,\n  MatchResult,\n  RuleResolver,\n  CSSProperties,\n  CSSObject,\n  RuleResult,\n  ThemeValue,\n  KebabCase,\n  MatchConverter,\n  Rule,\n  MaybeArray,\n} from './types'\n\nimport { toColorValue } from './colors'\nimport { resolveThemeFunction } from './internal/serialize'\nimport {\n  type AutocompleteProvider,\n  type AutocompleteItem,\n  withAutocomplete,\n  type AutocompleteModifier,\n} from './autocomplete'\n\nexport type ThemeMatchResult<Value> = MatchResult & {\n  /** The found theme value */\n  _: Value\n}\n\nexport type ThemeRuleResolver<Value, Theme extends BaseTheme = BaseTheme> = RuleResolver<\n  Theme,\n  ThemeMatchResult<Value>\n>\n\nexport type ThemeMatchConverter<Value, Theme extends BaseTheme = BaseTheme> = MatchConverter<\n  Theme,\n  ThemeMatchResult<Value>\n>\n\n// indirection wrapper to remove autocomplete functions from production bundles\nfunction withAutocomplete$<Theme extends BaseTheme = BaseTheme>(\n  resolver: RuleResolver<Theme>,\n  autocomplete: AutocompleteProvider<Theme> | false,\n): RuleResolver<Theme> {\n  if (DEV) {\n    return withAutocomplete(resolver, autocomplete)\n  }\n\n  return resolver\n}\n\n/**\n * @group Configuration\n * @param pattern\n */\nexport function match<Theme extends BaseTheme = BaseTheme>(\n  pattern: MaybeArray<string | RegExp>,\n): Rule<Theme>\n\n/**\n * @group Configuration\n * @param pattern\n * @param resolver\n */\nexport function match<Theme extends BaseTheme = BaseTheme>(\n  pattern: MaybeArray<string | RegExp>,\n  resolver: RuleResolver<Theme>,\n): Rule<Theme>\n\n/**\n * @group Configuration\n * @param pattern\n * @param resolve\n */\nexport function match<Theme extends BaseTheme = BaseTheme>(\n  pattern: MaybeArray<string | RegExp>,\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  resolve: (string & {}) | CSSObject,\n): Rule<Theme>\n\n/**\n * @group Configuration\n * @param pattern\n * @param resolve\n * @param convert\n */\nexport function match<Theme extends BaseTheme = BaseTheme>(\n  pattern: MaybeArray<string | RegExp>,\n  resolve: keyof CSSProperties,\n  convert?: MatchConverter<Theme>,\n): Rule<Theme>\n\nexport function match<Theme extends BaseTheme = BaseTheme>(\n  pattern: MaybeArray<string | RegExp>,\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  resolve?: RuleResolver<Theme> | (string & {}) | CSSObject | keyof CSSProperties,\n  convert?: MatchConverter<Theme>,\n): Rule<Theme> {\n  return [pattern, fromMatch(resolve as keyof CSSProperties, convert)]\n}\n\n/**\n * @group Configuration\n * @internal\n * @deprecated Use {@link match} instead.\n */\nexport function fromMatch<Theme extends BaseTheme = BaseTheme>(): RuleResolver<Theme>\n\n/**\n * @group Configuration\n * @internal\n * @deprecated Use {@link match} instead.\n */\nexport function fromMatch<Theme extends BaseTheme = BaseTheme>(\n  resolver: RuleResolver<Theme>,\n): RuleResolver<Theme>\n\n/**\n * @group Configuration\n * @internal\n * @deprecated Use {@link match} instead.\n */\nexport function fromMatch<Theme extends BaseTheme = BaseTheme>(\n  resolve: keyof CSSProperties,\n  convert?: MatchConverter<Theme>,\n): RuleResolver<Theme>\n\n/**\n * @group Configuration\n * @internal\n * @deprecated Use {@link match} instead.\n */\nexport function fromMatch<Theme extends BaseTheme = BaseTheme>(\n  resolve: string | CSSObject,\n): RuleResolver<Theme>\n\nexport function fromMatch<Theme extends BaseTheme = BaseTheme>(\n  resolve?: RuleResolver<Theme> | keyof CSSProperties | string | CSSObject,\n  convert?: MatchConverter<Theme>,\n): RuleResolver<Theme> {\n  return typeof resolve == 'function'\n    ? resolve\n    : typeof resolve == 'string' && /^[\\w-]+$/.test(resolve) // a CSS property alias\n    ? (match, context) =>\n        ({\n          [resolve]: convert ? convert(match, context) : maybeNegate(match, 1),\n        } as CSSObject)\n    : (match) =>\n        // CSSObject, shortcut or apply\n        resolve ||\n        ({\n          [match[1]]: maybeNegate(match, 2),\n        } as CSSObject)\n}\n\nfunction maybeNegate<T>(\n  match: MatchResult,\n  offset: number,\n  value: T | string = match.slice(offset).find(Boolean) || match.$$ || match.input,\n): T | string {\n  return match.input[0] == '-' ? `calc(${value} * -1)` : value\n}\n\n/**\n * @group Configuration\n * @param pattern\n * @param section\n * @param resolve\n * @param convert\n * @returns\n */\nexport function matchTheme<\n  Theme extends BaseTheme = BaseTheme,\n  Section extends keyof Theme & string = keyof Theme & string,\n>(\n  pattern: MaybeArray<string | RegExp>,\n\n  /** Theme section to use (default: `$1` — The first matched group) */\n  section?: '' | Section | KebabCase<Section>,\n\n  /** The css property (default: value of {@link section}) */\n  resolve?: keyof CSSProperties | ThemeRuleResolver<ThemeValue<Theme[Section]>, Theme>,\n\n  convert?: ThemeMatchConverter<ThemeValue<Theme[Section]>, Theme>,\n): Rule<Theme> {\n  return [pattern, fromTheme(section, resolve, convert)]\n}\n\n/**\n * @group Configuration\n * @internal\n * @deprecated Use {@link matchTheme} instead.\n * @param section\n * @param resolve\n * @param convert\n * @returns\n */\nexport function fromTheme<\n  Theme extends BaseTheme = BaseTheme,\n  Section extends keyof Theme & string = keyof Theme & string,\n>(\n  /** Theme section to use (default: `$1` — The first matched group) */\n  section?: '' | Section | KebabCase<Section>,\n\n  /** The css property (default: value of {@link section}) */\n  resolve?: keyof CSSProperties | ThemeRuleResolver<ThemeValue<Theme[Section]>, Theme>,\n\n  convert?: ThemeMatchConverter<ThemeValue<Theme[Section]>, Theme>,\n): RuleResolver<Theme> {\n  const factory: (\n    match: ThemeMatchResult<ThemeValue<Theme[Section]>>,\n    context: Context<Theme>,\n    section: Section,\n  ) => RuleResult =\n    typeof resolve == 'string'\n      ? (match, context) =>\n          ({ [resolve]: convert ? convert(match, context) : match._ } as CSSObject)\n      : resolve || (({ 1: $1, _ }, context, section) => ({ [$1 || section]: _ } as CSSObject))\n\n  return withAutocomplete$(\n    (match, context) => {\n      const themeSection = camelize(section || match[1]) as Section\n\n      const value =\n        context.theme(themeSection, match.$$) ??\n        (arbitrary(match.$$, themeSection, context) as ThemeValue<Theme[Section]>)\n\n      if (value != null) {\n        ;(match as ThemeMatchResult<ThemeValue<Theme[Section]>>)._ = maybeNegate(\n          match,\n          0,\n          value,\n        ) as ThemeValue<Theme[Section]>\n\n        return factory(match as ThemeMatchResult<ThemeValue<Theme[Section]>>, context, themeSection)\n      }\n    },\n    DEV &&\n      ((match, context) => {\n        const themeSection = camelize(section || match[1]) as Section\n\n        const isKeyLookup = match.input.endsWith('-')\n\n        if (isKeyLookup) {\n          return Object.entries(context.theme(themeSection) || {})\n            .filter(\n              ([key, value]) =>\n                key &&\n                key != 'DEFAULT' &&\n                (!/color|fill|stroke/i.test(themeSection) ||\n                  ['string', 'function'].includes(typeof value)),\n            )\n            .map(\n              ([key, value]): AutocompleteItem => ({\n                suffix: key.replace(/-DEFAULT/g, ''),\n                theme: { section: themeSection, key },\n                color:\n                  /color|fill|stroke/i.test(themeSection) &&\n                  toColorValue(value as ColorValue, { opacityValue: '1' }),\n              }),\n            )\n            .concat([{ suffix: '[' }])\n        }\n\n        const value = context.theme(themeSection, 'DEFAULT')\n\n        if (value) {\n          return [\n            {\n              suffix: '',\n              theme: { section: themeSection, key: 'DEFAULT' },\n              color:\n                /color|fill|stroke/i.test(themeSection) &&\n                toColorValue(value as ColorValue, { opacityValue: '1' }),\n            },\n          ]\n        }\n\n        return []\n      }),\n  )\n}\n\nexport type FilterByThemeValue<Theme, Value> = {\n  [key in keyof Theme & string]: ThemeValue<Theme[key]> extends Value ? Theme[key] : never\n}\n\nexport interface ColorFromThemeValue {\n  value: string\n  color: ColorFunction\n  opacityVariable: string | undefined\n  opacityValue: string | undefined\n}\n\nexport interface ColorFromThemeOptions<\n  Theme extends BaseTheme = BaseTheme,\n  Section extends keyof FilterByThemeValue<Theme, ColorValue> = keyof FilterByThemeValue<\n    Theme,\n    ColorValue\n  >,\n  OpacitySection extends keyof FilterByThemeValue<Theme, string> = keyof FilterByThemeValue<\n    Theme,\n    string\n  >,\n> {\n  /** Theme section to use (default: `$0.replace('-', 'Color')` — The matched string with `Color` appended) */\n  section?: Section | KebabCase<Section>\n  /** The css property (default: value of {@link section}) */\n  property?: keyof CSSProperties\n  /** `--tw-${$0}opacity` -> '--tw-text-opacity' */\n  opacityVariable?: string | false\n  /** `section.replace('Color', 'Opacity')` -> 'textOpacity' */\n  opacitySection?: OpacitySection\n  selector?: string\n}\n\n/**\n * @group Configuration\n * @param pattern\n * @param options\n * @param resolve\n * @returns\n */\nexport function matchColor<\n  Theme extends BaseTheme = BaseTheme,\n  Section extends keyof FilterByThemeValue<Theme, ColorValue> = keyof FilterByThemeValue<\n    Theme,\n    ColorValue\n  >,\n  OpacitySection extends keyof FilterByThemeValue<Theme, string> = keyof FilterByThemeValue<\n    Theme,\n    string\n  >,\n>(\n  pattern: MaybeArray<string | RegExp>,\n  options: ColorFromThemeOptions<Theme, Section, OpacitySection> = {},\n  resolve?: ThemeRuleResolver<ColorFromThemeValue, Theme>,\n): Rule<Theme> {\n  return [pattern, colorFromTheme(options, resolve)]\n}\n\n/**\n * @group Configuration\n * @internal\n * @deprecated Use {@link matchColor} instead.\n * @param options\n * @param resolve\n * @returns\n */\nexport function colorFromTheme<\n  Theme extends BaseTheme = BaseTheme,\n  Section extends keyof FilterByThemeValue<Theme, ColorValue> = keyof FilterByThemeValue<\n    Theme,\n    ColorValue\n  >,\n  OpacitySection extends keyof FilterByThemeValue<Theme, string> = keyof FilterByThemeValue<\n    Theme,\n    string\n  >,\n>(\n  options: ColorFromThemeOptions<Theme, Section, OpacitySection> = {},\n  resolve?: ThemeRuleResolver<ColorFromThemeValue, Theme>,\n): RuleResolver<Theme> {\n  return withAutocomplete$(\n    (match, context) => {\n      // text- -> textColor\n      // ring-offset(?:-|$) -> ringOffsetColor\n      const { section = (camelize(match[0]).replace('-', '') + 'Color') as Section } = options\n\n      // extract color and opacity\n      // rose-500                  -> ['rose-500']\n      // [hsl(0_100%_/_50%)]       -> ['[hsl(0_100%_/_50%)]']\n      // indigo-500/100            -> ['indigo-500', '100']\n      // [hsl(0_100%_/_50%)]/[.25] -> ['[hsl(0_100%_/_50%)]', '[.25]']\n      const [colorMatch, opacityMatch] = parseValue(match.$$)\n\n      if (!colorMatch) return\n\n      const colorValue =\n        (context.theme(section, colorMatch) as ColorValue) ||\n        arbitrary(colorMatch, section, context)\n\n      if (!colorValue || typeof colorValue == 'object') return\n\n      const {\n        // text- -> --tw-text-opacity\n        // ring-offset(?:-|$) -> --tw-ring-offset-opacity\n        // TODO move this default into preset-tailwind?\n        opacityVariable = `--tw-${match[0].replace(/-$/, '')}-opacity`,\n        opacitySection = section.replace('Color', 'Opacity') as OpacitySection,\n        property = section,\n        selector,\n      } = options\n\n      const opacityValue =\n        (context.theme(opacitySection, opacityMatch || 'DEFAULT') as string | undefined) ||\n        (opacityMatch && arbitrary(opacityMatch, opacitySection, context))\n\n      // if (typeof color != 'string') {\n      //   console.warn(`Invalid color ${colorMatch} (from ${match.input}):`, color)\n      //   return\n      // }\n\n      const create =\n        resolve ||\n        (({ _ }) => {\n          const properties = toCSS(property, _)\n\n          return selector ? { [selector]: properties } : properties\n        })\n\n      ;(match as ThemeMatchResult<ColorFromThemeValue>)._ = {\n        value: toColorValue(colorValue, {\n          opacityVariable: opacityVariable || undefined,\n          opacityValue: opacityValue || undefined,\n        }),\n        color: (options) => toColorValue(colorValue, options),\n        opacityVariable: opacityVariable || undefined,\n        opacityValue: opacityValue || undefined,\n      }\n\n      let properties = create(match as ThemeMatchResult<ColorFromThemeValue>, context)\n\n      // auto support dark mode colors\n      if (!match.dark) {\n        const darkColorValue = context.d(section, colorMatch, colorValue)\n\n        if (darkColorValue && darkColorValue !== colorValue) {\n          ;(match as ThemeMatchResult<ColorFromThemeValue>)._ = {\n            value: toColorValue(darkColorValue, {\n              opacityVariable: opacityVariable || undefined,\n              opacityValue: opacityValue || '1',\n            }),\n            color: (options) => toColorValue(darkColorValue, options),\n            opacityVariable: opacityVariable || undefined,\n            opacityValue: opacityValue || undefined,\n          }\n\n          properties = {\n            '&': properties,\n            [context.v('dark') as string]: create(\n              match as ThemeMatchResult<ColorFromThemeValue>,\n              context,\n            ),\n          } as CSSObject\n        }\n      }\n\n      return properties\n    },\n    DEV &&\n      ((match, context) => {\n        const {\n          section = (camelize(match[0]).replace('-', '') + 'Color') as Section,\n          opacitySection = section.replace('Color', 'Opacity') as OpacitySection,\n        } = options\n\n        const isKeyLookup = match.input.endsWith('-')\n\n        const opacities = Object.entries<string>(context.theme(opacitySection) || {}).filter(\n          ([key, value]) => key != 'DEFAULT' && /^[\\w-]+$/.test(key) && typeof value == 'string',\n        )\n\n        if (isKeyLookup) {\n          // ['gray-50', ['/0', '/10', ...]],\n          // ['gray-100', ['/0', '/10', ...]],\n\n          return Object.entries(context.theme(section) || {})\n            .filter(\n              ([key, value]) =>\n                key && key != 'DEFAULT' && ['string', 'function'].includes(typeof value),\n            )\n            .map(\n              ([key, value]): AutocompleteItem => ({\n                suffix: key.replace(/-DEFAULT/g, ''),\n                theme: { section, key },\n                color: toColorValue(value as ColorValue, {\n                  opacityValue: (context.theme(opacitySection, 'DEFAULT') as string) || '1',\n                }),\n                modifiers:\n                  (typeof value == 'function' ||\n                    (typeof value == 'string' &&\n                      (value.includes('<alpha-value>') ||\n                        (value[0] == '#' && (value.length == 4 || value.length == 7))))) &&\n                  opacities\n                    .map(\n                      ([key, opacityValue]): AutocompleteModifier => ({\n                        modifier: key,\n                        theme: { section: opacitySection, key },\n                        color: toColorValue(value as ColorValue, { opacityValue }),\n                      }),\n                    )\n                    .concat([\n                      {\n                        modifier: '[',\n                        color: toColorValue(value as ColorValue, { opacityValue: '1' }),\n                      },\n                    ]),\n              }),\n            )\n            .concat([{ suffix: '[' }])\n        }\n\n        const value = context.theme(section, 'DEFAULT')\n\n        if (value) {\n          return [\n            {\n              suffix: '',\n              theme: { section, key: 'DEFAULT' },\n              color: toColorValue(value as ColorValue, {\n                opacityValue: (context.theme(opacitySection, 'DEFAULT') as string) || '1',\n              }),\n              modifiers:\n                (typeof value == 'function' ||\n                  (typeof value == 'string' &&\n                    (value.includes('<alpha-value>') ||\n                      (value[0] == '#' && (value.length == 4 || value.length == 7))))) &&\n                opacities\n                  .map(\n                    ([key, opacityValue]): AutocompleteModifier => ({\n                      modifier: key,\n                      theme: { section: opacitySection, key },\n                      color: toColorValue(value as ColorValue, { opacityValue }),\n                    }),\n                  )\n                  .concat([\n                    {\n                      modifier: '[',\n                      color: toColorValue(value as ColorValue, { opacityValue: '1' }),\n                    },\n                  ]),\n            },\n          ]\n        }\n\n        return []\n      }),\n  )\n}\n\n/**\n * @internal\n * @param input\n */\nexport function parseValue(\n  input: string,\n):\n  | [value: string, modifier: string | undefined]\n  | [value: undefined, modifier: string | undefined] {\n  // extract color and opacity\n  // rose-500                  -> ['rose-500']\n  // [hsl(0_100%_/_50%)]       -> ['[hsl(0_100%_/_50%)]']\n  // indigo-500/100            -> ['indigo-500', '100']\n  // [hsl(0_100%_/_50%)]/[.25] -> ['[hsl(0_100%_/_50%)]', '[.25]']\n  return (input.match(/^(\\[[^\\]]+]|[^/]+?)(?:\\/(.+))?$/) || []).slice(1) as [\n    value: string,\n    modifier: string | undefined,\n  ]\n}\n\n/**\n * @internal\n * @param property\n * @param value\n * @returns\n */\nexport function toCSS(property: string, value: string | ColorFromThemeValue): CSSObject {\n  const properties: CSSObject = {}\n\n  if (typeof value === 'string') {\n    properties[property] = value\n  } else {\n    if (value.opacityVariable && value.value.includes(value.opacityVariable)) {\n      properties[value.opacityVariable] = value.opacityValue || '1'\n    }\n\n    properties[property] = value.value\n  }\n\n  return properties\n}\n\n/**\n * @internal\n * @param value\n * @param section\n * @param context\n * @returns\n */\nexport function arbitrary<Theme extends BaseTheme = BaseTheme>(\n  value: string,\n  section: string | undefined,\n  context: Context<Theme>,\n): string | undefined {\n  if (value[0] == '[' && value.slice(-1) == ']') {\n    value = normalize(resolveThemeFunction(value.slice(1, -1), context.theme))\n\n    if (!section) return value\n\n    if (\n      // Respect type hints from the user on ambiguous arbitrary values - https://tailwindcss.com/docs/adding-custom-styles#resolving-ambiguities\n      !(\n        // If this is a color section and the value is a hex color, color function or color name\n        (\n          (/color|fill|stroke/i.test(section) &&\n            !(\n              /^color:/.test(value) || /^(#|((hsl|rgb)a?|hwb|lab|lch|color)\\(|[a-z]+$)/.test(value)\n            )) ||\n          // url(, [a-z]-gradient(, image(, cross-fade(, image-set(\n          (/image/i.test(section) && !(/^image:/.test(value) || /^[a-z-]+\\(/.test(value))) ||\n          // font-*\n          // - fontWeight (type: ['lookup', 'number', 'any'])\n          // - fontFamily (type: ['lookup', 'generic-name', 'family-name'])\n          (/weight/i.test(section) && !(/^(number|any):/.test(value) || /^\\d+$/.test(value))) ||\n          // bg-*\n          // - backgroundPosition (type: ['lookup', ['position', { preferOnConflict: true }]])\n          // - backgroundSize (type: ['lookup', 'length', 'percentage', 'size'])\n          (/position/i.test(section) && /^(length|size):/.test(value))\n        )\n      )\n    ) {\n      // remove arbitrary type prefix — we do not need it but user may use it\n      // https://github.com/tailwindlabs/tailwindcss/blob/master/src/util/dataTypes.js\n      // url, number, percentage, length, line-width, shadow, color, image, gradient, position, family-name, lookup, any, generic-name, absolute-size, relative-size\n      return value.replace(/^[a-z-]+:/, '')\n    }\n  }\n}\n\nfunction camelize(value: string): string {\n  return value.replace(/-./g, (x) => x[1].toUpperCase())\n}\n\n/**\n * @internal\n * @param value\n * @returns\n */\nexport function normalize(value: string): string {\n  // Keep raw strings if it starts with `url(`\n  if (value.includes('url(')) {\n    return value.replace(\n      /(.*?)(url\\(.*?\\))(.*?)/g,\n      (_, before = '', url, after = '') => normalize(before) + url + normalize(after),\n    )\n  }\n\n  return (\n    value\n      // Convert `_` to ` `, except for escaped underscores `\\_`\n      .replace(\n        /(^|[^\\\\])_+/g,\n        (fullMatch, characterBefore: string) =>\n          characterBefore + ' '.repeat(fullMatch.length - characterBefore.length),\n      )\n      .replace(/\\\\_/g, '_')\n\n      // Add spaces around operators inside math functions like calc() that do not follow an operator\n      // or '('.\n      .replace(/(calc|min|max|clamp)\\(.+\\)/g, (match) =>\n        match.replace(\n          /(-?\\d*\\.?\\d(?!\\b-.+[,)](?![^+\\-/*])\\D)(?:%|[a-z]+)?|\\))([+\\-/*])/g,\n          '$1 $2 ',\n        ),\n      )\n  )\n}\n", "import type {\n  BaseTheme,\n  CSSProperties,\n  MatchResult,\n  Rule,\n  RuleResolver,\n  ThemeFunction,\n  VariantResolver,\n} from './types'\nimport { DEV } from 'distilt/env'\nimport { fromMatch } from './rules'\nimport { asArray } from './utils'\n\nexport type AutocompleteItem = {\n  prefix?: string\n  suffix: string\n  theme?: { section: string; key: string }\n  modifiers?: AutocompleteModifier[] | false | null | undefined\n  color?: string | false | null | undefined\n  label?: string\n}\n\nexport type AutocompleteModifier = {\n  modifier: string\n  theme?: { section: string; key: string }\n  color?: string | false | null | undefined\n  label?: string\n}\n\nexport interface AutocompleteContext<Theme extends BaseTheme = BaseTheme> {\n  /** Allows to resolve theme values. */\n  readonly theme: ThemeFunction<Theme>\n  readonly variants: Record<string, string>\n}\n\nexport type AutocompleteProvider<Theme extends BaseTheme = BaseTheme> = (\n  match: MatchResult,\n  context: AutocompleteContext<Theme>,\n) => (string | AutocompleteItem)[]\n\nconst kAutocomplete = /* #__PURE__ */ Symbol('@twind/autocomplete')\n\n/**\n * @experimental\n * @group Configuration\n * @param resolver\n * @param autocomplete\n */\nexport function withAutocomplete<Theme extends BaseTheme = BaseTheme>(\n  resolver: RuleResolver<Theme>,\n  autocomplete: AutocompleteProvider<Theme> | false | null | undefined,\n): RuleResolver<Theme>\n\nexport function withAutocomplete<Theme extends BaseTheme = BaseTheme>(\n  resolver: VariantResolver<Theme>,\n  autocomplete: AutocompleteProvider<Theme> | false | null | undefined,\n): VariantResolver<Theme>\n\nexport function withAutocomplete<Theme extends BaseTheme = BaseTheme>(\n  rule: Rule<Theme>,\n  autocomplete: AutocompleteProvider<Theme> | false | null | undefined,\n): Rule<Theme>\n\nexport function withAutocomplete<Theme extends BaseTheme = BaseTheme>(\n  rule: Rule<Theme> | RuleResolver<Theme> | VariantResolver<Theme>,\n  autocomplete: AutocompleteProvider<Theme> | false | null | undefined,\n): Rule<Theme> | RuleResolver<Theme> | VariantResolver<Theme> {\n  if (DEV && autocomplete) {\n    if (typeof rule == 'function') {\n      return Object.defineProperty(rule, kAutocomplete, {\n        value: autocomplete,\n        configurable: true,\n      })\n    }\n\n    const [pattern, resolve, convert] = asArray(rule) as Exclude<Rule<Theme>, string | RegExp>\n\n    // [\n    //   patterns: MaybeArray<string | RegExp>,\n    //   resolve?: keyof CSSProperties | string | CSSObject | RuleResolver<Theme>,\n    //   convert?: MatchConverter<Theme>,\n    // ]\n\n    return [\n      pattern,\n      Object.defineProperty(fromMatch(resolve as keyof CSSProperties, convert), kAutocomplete, {\n        value: autocomplete,\n        configurable: true,\n      }),\n    ]\n  }\n\n  return rule\n}\n\n/**\n * @internal\n * @param resolver\n * @returns\n */\nexport function getAutocompleteProvider<Theme extends BaseTheme = BaseTheme>(\n  resolver: RuleResolver<Theme> | VariantResolver<Theme>,\n): AutocompleteProvider<Theme> | undefined {\n  return (resolver as { [kAutocomplete]?: AutocompleteProvider<Theme> })[kAutocomplete]\n}\n", "import type { Class } from './types'\nimport { parse } from './parse'\nimport { format } from './internal/format'\nimport { interpolate } from './internal/interpolate'\n\n/**\n * Constructs `class` strings conditionally.\n *\n * Twinds version of popular libraries like [classnames](https://github.com/JedWatson/classnames) or [clsx](https://github.com/lukeed/clsx).\n * The key advantage of `cx` is that it supports twinds enhanced class name syntax like grouping and aliases.\n *\n * @group Class Name Generators\n * @param strings\n * @param interpolations\n * @returns\n */\nexport function cx(strings: TemplateStringsArray, ...interpolations: Class[]): string\n\n/**\n * Constructs `class` strings conditionally.\n *\n * Twinds version of popular libraries like [classnames](https://github.com/JedWatson/classnames) or [clsx](https://github.com/lukeed/clsx).\n * The key advantage of `cx` is that it supports twinds enhanced class name syntax like grouping and aliases.\n *\n * @group Class Name Generators\n * @param input\n */\nexport function cx(...input: Class[]): string\n\nexport function cx(strings: TemplateStringsArray | Class, ...interpolations: Class[]): string {\n  return format(parse(interpolate(strings, interpolations)), ' ')\n}\n", "import type {\n  BaseTheme,\n  Preset,\n  TwindConfig,\n  TwindUserConfig,\n  ExtractThemes,\n  TwindPresetConfig,\n} from './types'\n\nimport { asArray } from './utils'\n\n/**\n * @group Configuration\n * @param param0\n * @returns\n */\nexport function defineConfig<Theme = BaseTheme, Presets extends Preset<any>[] = Preset[]>({\n  presets = [] as unknown as Presets,\n  ...userConfig\n}: TwindUserConfig<Theme, Presets>): TwindConfig<BaseTheme & ExtractThemes<Theme, Presets>> {\n  // most user config values go first to have precendence over preset config\n  // only `preflight` and `theme` are applied as last preset to override all presets\n  let config: TwindConfig<BaseTheme & ExtractThemes<Theme, Presets>> = {\n    darkMode: undefined,\n    darkColor: undefined,\n    preflight: userConfig.preflight !== false && [],\n    theme: {},\n    variants: asArray(userConfig.variants),\n    rules: asArray(userConfig.rules),\n    ignorelist: asArray(userConfig.ignorelist),\n    hash: undefined,\n    stringify: (property, value) => property + ':' + value,\n    finalize: [],\n  }\n\n  for (const preset of asArray([\n    ...presets,\n    {\n      darkMode: userConfig.darkMode,\n      darkColor: userConfig.darkColor,\n      preflight: userConfig.preflight !== false && asArray(userConfig.preflight),\n      theme: userConfig.theme as TwindConfig<BaseTheme & ExtractThemes<Theme, Presets>>['theme'],\n      hash: userConfig.hash,\n      stringify: userConfig.stringify,\n      finalize: userConfig.finalize,\n    } as TwindPresetConfig<Theme>,\n  ])) {\n    const {\n      preflight,\n      darkMode = config.darkMode,\n      darkColor = config.darkColor,\n      theme,\n      variants,\n      rules,\n      ignorelist,\n      hash = config.hash,\n      stringify = config.stringify,\n      finalize,\n    } = typeof preset == 'function' ? preset(config) : (preset as TwindPresetConfig<Theme>)\n\n    config = {\n      // values defined by user or previous presets take precedence\n      preflight: config.preflight !== false &&\n        preflight !== false && [...config.preflight, ...asArray(preflight)],\n\n      darkMode,\n      darkColor,\n\n      theme: {\n        ...config.theme,\n        ...theme,\n        extend: {\n          ...config.theme.extend,\n          ...theme?.extend,\n        },\n      },\n\n      variants: [...config.variants, ...asArray(variants)],\n      rules: [...config.rules, ...asArray(rules)],\n      ignorelist: [...config.ignorelist, ...asArray(ignorelist)],\n\n      hash,\n      stringify,\n\n      finalize: [...config.finalize, ...asArray(finalize)],\n    } as TwindConfig<BaseTheme & ExtractThemes<Theme, Presets>>\n  }\n\n  return config\n}\n", "import { DEV } from 'distilt/env'\n\ndeclare global {\n  interface WindowEventMap {\n    warning: CustomEvent<Warning>\n  }\n}\n\nexport type Warning = {\n  [Code in keyof WarningEventMap]: { message: string; code: Code; detail: WarningEventMap[Code] }\n}[keyof WarningEventMap]\n\nexport interface WarningEventMap {\n  TWIND_INVALID_CLASS: string\n  TWIND_INVALID_CSS: string\n}\n\nexport function warn<Code extends keyof WarningEventMap>(\n  message: string,\n  code: Code,\n  detail: WarningEventMap[Code],\n): void {\n  if (DEV) {\n    if (typeof dispatchEvent == 'function' && typeof CustomEvent === 'function') {\n      // Browser\n      const event = new CustomEvent('warning', {\n        detail: { message, code, detail },\n        cancelable: true,\n      })\n\n      dispatchEvent(event)\n\n      if (!event.defaultPrevented) {\n        console.warn(`[${code}] ${message}`, { detail })\n      }\n    } else if (typeof process == 'object' && typeof process.emitWarning == 'function') {\n      // Node.JS\n      process.emitWarning(message, { code, detail } as unknown as string)\n    } else {\n      // Fallback\n      console.warn(`[${code}] ${message}`, { detail })\n    }\n  }\n}\n", "import type {\n  BaseTheme,\n  Context,\n  RuleResult,\n  TwindConfig,\n  CSSProperties,\n  MatchResult,\n  MaybeArray,\n  RuleResolver,\n  MatchConverter,\n  Rule,\n  CSSObject,\n  Variant,\n  VariantResult,\n  VariantResolver,\n  Falsey,\n} from '../types'\n\nimport { DEV } from 'distilt/env'\n\nimport { makeThemeFunction } from './theme'\nimport { asArray, escape, hash as defaultHash, identity, noop } from '../utils'\nimport { fromMatch } from '../rules'\nimport { warn } from './warn'\n\ntype ResolveFunction<Theme extends BaseTheme = BaseTheme> = (\n  className: string,\n  context: Context<Theme>,\n  isDark?: boolean,\n) => RuleResult\n\ntype VariantFunction<Theme extends BaseTheme = BaseTheme> = (\n  variant: string,\n  context: Context<Theme>,\n) => VariantResult\n\nexport function createContext<Theme extends BaseTheme = BaseTheme>({\n  theme,\n  darkMode,\n  darkColor = noop,\n  variants,\n  rules,\n  hash,\n  stringify,\n  ignorelist,\n  finalize,\n}: TwindConfig<Theme>): Context<Theme> {\n  // Used to cache resolved rule values\n  const variantCache = new Map<string, MaybeArray<string>>()\n\n  // lazy created resolve functions\n  const variantResolvers = new Map<Variant<Theme>, VariantFunction<Theme>>()\n\n  // Used to cache resolved rule values\n  const ruleCache = new Map<string, RuleResult>()\n\n  // lazy created resolve functions\n  const ruleResolvers = new Map<Rule<Theme>, ResolveFunction<Theme>>()\n\n  const ignored = createRegExpExecutor(ignorelist, (value, condition) => condition.test(value))\n\n  const reportedUnknownClasses = /* #__PURE__ */ new Set<string>()\n\n  // add dark as last variant to allow user to override it\n  // we can modify variants as it has been passed through defineConfig which already made a copy\n  variants.push([\n    'dark',\n    Array.isArray(darkMode) || darkMode == 'class'\n      ? `${asArray(darkMode)[1] || '.dark'} &`\n      : typeof darkMode == 'string' && darkMode != 'media'\n      ? darkMode // a custom selector\n      : '@media (prefers-color-scheme:dark)',\n  ])\n\n  const h =\n    typeof hash == 'function'\n      ? (value: string) => hash(value, defaultHash)\n      : hash\n      ? defaultHash\n      : identity\n\n  if (h !== identity) {\n    finalize.push((rule) => ({\n      ...rule,\n      n: rule.n && h(rule.n),\n      d: rule.d?.replace(\n        /--(tw(?:-[\\w-]+)?)\\b/g,\n        (_: string, property: string) => '--' + h(property).replace('#', ''),\n      ),\n    }))\n  }\n\n  const ctx: Context<Theme> = {\n    theme: makeThemeFunction(theme),\n\n    e: escape,\n\n    h,\n\n    s(property, value) {\n      return stringify(property, value, ctx)\n    },\n\n    d(section, key, color) {\n      return darkColor(section, key, ctx, color)\n    },\n\n    v(value) {\n      if (!variantCache.has(value)) {\n        variantCache.set(\n          value,\n          find(value, variants, variantResolvers, getVariantResolver, ctx) || '&:' + value,\n        )\n      }\n\n      return variantCache.get(value) as string\n    },\n\n    r(className, isDark) {\n      const key = JSON.stringify([className, isDark])\n\n      if (!ruleCache.has(key)) {\n        ruleCache.set(\n          key,\n          !ignored(className, ctx) &&\n            find(className, rules, ruleResolvers, getRuleResolver, ctx, isDark),\n        )\n\n        if (DEV) {\n          const rule = ruleCache.get(key)\n          if (rule == null && !reportedUnknownClasses.has(className)) {\n            reportedUnknownClasses.add(className)\n\n            warn(\n              `Unknown class ${JSON.stringify(className)} found.`,\n              'TWIND_INVALID_CLASS',\n              className,\n            )\n          }\n        }\n      }\n\n      return ruleCache.get(key)\n    },\n\n    f(rule) {\n      return finalize.reduce((rule, p) => p(rule, ctx), rule)\n    },\n  }\n\n  return ctx\n}\n\nfunction find<Value, Config, Result, Theme extends BaseTheme = BaseTheme>(\n  value: Value,\n  list: Config[],\n  cache: Map<Config, (value: Value, context: Context<Theme>, isDark?: boolean) => Result>,\n  getResolver: (\n    item: Config,\n  ) => (value: Value, context: Context<Theme>, isDark?: boolean) => Result,\n  context: Context<Theme>,\n  isDark?: boolean,\n) {\n  for (const item of list) {\n    let resolver = cache.get(item)\n\n    if (!resolver) {\n      cache.set(item, (resolver = getResolver(item)))\n    }\n\n    const resolved = resolver(value, context, isDark)\n\n    if (resolved) return resolved\n  }\n}\n\nfunction getVariantResolver<Theme extends BaseTheme = BaseTheme>(\n  variant: Variant<Theme>,\n): VariantFunction<Theme> {\n  return createVariantFunction(variant[0], variant[1])\n}\n\nfunction getRuleResolver<Theme extends BaseTheme = BaseTheme>(\n  rule: Rule<Theme>,\n): ResolveFunction<Theme> {\n  if (Array.isArray(rule)) {\n    return createResolveFunction(rule[0], rule[1], rule[2])\n  }\n\n  return createResolveFunction(rule)\n}\n\nfunction createVariantFunction<Theme extends BaseTheme = BaseTheme>(\n  patterns: MaybeArray<string | RegExp>,\n  resolve: string | VariantResolver<Theme>,\n): VariantFunction<Theme> {\n  return createResolve(patterns, typeof resolve == 'function' ? resolve : () => resolve)\n}\n\nfunction createResolveFunction<Theme extends BaseTheme = BaseTheme>(\n  patterns: MaybeArray<string | RegExp>,\n  resolve?: keyof CSSProperties | string | CSSObject | RuleResolver<Theme>,\n  convert?: MatchConverter<Theme>,\n): ResolveFunction<Theme> {\n  return createResolve(patterns, fromMatch(resolve as keyof CSSProperties, convert))\n}\n\nfunction createResolve<Result, Theme extends BaseTheme = BaseTheme>(\n  patterns: MaybeArray<string | RegExp>,\n  resolve: (match: MatchResult, context: Context<Theme>) => Result,\n): (value: string, context: Context<Theme>, isDark?: boolean) => Result | undefined {\n  return createRegExpExecutor(patterns, (value, condition, context, isDark?: boolean) => {\n    const match = condition.exec(value) as MatchResult | Falsey\n\n    if (match) {\n      // MATCH.$_ = value\n      match.$$ = value.slice(match[0].length)\n      match.dark = isDark\n\n      return resolve(match, context)\n    }\n  })\n}\n\nfunction createRegExpExecutor<Result, Theme extends BaseTheme = any>(\n  patterns: MaybeArray<string | RegExp>,\n  run: (value: string, condition: RegExp, context: Context<Theme>, isDark?: boolean) => Result,\n): (value: string, context: Context<Theme>, isDark?: boolean) => Result | undefined {\n  const conditions = asArray(patterns).map(toCondition)\n\n  return (value, context, isDark) => {\n    for (const condition of conditions) {\n      const result = run(value, condition, context, isDark)\n\n      if (result) return result\n    }\n  }\n}\n\nexport function toCondition(value: string | RegExp): RegExp {\n  // \"visible\" -> /^visible$/\n  // \"(float)-(left|right|none)\" -> /^(float)-(left|right|none)$/\n  // \"auto-rows-\" -> /^auto-rows-/\n  // \"gap(-|$)\" -> /^gap(-|$)/\n  return typeof value == 'string'\n    ? new RegExp('^' + value + (value.includes('$') || value.slice(-1) == '-' ? '' : '$'))\n    : value\n}\n", "import type {\n  BaseTheme,\n  ExtractThemes,\n  Preset,\n  Twind,\n  Sheet,\n  TwindConfig,\n  TwindRule,\n  TwindUserConfig,\n} from './types'\nimport type { SortableRule } from './internal/sorted-insertion-index'\n\nimport { sortedInsertionIndex } from './internal/sorted-insertion-index'\nimport { stringify } from './internal/stringify'\nimport { createContext } from './internal/context'\nimport { translate, translateWith } from './internal/translate'\nimport { parse } from './parse'\nimport { defineConfig } from './define-config'\nimport { asArray } from './utils'\nimport { serialize } from './internal/serialize'\nimport { Layer } from './internal/precedence'\n\n/**\n * @group Runtime\n * @param config\n * @param sheet\n */\nexport function twind<Theme extends BaseTheme = BaseTheme, Target = unknown>(\n  config: TwindConfig<Theme>,\n  sheet: Sheet<Target>,\n): Twind<Theme, Target>\n\nexport function twind<\n  Theme = BaseTheme,\n  Presets extends Preset<any>[] = Preset[],\n  Target = unknown,\n>(\n  config: TwindUserConfig<Theme, Presets>,\n  sheet: Sheet<Target>,\n): Twind<BaseTheme & ExtractThemes<Theme, Presets>, Target>\n\nexport function twind(userConfig: TwindConfig<any> | TwindUserConfig<any>, sheet: Sheet): Twind {\n  const config = defineConfig(userConfig as TwindUserConfig<any>)\n\n  const context = createContext(config)\n\n  // Map of tokens to generated className\n  let cache = new Map<string, string>()\n\n  // An array of precedence by index within the sheet\n  // always sorted\n  let sortedPrecedences: SortableRule[] = []\n\n  // Cache for already inserted css rules\n  // to prevent double insertions\n  let insertedRules = new Set<string>()\n\n  sheet.resume(\n    (className) => cache.set(className, className),\n    (cssText, rule) => {\n      sheet.insert(cssText, sortedPrecedences.length, rule)\n      sortedPrecedences.push(rule)\n      insertedRules.add(cssText)\n    },\n  )\n\n  function insert(rule: TwindRule): string | undefined {\n    const finalRule = context.f(rule)\n\n    const cssText = stringify(finalRule)\n\n    // If not already inserted\n    if (cssText && !insertedRules.has(cssText)) {\n      // Mark rule as inserted\n      insertedRules.add(cssText)\n\n      // Find the correct position\n      const index = sortedInsertionIndex(sortedPrecedences, rule)\n\n      // Insert\n      sheet.insert(cssText, index, rule)\n\n      // Update sorted index\n      sortedPrecedences.splice(index, 0, rule)\n    }\n\n    return finalRule.n\n  }\n\n  return Object.defineProperties(\n    function tw(tokens) {\n      if (!cache.size) {\n        for (let preflight of asArray(config.preflight)) {\n          if (typeof preflight == 'function') {\n            preflight = preflight(context)\n          }\n\n          if (preflight) {\n            ;(typeof preflight == 'string'\n              ? translateWith('', Layer.b, parse(preflight), context, Layer.b, [], false, true)\n              : serialize(preflight, {}, context, Layer.b)\n            ).forEach(insert)\n          }\n        }\n      }\n\n      tokens = '' + tokens\n\n      let className = cache.get(tokens)\n\n      if (!className) {\n        const classNames = new Set<string | undefined>()\n\n        for (const rule of translate(parse(tokens), context)) {\n          classNames.add(rule.c).add(insert(rule))\n        }\n\n        className = [...classNames].filter(Boolean).join(' ')\n\n        // Remember the generated class name\n        cache.set(tokens, className).set(className, className)\n      }\n\n      return className\n    } as Twind,\n    Object.getOwnPropertyDescriptors({\n      get target() {\n        return sheet.target\n      },\n\n      theme: context.theme,\n\n      config,\n\n      snapshot() {\n        const restoreSheet = sheet.snapshot()\n        const insertedRules$ = new Set(insertedRules)\n        const cache$ = new Map(cache)\n        const sortedPrecedences$ = [...sortedPrecedences]\n\n        return () => {\n          restoreSheet()\n\n          insertedRules = insertedRules$\n          cache = cache$\n          sortedPrecedences = sortedPrecedences$\n        }\n      },\n\n      clear() {\n        sheet.clear()\n\n        insertedRules = new Set()\n        cache = new Map()\n        sortedPrecedences = []\n      },\n\n      destroy() {\n        this.clear()\n        sheet.destroy()\n      },\n    }),\n  )\n}\n", "/* eslint-disable @typescript-eslint/no-unsafe-member-access */\nimport type {\n  BaseTheme,\n  MaybeColorValue,\n  ThemeConfig,\n  ThemeFunction,\n  ThemeSectionResolverContext,\n} from '../types'\nimport { toColorValue } from '../colors'\nimport { resolveThemeFunction } from './serialize'\n\nexport function makeThemeFunction<Theme extends BaseTheme = BaseTheme>({\n  extend = {},\n  ...base\n}: ThemeConfig<Theme>): ThemeFunction<Theme> {\n  const resolved: Record<string, any> = {}\n\n  const resolveContext: ThemeSectionResolverContext<Theme> = {\n    get colors() {\n      return theme('colors')\n    },\n\n    theme,\n\n    // Stub implementation as negated values are automatically infered and do _not_ need to be in the theme\n    negative() {\n      return {}\n    },\n\n    breakpoints(screens) {\n      const breakpoints = {} as Record<string, string>\n\n      for (const key in screens) {\n        if (typeof screens[key] == 'string') {\n          breakpoints['screen-' + key] = screens[key] as string\n        }\n      }\n\n      return breakpoints\n    },\n  }\n\n  return theme as ThemeFunction<Theme>\n\n  function theme(\n    sectionKey?: string,\n    key?: string,\n    defaultValue?: any,\n    opacityValue?: string | undefined,\n  ): any {\n    if (sectionKey) {\n      ;({ 1: sectionKey, 2: opacityValue } =\n        // eslint-disable-next-line no-sparse-arrays\n        /^(\\S+?)(?:\\s*\\/\\s*([^/]+))?$/.exec(sectionKey) || ([, sectionKey] as [undefined, string]))\n\n      if (/[.[]/.test(sectionKey)) {\n        const path: string[] = []\n\n        // dotted deep access: colors.gray.500 or spacing[2.5]\n        sectionKey.replace(\n          /\\[([^\\]]+)\\]|([^.[]+)/g,\n          (_, $1, $2 = $1) => path.push($2) as unknown as string,\n        )\n\n        sectionKey = path.shift() as string\n        defaultValue = key\n        key = path.join('-')\n      }\n\n      const section =\n        resolved[sectionKey] ||\n        // two-step deref to allow extend section to reference base section\n        Object.assign(\n          Object.assign(\n            // Make sure to not get into recursive calls\n            (resolved[sectionKey] = {}),\n            deref(base, sectionKey),\n          ),\n          deref(extend, sectionKey),\n        )\n\n      if (key == null) return section\n\n      key ||= 'DEFAULT'\n\n      const value =\n        section[key] ?? key.split('-').reduce((obj, prop) => obj?.[prop], section) ?? defaultValue\n\n      return opacityValue\n        ? toColorValue(value, { opacityValue: resolveThemeFunction(opacityValue, theme) })\n        : value\n    }\n\n    // Collect the whole theme\n    const result = {} as Record<string, any>\n\n    for (const section of [...Object.keys(base), ...Object.keys(extend)]) {\n      result[section] = theme(section)\n    }\n\n    return result\n  }\n\n  function deref(source: any, section: string): any {\n    let value = source[section]\n\n    if (typeof value == 'function') {\n      value = value(resolveContext)\n    }\n\n    if (value && /color|fill|stroke/i.test(section)) {\n      return flattenColorPalette(value)\n    }\n\n    return value\n  }\n}\n\nfunction flattenColorPalette(colors: Record<string, MaybeColorValue>, path: string[] = []): any {\n  const flattend: Record<string, MaybeColorValue> = {}\n\n  for (const key in colors) {\n    const value = colors[key]\n\n    let keyPath = [...path, key]\n\n    flattend[keyPath.join('-')] = value\n\n    if (key == 'DEFAULT') {\n      keyPath = path\n      flattend[path.join('-')] = value\n    }\n\n    if (typeof value == 'object') {\n      Object.assign(flattend, flattenColorPalette(value, keyPath))\n    }\n  }\n\n  return flattend\n}\n", "/**\n * Determines if two class name strings contain the same classes.\n *\n * @param a first class names\n * @param b second class names\n * @returns are they different\n */\nexport function changed(a: string, b: string): boolean {\n  return a != b && '' + a.split(' ').sort() != '' + b.split(' ').sort()\n}\n", "import type { BaseTheme, Twind } from './types'\n\nimport { changed } from './internal/changed'\nimport { tw as tw$ } from './runtime'\n\nexport interface TwindMutationObserver {\n  observe: (target: Node) => void\n  disconnect: () => void\n}\n\n/**\n * @group Runtime\n * @param tw\n * @param target\n * @returns\n * @internal\n */\nexport function mo<Theme extends BaseTheme = BaseTheme, Target = unknown>(\n  tw: Twind<Theme, Target>,\n): TwindMutationObserver {\n  const observer = new MutationObserver(handleMutationRecords)\n\n  return {\n    observe(target) {\n      observer.observe(target, {\n        attributeFilter: ['class'],\n        subtree: true,\n        childList: true,\n      })\n\n      // handle class attribute on target\n      handleClassAttributeChange(target as Element)\n\n      // handle children of target\n      handleMutationRecords([{ target, type: '' }])\n    },\n    disconnect() {\n      observer.disconnect()\n    },\n  }\n\n  function handleMutationRecords(records: MinimalMutationRecord[]): void {\n    for (const { type, target } of records) {\n      if (type[0] == 'a' /* attribute */) {\n        // class attribute has been changed\n        handleClassAttributeChange(target as Element)\n      } else {\n        /* childList */\n        // some nodes have been added — find all with a class attribute\n        for (const el of (target as Element).querySelectorAll('[class]')) {\n          handleClassAttributeChange(el)\n        }\n      }\n    }\n\n    // remove pending mutations — these are triggered by updating the class attributes\n    observer.takeRecords()\n    // XXX maybe we need to handle all pending mutations\n    // observer.takeRecords().forEach(handleMutation)\n  }\n\n  function handleClassAttributeChange(target: Element): void {\n    // Not using target.classList.value (not supported in all browsers) or target.class (this is an SVGAnimatedString for svg)\n    // safe guard access to getAttribute because ShadowRoot does not have attribute but child nodes\n    const tokens = target.getAttribute?.('class')\n\n    let className: string\n\n    // try do keep classNames unmodified\n    if (tokens && changed(tokens, (className = tw(tokens)))) {\n      // Not using `target.className = ...` as that is read-only for SVGElements\n      target.setAttribute('class', className)\n    }\n  }\n}\n\n/**\n * @group Runtime\n * @param tw\n * @param target\n * @returns\n */\nexport function observe<Theme extends BaseTheme = BaseTheme, Target = unknown>(\n  tw: Twind<Theme, Target> = tw$ as unknown as Twind<Theme, Target>,\n  target: false | Node = typeof document != 'undefined' && document.documentElement,\n): Twind<Theme, Target> {\n  if (target) {\n    const observer = mo(tw)\n\n    observer.observe(target)\n\n    // monkey patch tw.destroy to disconnect this observer\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    const { destroy } = tw\n    tw.destroy = () => {\n      observer.disconnect()\n      destroy.call(tw)\n    }\n  }\n\n  return tw\n}\n\n/**\n * Simplified MutationRecord which allows us to pass an\n * ArrayLike (compatible with Array and NodeList) `addedNodes` and\n * omit other properties we are not interested in.\n */\ninterface MinimalMutationRecord {\n  readonly type: string\n  readonly target: Node\n}\n", "import { warn } from './internal/warn'\nimport type { Sheet, SheetRule } from './types'\nimport { asArray, noop } from './utils'\n\nfunction getStyleElement(selector: string | null | undefined | false): HTMLStyleElement {\n  let style = document.querySelector(selector || 'style[data-twind=\"\"]')\n\n  if (!style || style.tagName != 'STYLE') {\n    style = document.createElement('style')\n    document.head.prepend(style)\n  }\n\n  ;(style as HTMLElement).dataset.twind = 'claimed'\n\n  return style as HTMLStyleElement\n}\n\n/**\n * @group Sheets\n * @param element\n * @returns\n */\nexport function cssom(\n  element?: CSSStyleSheet | HTMLStyleElement | string | null | false,\n): Sheet<CSSStyleSheet> {\n  const target = (element as CSSStyleSheet)?.cssRules\n    ? (element as CSSStyleSheet)\n    : ((element && typeof element != 'string'\n        ? (element as HTMLStyleElement)\n        : getStyleElement(element)\n      ).sheet as CSSStyleSheet)\n\n  return {\n    target,\n\n    snapshot() {\n      // collect current rules\n      const rules = Array.from(target.cssRules, (rule) => rule.cssText)\n\n      return () => {\n        // remove all existing rules\n        this.clear()\n\n        // add all snapshot rules back\n        // eslint-disable-next-line @typescript-eslint/unbound-method\n        rules.forEach(this.insert as (cssText: string, index: number) => void)\n      }\n    },\n\n    clear() {\n      // remove all added rules\n      for (let index = target.cssRules.length; index--; ) {\n        target.deleteRule(index)\n      }\n    },\n\n    destroy() {\n      target.ownerNode?.remove()\n    },\n\n    insert(cssText, index) {\n      try {\n        // Insert\n        target.insertRule(cssText, index)\n      } catch (error) {\n        // Empty rule to keep index valid — not using `*{}` as that would show up in all rules (DX)\n        target.insertRule(':root{}', index)\n\n        // Some thrown errors are because of specific pseudo classes\n        // lets filter them to prevent unnecessary warnings\n        // ::-moz-focus-inner\n        // :-moz-focusring\n        if (!/:-[mwo]/.test(cssText)) {\n          warn((error as Error).message, 'TWIND_INVALID_CSS', cssText)\n        }\n      }\n    },\n\n    resume: noop,\n  }\n}\n\n/**\n * @group Sheets\n * @param element\n * @returns\n */\nexport function dom(element?: HTMLStyleElement | string | null | false): Sheet<HTMLStyleElement> {\n  const target = element && typeof element != 'string' ? element : getStyleElement(element)\n\n  return {\n    target,\n\n    snapshot() {\n      // collect current rules\n      const rules = Array.from(target.childNodes, (node) => node.textContent as string)\n\n      return () => {\n        // remove all existing rules\n        this.clear()\n\n        // add all snapshot rules back\n        // eslint-disable-next-line @typescript-eslint/unbound-method\n        rules.forEach(this.insert as (cssText: string, index: number) => void)\n      }\n    },\n\n    clear() {\n      target.textContent = ''\n    },\n\n    destroy() {\n      target.remove()\n    },\n\n    insert(cssText, index) {\n      target.insertBefore(document.createTextNode(cssText), target.childNodes[index] || null)\n    },\n\n    resume: noop,\n  }\n}\n\n/**\n * @group Sheets\n * @param includeResumeData\n * @returns\n */\nexport function virtual(includeResumeData?: boolean): Sheet<string[]> {\n  const target: string[] = []\n\n  return {\n    target,\n\n    snapshot() {\n      // collect current rules\n      const rules = [...target]\n\n      return () => {\n        // remove all existing rules and add all snapshot rules back\n        target.splice(0, target.length, ...rules)\n      }\n    },\n\n    clear() {\n      target.length = 0\n    },\n\n    destroy() {\n      this.clear()\n    },\n\n    insert(css, index, rule) {\n      target.splice(\n        index,\n        0,\n        includeResumeData\n          ? `/*!${rule.p.toString(36)},${(rule.o * 2).toString(36)}${\n              rule.n ? ',' + rule.n : ''\n            }*/${css}`\n          : css,\n      )\n    },\n\n    resume: noop,\n  }\n}\n\n/**\n * Returns a sheet useable in the current environment.\n *\n * @group Sheets\n * @param useDOMSheet usually something like `process.env.NODE_ENV != 'production'` or `import.meta.env.DEV` (default: browser={@link cssom}, server={@link virtual})\n * @param disableResume to not include or use resume data\n * @returns a sheet to use\n */\nexport function getSheet(\n  useDOMSheet?: boolean,\n  disableResume?: boolean,\n): Sheet<string[] | HTMLStyleElement | CSSStyleSheet> {\n  const sheet =\n    typeof document == 'undefined' ? virtual(!disableResume) : useDOMSheet ? dom() : cssom()\n\n  if (!disableResume) sheet.resume = resume\n\n  return sheet\n}\n\n/**\n * @group Sheets\n * @param target\n * @returns\n */\nexport function stringify(target: unknown): string {\n  // string[] | CSSStyleSheet | HTMLStyleElement\n  return (\n    // prefer the raw text content of a CSSStyleSheet as it may include the resume data\n    ((target as CSSStyleSheet).ownerNode || (target as HTMLStyleElement)).textContent ||\n    ((target as CSSStyleSheet).cssRules\n      ? Array.from((target as CSSStyleSheet).cssRules, (rule) => rule.cssText)\n      : asArray(target)\n    ).join('')\n  )\n}\n\nfunction resume(\n  this: Sheet,\n  addClassName: (className: string) => void,\n  insert: (cssText: string, rule: SheetRule) => void,\n) {\n  // hydration from SSR sheet\n  const textContent = stringify(this.target)\n  const RE = /\\/\\*!([\\da-z]+),([\\da-z]+)(?:,(.+?))?\\*\\//g\n\n  // only if this is a hydratable sheet\n  if (RE.test(textContent)) {\n    // RE has global flag — reset index to get the first match as well\n    RE.lastIndex = 0\n\n    // 1. start with a fresh sheet\n    this.clear()\n\n    // 2. add all existing class attributes to the token/className cache\n    if (typeof document != 'undefined') {\n      for (const el of document.querySelectorAll('[class]')) {\n        addClassName(el.getAttribute('class') as string)\n      }\n    }\n\n    // 3. parse SSR styles\n    let lastMatch: RegExpExecArray | null | undefined\n\n    while (\n      (function commit(match?: RegExpExecArray | null) {\n        if (lastMatch) {\n          insert(\n            // grep the cssText from the previous match end up to this match start\n            textContent.slice(lastMatch.index + lastMatch[0].length, match?.index),\n            {\n              p: parseInt(lastMatch[1], 36),\n              o: parseInt(lastMatch[2], 36) / 2,\n              n: lastMatch[3],\n            },\n          )\n        }\n\n        return (lastMatch = match)\n      })(RE.exec(textContent))\n    ) {\n      /* no-op */\n    }\n  }\n}\n", "import type { CSSBase, CSSObject, CSSValue } from './types'\n\nimport { tw as tw$ } from './runtime'\nimport { astish } from './internal/astish'\nimport { css } from './css'\n\nexport interface InjectGlobalFunction {\n  (style: CSSBase | string): void\n\n  (strings: TemplateStringsArray, ...interpolations: readonly CSSValue[]): void\n\n  bind(thisArg?: ((tokens: string) => string) | undefined | void): InjectGlobalFunction\n\n  call(thisArg: ((tokens: string) => string) | undefined | void, style: CSSBase | string): void\n\n  apply(thisArg: ((tokens: string) => string) | undefined | void, args: [CSSBase | string]): void\n}\n\n/**\n * Injects styles into the global scope and is useful for applications such as gloabl styles, CSS resets or font faces.\n *\n * It **does not** return a class name, but adds the styles within the base layer to the stylesheet directly.\n *\n * @group Style Injectors\n */\nexport const injectGlobal: InjectGlobalFunction = function injectGlobal(\n  this: ((tokens: string) => string) | undefined | void,\n  strings: CSSBase | string | TemplateStringsArray,\n  ...interpolations: readonly CSSValue[]\n): void {\n  const tw = typeof this == 'function' ? this : tw$\n\n  tw(\n    css({\n      '@layer base': astish(strings as CSSObject, interpolations),\n    } as CSSObject),\n  )\n}\n", "import type { Twind, BaseTheme, TwindConfig, TwindUserConfig, Preset, ExtractThemes } from './types'\n\nimport { PROD } from 'distilt/env'\n\nimport { defineConfig } from './define-config'\nimport { setup } from './runtime'\nimport { getSheet } from './sheets'\n\n/**\n * @group Runtime\n * @param config\n * @param isProduction\n */\nexport function install<Theme extends BaseTheme = BaseTheme>(\n  config: TwindConfig<Theme>,\n  isProduction?: boolean,\n): Twind<Theme & BaseTheme>\n\nexport function install<Theme = BaseTheme, Presets extends Preset<any>[] = Preset[]>(\n  config: TwindUserConfig<Theme, Presets>,\n  isProduction?: boolean,\n): Twind<BaseTheme & ExtractThemes<Theme, Presets>>\n\nexport function install(config: TwindConfig | TwindUserConfig, isProduction = PROD): Twind {\n  const config$ = defineConfig(config as TwindUserConfig)\n\n  return setup(\n    {\n      ...config$,\n      // in production use short hashed class names\n      hash: config$.hash ?? isProduction,\n    },\n    () => getSheet(!isProduction),\n  )\n}\n", "import type { CSSObject, CSSValue, StringLike } from './types'\n\nimport { escape, hash } from './utils'\nimport { tw as tw$ } from './runtime'\nimport { astish } from './internal/astish'\nimport { css } from './css'\n\nexport interface KeyframesFunction {\n  (style: CSSObject | string): StringLike\n\n  (strings: TemplateStringsArray, ...interpolations: readonly CSSValue[]): StringLike\n\n  bind(thisArg?: ((tokens: string) => string) | undefined | void): Keyframes & {\n    [label: string]: KeyframesFunction\n  }\n\n  call(\n    thisArg: ((tokens: string) => string) | undefined | void,\n    style: CSSObject | string,\n  ): StringLike\n\n  call(\n    thisArg: ((tokens: string) => string) | undefined | void,\n    strings: TemplateStringsArray,\n    ...interpolations: readonly CSSValue[]\n  ): StringLike\n\n  apply(\n    thisArg: ((tokens: string) => string) | undefined | void,\n    args: [CSSObject | string],\n  ): StringLike\n\n  apply(\n    thisArg: ((tokens: string) => string) | undefined | void,\n    args:\n      | [CSSObject | string]\n      | [strings: TemplateStringsArray, ...interpolations: readonly CSSValue[]],\n  ): StringLike\n}\n\nexport type Keyframes = KeyframesFunction & {\n  [label: string]: KeyframesFunction\n}\n\n/**\n * **Note**: The styles will be injected on first use.\n *\n * @group Style Injectors\n */\nexport const keyframes = /* #__PURE__ */ bind()\n\nfunction bind(thisArg: ((tokens: string) => string) | undefined | void): Keyframes {\n  return new Proxy(\n    function keyframes(\n      strings: CSSObject | string | TemplateStringsArray,\n      ...interpolations: readonly CSSValue[]\n    ): StringLike {\n      return keyframes$(thisArg, '', strings, interpolations)\n    } as Keyframes,\n    {\n      get(target, name) {\n        if (name === 'bind') {\n          return bind\n        }\n\n        if (name in target) return target[name as string]\n\n        return function namedKeyframes(\n          strings: CSSObject | string | TemplateStringsArray,\n          ...interpolations: readonly CSSValue[]\n        ): StringLike {\n          return keyframes$(thisArg, name as string, strings, interpolations)\n        }\n      },\n    },\n  )\n}\n\nfunction keyframes$(\n  thisArg: ((tokens: string) => string) | undefined | void,\n  name: string,\n  strings: CSSObject | string | TemplateStringsArray,\n  interpolations: readonly CSSValue[],\n): StringLike {\n  // lazy inject keyframes\n  return {\n    toString() {\n      // lazy access tw\n      const tw = typeof thisArg == 'function' ? thisArg : tw$\n\n      const ast = astish(strings, interpolations)\n\n      const keyframeName = escape(name + hash(JSON.stringify([name, ast])))\n\n      tw(\n        css({\n          [`@keyframes ${keyframeName}`]: astish(strings, interpolations),\n        } as unknown as CSSObject),\n      )\n\n      return keyframeName\n    },\n  } as StringLike\n}\n", "import type { Twind } from './types'\nimport { changed } from './internal/changed'\nimport { tw as tw$ } from './runtime'\nimport { identity } from './utils'\nimport { stringify } from './sheets'\nimport { fixClassList, parseHTML } from './internal/parse-html'\n\n/**\n * Options for {@link inline}\n */\nexport interface InlineOptions {\n  /**\n   * {@link Twind} instance to use (default: {@link @twind/core.tw})\n   */\n  tw?: Twind<any, any>\n\n  /**\n   * Allows to minify the resulting CSS.\n   */\n  minify?: InlineMinify\n}\n\nexport interface InlineMinify {\n  /**\n   * Called to minify the CSS.\n   *\n   * @param css the CSS to minify\n   * @param html the HTML that will be used — allows to only include above-the-fold CSS\n   * @return the resulting CSS\n   */\n  (css: string, html: string): string\n}\n/**\n * Used for static HTML processing (usually to provide SSR support for your javascript-powered web apps)\n *\n * 1. parse the markup and process element classes with the provided Twind instance\n * 2. update the class attributes _if_ necessary\n * 3. inject a style element with the CSS as last element into the head\n * 4. return the HTML string with the final element classes\n *\n * ```js\n * import { inline } from '@twind/core'\n *\n * function render() {\n *   return inline(renderApp())\n * }\n * ```\n *\n * Minify CSS with [@parcel/css](https://www.npmjs.com/package/@parcel/css):\n *\n * ```js\n * import { inline } from '@twind/core'\n * import { transform } from '@parcel/css'\n *\n * function render() {\n *   return inline(renderApp(), { minify: (css) => transform({ filename: 'twind.css', code: Buffer.from(css), minify: true }) })\n * }\n * ```\n *\n * You can provide your own Twind instance:\n *\n * ```js\n * import { inline } from '@twind/core'\n * import { tw } from './custom/twind/instance'\n *\n * function render() {\n *   return inline(renderApp(), { tw })\n * }\n * ```\n *\n * @group Static Extraction\n * @param markup HTML to process\n * @param options to customize the processing\n * @returns the resulting HTML\n */\nexport function inline(markup: string, options: InlineOptions['tw'] | InlineOptions = {}): string {\n  const { tw = tw$, minify = identity } =\n    typeof options == 'function' ? ({ tw: options } as InlineOptions) : options\n\n  const { html, css } = extract(markup, tw)\n\n  // inject as last element into the head\n  return html.replace('</head>', `<style data-twind>${minify(css, html)}</style></head>`)\n}\n\n/**\n * Result of {@link extract}\n */\nexport interface ExtractResult {\n  /** The possibly modified HTML */\n  html: string\n\n  /** The generated CSS */\n  css: string\n}\n\n/**\n * Used for static HTML processing (usually to provide SSR support for your javascript-powered web apps)\n *\n * **Note**: Consider using {@link inline} instead.\n *\n * 1. parse the markup and process element classes with the provided Twind instance\n * 2. update the class attributes _if_ necessary\n * 3. return the HTML string with the final element classes\n *\n * ```js\n * import { extract } from '@twind/core'\n *\n * function render() {\n *   const { html, css } = extract(renderApp())\n *\n *   // inject as last element into the head\n *   return html.replace('</head>', `<style data-twind>${css}</style></head>`)\n * }\n * ```\n *\n * You can provide your own Twind instance:\n *\n * ```js\n * import { extract } from '@twind/core'\n * import { tw } from './custom/twind/instance'\n *\n * function render() {\n *   const { html, css } = extract(renderApp(), tw)\n *\n *   // inject as last element into the head\n *   return html.replace('</head>', `<style data-twind>${css}</style></head>`)\n * }\n * ```\n *\n * @group Static Extraction\n * @param markup HTML to process\n * @param tw a {@link Twind} instance (default: twind managed tw)\n * @returns the possibly modified html and css\n */\nexport function extract(html: string, tw: Twind<any, any> = tw$): ExtractResult {\n  const restore = tw.snapshot()\n\n  const result = { html: consume(html, tw), css: stringify(tw.target) }\n\n  restore()\n\n  return result\n}\n\n/**\n * Used for static HTML processing (usually to provide SSR support for your javascript-powered web apps)\n *\n * **Note**: Consider using {@link inline} or {@link extract} instead.\n *\n * 1. parse the markup and process element classes with the provided Twind instance\n * 2. update the class attributes _if_ necessary\n * 3. return the HTML string with the final element classes\n *\n * ```js\n * import { consume, stringify, tw } from '@twind/core'\n *\n * function render() {\n *   const html = renderApp()\n *\n *   // remember global classes\n *   const restore = tw.snapshot()\n *\n *   // generated markup\n *   const markup = consume(html)\n *\n *   // create CSS\n *   const css = stringify(tw.target)\n *\n *   // restore global classes\n *   restore()\n *\n *   // inject as last element into the head\n *   return markup.replace('</head>', `<style data-twind>${css}</style></head>`)\n * }\n * ```\n *\n * You can provide your own Twind instance:\n *\n * ```js\n * import { consume, stringify } from '@twind/core'\n * import { tw } from './custom/twind/instance'\n *\n * function render() {\n *   const html = renderApp()\n *\n *   // remember global classes\n *   const restore = snapshot(tw.target)\n *\n *   // generated markup\n *   const markup = consume(html)\n *\n *   // restore global classes\n *   restore()\n *\n *   // create CSS\n *   const css = stringify(tw.target)\n *\n *   // inject as last element into the head\n *   return markup.replace('</head>', `<style data-twind>${css}</style></head>`)\n * }\n * ```\n *\n * @group Static Extraction\n * @param markup HTML to process\n * @param tw a {@link Twind} instance\n * @returns possibly modified HTML\n */\nexport function consume(markup: string, tw: (className: string) => string = tw$): string {\n  let result = ''\n  let lastChunkStart = 0\n\n  parseHTML(markup, (startIndex, endIndex, quote) => {\n    const value = markup.slice(startIndex, endIndex)\n    const className = tw(fixClassList(value, quote))\n\n    // We only need to shift things around if we need to actually change the markup\n    if (changed(value, className)) {\n      // We've hit another mutation boundary\n\n      // Add quote if necessary\n      quote = quote ? '' : '\"'\n\n      result += markup.slice(lastChunkStart, startIndex) + quote + className + quote\n\n      lastChunkStart = endIndex\n    }\n  })\n\n  // Combine the current result with the tail-end of the input\n  return result + markup.slice(lastChunkStart, markup.length)\n}\n", "// For now we are using a simple parser adapted from htm (https://github.com/developit/htm/blob/master/src/build.mjs)\n// If we find any issues we can switch to something more sophisticated like\n// - https://github.com/acrazing/html5parser\n// - https://github.com/fb55/htmlparser2\n\nconst MODE_SLASH = 0\nconst MODE_TEXT = 1\nconst MODE_WHITESPACE = 2\nconst MODE_TAGNAME = 3\nconst MODE_COMMENT = 4\nconst MODE_ATTRIBUTE = 5\n\nexport function parseHTML(\n  markup: string,\n  onClass: (startIndex: number, endIndex: number, quote: string) => false | unknown,\n): void {\n  let mode = MODE_TEXT\n  let startIndex = 0\n  let quote = ''\n  let attributeName = ''\n\n  const commit = (currentIndex: number): void => {\n    if (mode == MODE_ATTRIBUTE && attributeName == 'class') {\n      if (onClass(startIndex, currentIndex, quote) === false) {\n        markup = ''\n      }\n    }\n  }\n\n  for (let position = 0; position < markup.length; position++) {\n    const char = markup[position]\n\n    if (mode == MODE_TEXT) {\n      if (char == '<') {\n        mode = markup.substr(position + 1, 3) == '!--' ? MODE_COMMENT : MODE_TAGNAME\n      }\n    } else if (mode == MODE_COMMENT) {\n      // Ignore everything until the last three characters are '-', '-' and '>'\n      if (char == '>' && markup.slice(position - 2, position) == '--') {\n        mode = MODE_TEXT\n      }\n    } else if (quote) {\n      if (char == quote && markup[position - 1] != '\\\\') {\n        commit(position)\n        mode = MODE_WHITESPACE\n        quote = ''\n      }\n    } else if (char == '\"' || char == \"'\") {\n      quote = char\n      startIndex += 1\n    } else if (char == '>') {\n      commit(position)\n      mode = MODE_TEXT\n    } else if (!mode) {\n      // MODE_SLASH\n      // Ignore everything until the tag ends\n    } else if (char == '=') {\n      attributeName = markup.slice(startIndex, position)\n      mode = MODE_ATTRIBUTE\n      startIndex = position + 1\n    } else if (char == '/' && (mode < MODE_ATTRIBUTE || markup[position + 1] == '>')) {\n      commit(position)\n      mode = MODE_SLASH\n    } else if (/\\s/.test(char)) {\n      // <a class=font-bold>\n      commit(position)\n      mode = MODE_WHITESPACE\n      startIndex = position + 1\n    }\n  }\n}\n\nexport function fixClassList(value: string, quote: string): string {\n  // const value = markup.slice(startIndex, endIndex)\n\n  // Lets handle some special react cases:\n  //   * arbitrary values for `content-`\n  //     <span class=\"before:content-[&#x27;asas&#x27;]\"></span>\n  //     <span class=\"before:content-[&quot;asas&quot;]\"></span>\n  //\n  //   * self-referenced groups\n  //     <span class=\"flex(&amp; col)\"></span>\n  //\n  //     If a class name contains `'`, `\"`, or `&` those will be replaced with HTML entities\n  //     To fix this we replace those for depending on the actual symbol that is being used\n  //     As an alternative we could always escape class names direcly in twind like react does\n  //     but this works for now\n  return (\n    quote == `\"`\n      ? // `'` -> &#39; &apos; &#x27;\n        value.replace(/(=|\\[)(?:&#39;|&apos;|&#x27;)|(?:&#39;|&apos;|&#x27;)(])/g, `$1'$2`)\n      : quote == `'`\n      ? // `\"` -> &#34; &quot; &#x22;\n        value.replace(/(=|\\[)(?:&#34;|&quot;|&#x22;)|(?:&#34;|&quot;|&#x22;)(])/g, `$1\"$2`)\n      : value\n  ).replace(/(&#38;|&amp;|&#x26;)/g, '&')\n}\n", "// Based on https://github.com/modulz/stitches\n// License MIT\n// eslint-disable @typescript-eslint/ban-types\n\nimport type { Falsey, MatchResult } from './types'\nimport { parse } from './parse'\nimport { Layer } from './internal/precedence'\n\nimport { escape, hash } from './utils'\nimport { define } from './internal/define'\n\nexport type StrictMorphVariant<T> = T extends number\n  ? `${T}` | T\n  : T extends 'true'\n  ? true | T\n  : T extends 'false'\n  ? false | T\n  : T\n\nexport type MorphVariant<T> = T extends number\n  ? `${T}` | T\n  : T extends 'true'\n  ? boolean | T\n  : T extends 'false'\n  ? boolean | T\n  : T extends `${number}`\n  ? number | T\n  : T\n\nexport type StyleTokenValue = string | Falsey\n\n// No support for thunks yet — these may use props that are not in the generated class name\n// and may therefore override each other\n\nexport type StyleToken = StyleTokenValue\n\n/**\n * Allows to extract the supported properties of a style function.\n *\n * Here is an example for `react`\n * ```js\n * import { HTMLAttributes } from \"react\";\n * import { style, PropsOf } from \"@twind/core\";\n * const button = style({ ... })\n * type ButtonProps = PropsOf<typeof button>\n * export const Button = (props: ButtonProps & HTMLAttributes<HTMLButtonElement>) => {\n *   return <button className={style(props)} {...rest} />\n * }\n * ```\n */\nexport type PropsOf<T> = T extends Style<infer Variants>\n  ? {\n      [key in keyof Variants]: MorphVariant<keyof Variants[key]>\n    }\n  : never\n\nexport type DefaultVariants<Variants> = {\n  [key in keyof Variants]?:\n    | StrictMorphVariant<keyof Variants[key]>\n    | (Record<string, StrictMorphVariant<keyof Variants[key]>> & {\n        /** initial breakpoint */\n        _?: StrictMorphVariant<keyof Variants[key]>\n      })\n}\n\nexport type VariantsProps<Variants> = {\n  [key in keyof Variants]?:\n    | MorphVariant<keyof Variants[key]>\n    // TODO possible breakpoint from theme\n    | (Record<string, MorphVariant<keyof Variants[key]>> & {\n        /** initial breakpoint */\n        _?: MorphVariant<keyof Variants[key]>\n      })\n}\n\nexport type When<Variants> = {\n  [key in keyof Variants]?: StrictMorphVariant<keyof Variants[key]>\n}\n\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport interface StyleConfig<Variants, BaseVariants = {}> {\n  /** Used as prefix */\n  label?: string\n  base?: StyleToken\n  props?: Variants & {\n    [variant in keyof BaseVariants]?: {\n      [key in keyof BaseVariants[variant]]?: StyleToken\n    }\n  }\n  defaults?: DefaultVariants<Variants & BaseVariants>\n  when?: [match: When<Variants & BaseVariants>, then: StyleToken][]\n}\n\nexport interface StyleFunction {\n  <Variants>(config?: StyleConfig<Variants>): Style<Variants>\n  <Variants, BaseVariants>(\n    base: Style<BaseVariants>,\n    config?: StyleConfig<Variants, BaseVariants>,\n  ): Style<Variants & BaseVariants>\n}\n\nexport type StyleProps<Variants> = VariantsProps<Variants>\n\nexport interface Style<Variants> {\n  /**\n   * CSS Class associated with the current component.\n   *\n   * ```jsx\n   * const button = style({\n   *   base: css({\n   *     color: \"DarkSlateGray\"\n   *   })\n   * })\n   *\n   * <div className={button()} />\n   * ```\n   * <br />\n   */\n  (props?: StyleProps<Variants>): string\n\n  /**\n   * To be used as resolve within config.rules:\n   *\n   * ```js\n   * {\n   *   rules: [\n   *     // label?prop=value&other=propValue\n   *     // if the style has base eg no prop is required\n   *     ['label(\\\\?.+)?', style( /* ... *\\/ )],\n   *\n   *     // if the style requires at least one prop\n   *     ['label\\\\?(.+)', style( /* ... *\\/ )],\n   *   ]\n   * }\n   * ```\n   *\n   * The first group is used to extract the props using {@link !URLSearchParams | URLSearchParams}.\n   */\n  (match: MatchResult): string\n\n  readonly defaults: StyleProps<Variants>\n\n  /**\n   * CSS Class associated with the current component.\n   *\n   * ```js\n   * const button = style({\n   *   base: css`\n   *     color: \"DarkSlateGray\"\n   *   `\n   * })\n   *\n   * <div className={button.className} />\n   * ```\n   */\n  readonly className: string\n\n  /**\n   * CSS Selector associated with the current component.\n   *\n   * ```js\n   * const button = style({\n   *   base: css({\n   *     color: \"DarkSlateGray\"\n   *   })\n   * })\n   *\n   * const Card = styled({\n   *   base: css`\n   *     & ${button.selector} {\n   *       boxShadow: \"0 0 0 5px\"\n   *     }\n   *   `\n   * })\n   * ```\n   */\n  readonly selector: string\n}\n\n/**\n * @group Class Name Generators\n */\nexport const style = (<Variants, BaseVariants>(\n  base: Style<BaseVariants> | StyleConfig<Variants>,\n  config?: StyleConfig<Variants, BaseVariants>,\n): Style<Variants & BaseVariants> =>\n  (typeof base == 'function' ? createStyle(config, base) : createStyle(base)) as Style<\n    Variants & BaseVariants\n  > &\n    string) as StyleFunction\n\nfunction createStyle<Variants, BaseVariants>(\n  config: StyleConfig<Variants, BaseVariants> = {},\n  parent?: Style<BaseVariants>,\n): Style<Variants & BaseVariants> {\n  const { label = 'style', base, props: variants = {}, defaults: localDefaults, when = [] } = config\n\n  const defaults = { ...parent?.defaults, ...localDefaults }\n\n  const id = hash(JSON.stringify([label, parent?.className, base, variants, defaults, when]))\n\n  // Layers:\n  // component: 0b010\n  // props: 0b011\n  // when: 0b100\n\n  const className = register('', base || '', Layer.c)\n\n  function register(mq: string, token: string, layer: number): string {\n    return define(\n      // `<name>#<id>` or `<parent>~<name>#<id>`\n      ((parent ? parent.className.replace(/#.+$/, '~') : '') + label + mq + id).replace(\n        /[: ,()[\\]]/,\n        '',\n      ),\n      layer,\n      token && parse(token),\n    )\n  }\n\n  return Object.defineProperties(\n    function style(allProps) {\n      let isWithinRuleDeclaration\n\n      if (Array.isArray(allProps)) {\n        isWithinRuleDeclaration = true\n        allProps = Object.fromEntries(new URLSearchParams(allProps[1]).entries()) as VariantsProps<\n          Variants & BaseVariants\n        >\n      }\n\n      const props = { ...defaults, ...allProps }\n\n      // If this style is used within config.rules we do NOT include the marker classes\n      let classNames = isWithinRuleDeclaration\n        ? ''\n        : (parent ? parent(props) + ' ' : '') + className\n\n      let token: StyleToken\n\n      for (const variantKey in variants) {\n        const variant = (variants as Record<string, Record<string, StyleToken>>)[variantKey]\n        const propsValue = (props as Record<string, unknown>)[variantKey]\n\n        if (propsValue === Object(propsValue)) {\n          // inline responsive breakpoints\n          let mq = ''\n          token = ''\n\n          for (const breakpoint in propsValue as Record<string, string>) {\n            const breakpointToken = variant[(propsValue as Record<string, string>)[breakpoint]]\n\n            if (breakpointToken) {\n              mq += '@' + breakpoint + '-' + (propsValue as Record<string, string>)[breakpoint]\n\n              token +=\n                (token && ' ') +\n                (breakpoint == '_' ? breakpointToken : breakpoint + ':(' + breakpointToken + ')')\n            }\n          }\n\n          if (token) {\n            classNames +=\n              ' ' + register('--' + variantKey + '-' + mq, token, 0b011 << 27 /* Shifts.layer */)\n          }\n        } else if ((token = variant[propsValue as string])) {\n          classNames +=\n            ' ' +\n            register(\n              '--' + variantKey + '-' + (propsValue as string),\n              token,\n              0b011 << 27 /* Shifts.layer */,\n            )\n        }\n      }\n\n      when.forEach((match, index) => {\n        let mq = ''\n\n        for (const variantKey in match[0]) {\n          const propsValue = (props as Record<string, unknown>)[variantKey]\n\n          // TODO we ignore inline responsive breakpoints for now — what be the result??\n          if (\n            propsValue !== Object(propsValue) &&\n            '' + propsValue == '' + (match[0] as Record<string, string>)[variantKey]\n          ) {\n            mq += (mq && '_') + variantKey + '-' + (propsValue as string)\n          } else {\n            mq = ''\n            break\n          }\n        }\n\n        if (mq && (token = match[1])) {\n          classNames +=\n            ' ' + register('-' + index + '--' + mq, token, 0b100 << 27 /* Shifts.layer */)\n        }\n      })\n\n      return classNames\n    } as Style<Variants & BaseVariants>,\n    Object.getOwnPropertyDescriptors({\n      className,\n      defaults,\n      selector: '.' + escape(className),\n    }),\n  )\n}\n", "import type { Class } from './types'\nimport { interpolate } from './internal/interpolate'\nimport { tw as tw$ } from './runtime'\n\nexport interface TxFunction {\n  (...classes: Class[]): string\n\n  (strings: TemplateStringsArray, ...interpolations: readonly Class[]): string\n\n  bind(thisArg?: ((tokens: string) => string) | undefined | void): TxFunction\n\n  call(thisArg: ((tokens: string) => string) | undefined | void, ...classes: Class[]): string\n  call(\n    thisArg: ((tokens: string) => string) | undefined | void,\n    strings: TemplateStringsArray,\n    ...interpolations: readonly Class[]\n  ): string\n\n  apply(\n    thisArg: ((tokens: string) => string) | undefined | void,\n    classes: Class[] | [strings: TemplateStringsArray, ...interpolations: readonly Class[]],\n  ): string\n}\n\n/**\n * Combines {@link tw} and {@link cx}.\n *\n * Using the default `tw` instance:\n *\n * ```js\n * import { tw } from '@twind/core'\n * tx`underline ${falsy && 'italic'}`\n * tx('underline', falsy && 'italic')\n * tx({'underline': true, 'italic': false})\n *\n * // using a custom twind instance\n * import { tw } from './custom/twind'\n * import { tw } from './custom/twind'\n * tx.bind(tw)\n * ```\n *\n * Using a custom `tw` instance:\n *\n * ```js\n * import { tx as tx$ } from '@twind/core'\n * import { tw } from './custom/twind'\n *\n * export const tx = tx$.bind(tw)\n *\n * tx`underline ${falsy && 'italic'}`\n * tx('underline', falsy && 'italic')\n * tx({'underline': true, 'italic': false})\n * ```\n *\n * @group Style Injectors\n * @param this {@link Twind} instance to use (default: {@link tw})\n * @param strings\n * @param interpolations\n * @returns the class name\n */\nexport const tx: TxFunction = function tx(\n  this: ((tokens: string) => string) | undefined | void,\n  strings: TemplateStringsArray | Class,\n  ...interpolations: Class[]\n): string {\n  const tw = typeof this == 'function' ? this : tw$\n  return tw(interpolate(strings, interpolations))\n}\n"],
  "mappings": "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",
  "names": ["active", "toClassName", "rule", "v", "i", "n", "join", "format", "rules", "seperator", "map", "escape", "CSS", "className", "replace", "hash", "value", "h", "index", "length", "Math", "imul", "charCodeAt", "toString", "mql", "screen", "prefix", "asArray", "min", "raw", "Object", "keys", "feature", "Array", "isArray", "identity", "noop", "Layer", "d", "b", "c", "a", "u", "o", "seperatorPrecedence", "string", "match", "atRulePrecedence", "css", "test", "max", "RegExp", "$1", "$2", "PRECEDENCES_BY_PSEUDO_CLASS", "convert", "name", "important", "variants", "context", "precedence", "conditions", "variant", "theme", "condition", "selector", "push", "indexOf", "slice", "p", "r", "registry", "Map", "stringify", "groups", "replaceEach", "reduce", "selectorPart", "conditionPart", "mergeMatch", "exec", "selectorIndex", "replaceReference", "reduceRight", "body", "grouping", "iteratee", "_", "comma", "reference", "collator", "Intl", "Collator", "numeric", "sortedInsertionIndex", "array", "element", "low", "high", "pivot", "compareTwindRules", "layer", "compare", "byModifier", "byName", "s", "split", "pop", "String", "fromCharCode", "parseColorComponent", "chars", "factor", "round", "parseInt", "toColorValue", "color", "options", "opacityValue", "opacityVariable", "opacity", "includes", "size", "substr", "autoDarkColor", "section", "key", "shade", "serialize", "style", "serialize$", "declarations", "maxPropertyPrecedence", "numberOfDeclarations", "property", "translateWith", "parse", "JSON", "toLowerCase", "resolveThemeFunction", "rulePrecedence", "screenKey", "unshift", "sort", "__", "___", "defaultValue", "filter", "merge", "current", "result", "Boolean", "translate", "cssRule", "resolved", "factory", "get", "splice", "useOrderOfRules", "flatMap", "define", "set", "createRule", "loc", "negated", "endsWith", "defineProperties", "uniq", "l", "values", "cache", "token", "parsed", "startIndex", "skip", "comment", "position", "commit", "isRule", "endOffset", "char", "lastMatch", "lastGroup", "lastIndexOf", "nested", "shift", "interleave", "strings", "interpolations", "handle", "interpolation", "interpolate", "trim", "tmp", "apply", "alias", "shortcut", "marker", "Proxy", "alias$", "target", "namedAlias", "astish", "astish$", "newRule", "block", "tree", "ast", "find", "label", "animation", "waypoints", "animation$", "namedAnimation", "animationName", "pattern", "resolve", "fromMatch", "maybeNegate", "offset", "$$", "input", "matchTheme", "fromTheme", "withAutocomplete", "themeSection", "camelize", "arbitrary", "isKeyLookup", "entries", "suffix", "concat", "matchColor", "colorFromTheme", "colorMatch", "opacityMatch", "parseValue", "colorValue", "opacitySection", "create", "properties", "toCSS", "undefined", "dark", "darkColorValue", "opacities", "modifiers", "modifier", "normalize", "x", "toUpperCase", "before", "url", "after", "fullMatch", "characterBefore", "repeat", "kAutocomplete", "Symbol", "autocomplete", "defineProperty", "configurable", "getAutocompleteProvider", "resolver", "cx", "defineConfig", "presets", "userConfig", "config", "darkMode", "darkColor", "preflight", "ignorelist", "finalize", "preset", "extend", "warn", "message", "code", "detail", "dispatchEvent", "CustomEvent", "event", "cancelable", "defaultPrevented", "console", "process", "emitWarning", "list", "getResolver", "isDark", "item", "getVariantResolver", "createResolve", "getRuleResolver", "patterns", "createRegExpExecutor", "run", "toCondition", "twind", "sheet", "variantCache", "variantResolvers", "ruleCache", "ruleResolvers", "ignored", "reportedUnknownClasses", "Set", "defaultHash", "ctx", "base", "resolveContext", "colors", "negative", "breakpoints", "screens", "sectionKey", "path", "assign", "deref", "obj", "prop", "source", "flattenColorPalette", "flattend", "keyPath", "e", "has", "add", "f", "sortedPrecedences", "insertedRules", "resume", "cssText", "insert", "finalRule", "tw", "tokens", "forEach", "classNames", "getOwnPropertyDescriptors", "snapshot", "restoreSheet", "insertedRules$", "cache$", "sortedPrecedences$", "clear", "destroy", "changed", "mo", "observer", "MutationObserver", "handleMutationRecords", "observe", "attributeFilter", "subtree", "childList", "handleClassAttributeChange", "type", "disconnect", "records", "el", "querySelectorAll", "takeRecords", "getAttribute", "setAttribute", "tw$", "document", "documentElement", "call", "getStyleElement", "querySelector", "tagName", "createElement", "head", "prepend", "dataset", "cssom", "cssRules", "from", "deleteRule", "ownerNode", "remove", "insertRule", "error", "dom", "childNodes", "node", "textContent", "insertBefore", "createTextNode", "virtual", "includeResumeData", "getSheet", "useDOMSheet", "disableResume", "addClassName", "RE", "lastIndex", "auto", "install", "currentScript", "cancelAutoInstall", "mutationsList", "assertActive", "Error", "_target", "_thisArg", "args", "arguments", "setup", "injectGlobal", "isProduction", "config$", "keyframes", "bind", "thisArg", "keyframes$", "namedKeyframes", "keyframeName", "inline", "markup", "minify", "html", "extract", "restore", "consume", "lastChunkStart", "onClass", "mode", "quote", "attributeName", "currentIndex", "endIndex", "createStyle", "parent", "props", "defaults", "localDefaults", "when", "id", "register", "mq", "allProps", "isWithinRuleDeclaration", "fromEntries", "URLSearchParams", "variantKey", "propsValue", "breakpoint", "breakpointToken", "tx"]
}
