// node_modules/@twind/core/core.dev.js
var active;
function toClassName(rule) {
  return [
    ...rule.v,
    (rule.i ? "!" : "") + rule.n
  ].join(":");
}
function format(rules, seperator = ",") {
  return rules.map(toClassName).join(seperator);
}
var escape = "undefined" != typeof CSS && CSS.escape || // Simplified: escaping only special characters
// Needed for NodeJS and Edge <79 (https://caniuse.com/mdn-api_css_escape)
((className) => className.replace(/[!"'`*+.,;:\\/<=>?@#$%&^|~()[\]{}]/g, "\\$&").replace(/^\d/, "\\3$& "));
function hash(value) {
  for (var h = 9, index = value.length; index--; ) h = Math.imul(h ^ value.charCodeAt(index), 1597334677);
  return "#" + ((h ^ h >>> 9) >>> 0).toString(36);
}
function mql(screen, prefix = "@media ") {
  return prefix + asArray(screen).map((screen2) => {
    return "string" == typeof screen2 && (screen2 = {
      min: screen2
    }), screen2.raw || Object.keys(screen2).map((feature) => `(${feature}-width:${screen2[feature]})`).join(" and ");
  }).join(",");
}
function asArray(value = []) {
  return Array.isArray(value) ? value : null == value ? [] : [
    value
  ];
}
function identity(value) {
  return value;
}
function noop() {
}
var Layer = {
  /**
  * 1. `default` (public)
  */
  d: (
    /* efaults */
    0
  ),
  /* Shifts.layer */
  /**
  * 2. `base` (public) — for things like reset rules or default styles applied to plain HTML elements.
  */
  b: (
    /* ase */
    134217728
  ),
  /* Shifts.layer */
  /**
  * 3. `components` (public, used by `style()`) — is for class-based styles that you want to be able to override with utilities.
  */
  c: (
    /* omponents */
    268435456
  ),
  /* Shifts.layer */
  // reserved for style():
  // - props: 0b011
  // - when: 0b100
  /**
  * 6. `aliases` (public, used by `apply()`) — `~(...)`
  */
  a: (
    /* liases */
    671088640
  ),
  /* Shifts.layer */
  /**
  * 6. `utilities` (public) — for small, single-purpose classes
  */
  u: (
    /* tilities */
    805306368
  ),
  /* Shifts.layer */
  /**
  * 7. `overrides` (public, used by `css()`)
  */
  o: (
    /* verrides */
    939524096
  )
};
function seperatorPrecedence(string) {
  var _a;
  return ((_a = string.match(/[-=:;]/g)) == null ? void 0 : _a.length) || 0;
}
function atRulePrecedence(css2) {
  return Math.min(/(?:^|width[^\d]+)(\d+(?:.\d+)?)(p)?/.test(css2) ? Math.max(0, 29.63 * (+RegExp.$1 / (RegExp.$2 ? 15 : 1)) ** 0.137 - 43) : 0, 15) << 22 | /* Shifts.responsive */
  Math.min(seperatorPrecedence(css2), 15) << 18;
}
var PRECEDENCES_BY_PSEUDO_CLASS = [
  /* fi */
  "rst-c",
  /* hild: 0 */
  /* la */
  "st-ch",
  /* ild: 1 */
  // even and odd use: nth-child
  /* nt */
  "h-chi",
  /* ld: 2 */
  /* an */
  "y-lin",
  /* k: 3 */
  /* li */
  "nk",
  /* : 4 */
  /* vi */
  "sited",
  /* : 5 */
  /* ch */
  "ecked",
  /* : 6 */
  /* em */
  "pty",
  /* : 7 */
  /* re */
  "ad-on",
  /* ly: 8 */
  /* fo */
  "cus-w",
  /* ithin : 9 */
  /* ho */
  "ver",
  /* : 10 */
  /* fo */
  "cus",
  /* : 11 */
  /* fo */
  "cus-v",
  /* isible : 12 */
  /* ac */
  "tive",
  /* : 13 */
  /* di */
  "sable",
  /* d : 14 */
  /* op */
  "tiona",
  /* l: 15 */
  /* re */
  "quire"
];
function convert({ n: name, i: important, v: variants = [] }, context, precedence, conditions) {
  name && (name = toClassName({
    n: name,
    i: important,
    v: variants
  }));
  conditions = [
    ...asArray(conditions)
  ];
  for (let variant of variants) {
    let screen = context.theme("screens", variant);
    for (let condition of asArray(screen && mql(screen) || context.v(variant))) {
      var selector;
      conditions.push(condition);
      precedence |= screen ? 67108864 | /* Shifts.screens */
      atRulePrecedence(condition) : "dark" == variant ? 1073741824 : (
        /* Shifts.darkMode */
        "@" == condition[0] ? atRulePrecedence(condition) : (selector = condition, // use first found pseudo-class
        1 << ~(/:([a-z-]+)/.test(selector) && ~PRECEDENCES_BY_PSEUDO_CLASS.indexOf(RegExp.$1.slice(2, 7)) || -18))
      );
    }
  }
  return {
    n: name,
    p: precedence,
    r: conditions,
    i: important
  };
}
var registry = /* @__PURE__ */ new Map();
function stringify$1(rule) {
  if (rule.d) {
    let groups = [], selector = replaceEach(
      // merge all conditions into a selector string
      rule.r.reduce((selector2, condition) => {
        return "@" == condition[0] ? (groups.push(condition), selector2) : (
          // Go over the selector and replace the matching multiple selectors if any
          condition ? replaceEach(selector2, (selectorPart) => replaceEach(
            condition,
            // If the current condition has a nested selector replace it
            (conditionPart) => {
              let mergeMatch = /(:merge\(.+?\))(:[a-z-]+|\\[.+])/.exec(conditionPart);
              if (mergeMatch) {
                let selectorIndex = selectorPart.indexOf(mergeMatch[1]);
                return ~selectorIndex ? (
                  // [':merge(.group):hover .rule', ':merge(.group):focus &'] -> ':merge(.group):focus:hover .rule'
                  // ':merge(.group)' + ':focus' + ':hover .rule'
                  selectorPart.slice(0, selectorIndex) + mergeMatch[0] + selectorPart.slice(selectorIndex + mergeMatch[1].length)
                ) : (
                  // [':merge(.peer):focus~&', ':merge(.group):hover &'] -> ':merge(.peer):focus~:merge(.group):hover &'
                  replaceReference(selectorPart, conditionPart)
                );
              }
              return replaceReference(conditionPart, selectorPart);
            }
          )) : selector2
        );
      }, "&"),
      // replace '&' with rule name or an empty string
      (selectorPart) => replaceReference(selectorPart, rule.n ? "." + escape(rule.n) : "")
    );
    return selector && groups.push(selector.replace(/:merge\((.+?)\)/g, "$1")), groups.reduceRight((body, grouping) => grouping + "{" + body + "}", rule.d);
  }
}
function replaceEach(selector, iteratee) {
  return selector.replace(/ *((?:\(.+?\)|\[.+?\]|[^,])+) *(,|$)/g, (_, selectorPart, comma) => iteratee(selectorPart) + comma);
}
function replaceReference(selector, reference) {
  return selector.replace(/&/g, reference);
}
var collator = new Intl.Collator("en", {
  numeric: true
});
function sortedInsertionIndex(array, element) {
  for (var low = 0, high = array.length; low < high; ) {
    let pivot = high + low >> 1;
    0 >= compareTwindRules(array[pivot], element) ? low = pivot + 1 : high = pivot;
  }
  return high;
}
function compareTwindRules(a, b) {
  let layer = a.p & Layer.o;
  return layer == (b.p & Layer.o) && (layer == Layer.b || layer == Layer.o) ? 0 : a.p - b.p || a.o - b.o || collator.compare(byModifier(a.n), byModifier(b.n)) || collator.compare(byName(a.n), byName(b.n));
}
function byModifier(s) {
  return (s || "").split(/:/).pop().split("/").pop() || "\0";
}
function byName(s) {
  return (s || "").replace(/\W/g, (c) => String.fromCharCode(127 + c.charCodeAt(0))) + "\0";
}
function parseColorComponent(chars, factor) {
  return Math.round(parseInt(chars, 16) * factor);
}
function toColorValue(color, options = {}) {
  if ("function" == typeof color) return color(options);
  let { opacityValue = "1", opacityVariable } = options, opacity = opacityVariable ? `var(${opacityVariable})` : opacityValue;
  if (color.includes("<alpha-value>")) return color.replace("<alpha-value>", opacity);
  if ("#" == color[0] && (4 == color.length || 7 == color.length)) {
    let size = (color.length - 1) / 3, factor = [
      17,
      1,
      0.062272
    ][size - 1];
    return `rgba(${[
      parseColorComponent(color.substr(1, size), factor),
      parseColorComponent(color.substr(1 + size, size), factor),
      parseColorComponent(color.substr(1 + 2 * size, size), factor),
      opacity
    ]})`;
  }
  return "1" == opacity ? color : "0" == opacity ? "#0000" : (
    // convert rgb and hsl to alpha variant
    color.replace(/^(rgb|hsl)(\([^)]+)\)$/, `$1a$2,${opacity})`)
  );
}
function autoDarkColor(section, key, { theme }) {
  return theme(
    section,
    // 50 -> 900, 100 -> 800, ..., 800 -> 100, 900 -> 50
    // key: gray-50, gray.50
    key = key.replace(/\d+$/, (shade) => (
      // ~~(parseInt(shade, 10) / 100): 50 -> 0, 900 -> 9
      100 * // (9 - 0) -> 900, (9 - 9) -> 50
      (9 - ~~(parseInt(shade, 10) / 100) || 0.5)
    ))
  );
}
function serialize(style2, rule, context, precedence, conditions = []) {
  return function serialize$(style3, { n: name, p: precedence2, r: conditions2 = [], i: important }, context2) {
    let rules = [], declarations = "", maxPropertyPrecedence = 0, numberOfDeclarations = 0;
    for (let key in style3 || {}) {
      var layer, property;
      let value = style3[key];
      if ("@" == key[0]) {
        if (!value) continue;
        if ("a" == key[1]) {
          rules.push(...translateWith(name, precedence2, parse("" + value), context2, precedence2, conditions2, important, true));
          continue;
        }
        if ("l" == key[1]) {
          for (let css2 of asArray(value)) rules.push(...serialize$(css2, {
            n: name,
            p: (layer = Layer[key[7]], // Set layer (first reset, than set)
            precedence2 & ~Layer.o | layer),
            r: "d" == key[7] ? [] : conditions2,
            i: important
          }, context2));
          continue;
        }
        if ("i" == key[1]) {
          rules.push(...asArray(value).map((value2) => ({
            // before all layers
            p: -1,
            o: 0,
            r: [],
            d: key + " " + value2
          })));
          continue;
        }
        if ("k" == key[1]) {
          rules.push({
            p: Layer.d,
            o: 0,
            r: [
              key
            ],
            d: serialize$(value, {
              p: Layer.d
            }, context2).map(stringify$1).join("")
          });
          continue;
        }
        if ("f" == key[1]) {
          rules.push(...asArray(value).map((value2) => ({
            p: Layer.d,
            o: 0,
            r: [
              key
            ],
            d: serialize$(value2, {
              p: Layer.d
            }, context2).map(stringify$1).join("")
          })));
          continue;
        }
      }
      if ("object" != typeof value || Array.isArray(value)) {
        if ("label" == key && value) name = value + hash(JSON.stringify([
          precedence2,
          important,
          style3
        ]));
        else if (value || 0 === value) {
          key = key.replace(/[A-Z]/g, (_) => "-" + _.toLowerCase());
          numberOfDeclarations += 1;
          maxPropertyPrecedence = Math.max(maxPropertyPrecedence, "-" == (property = key)[0] ? 0 : seperatorPrecedence(property) + (/^(?:(border-(?!w|c|sty)|[tlbr].{2,4}m?$|c.{7,8}$)|([fl].{5}l|g.{8}$|pl))/.test(property) ? +!!RegExp.$1 || /* +1 */
          -!!RegExp.$2 : (
            /* -1 */
            0
          )) + 1);
          declarations += (declarations ? ";" : "") + asArray(value).map((value2) => context2.s(
            key,
            // support theme(...) function in values
            // calc(100vh - theme('spacing.12'))
            resolveThemeFunction("" + value2, context2.theme) + (important ? " !important" : "")
          )).join(";");
        }
      } else if ("@" == key[0] || key.includes("&")) {
        let rulePrecedence = precedence2;
        if ("@" == key[0]) {
          key = key.replace(/\bscreen\(([^)]+)\)/g, (_, screenKey) => {
            let screen = context2.theme("screens", screenKey);
            return screen ? (rulePrecedence |= 67108864, /* Shifts.screens */
            mql(screen, "")) : _;
          });
          rulePrecedence |= atRulePrecedence(key);
        }
        rules.push(...serialize$(value, {
          n: name,
          p: rulePrecedence,
          r: [
            ...conditions2,
            key
          ],
          i: important
        }, context2));
      } else
        rules.push(...serialize$(value, {
          p: precedence2,
          r: [
            ...conditions2,
            key
          ]
        }, context2));
    }
    return (
      // PERF: prevent unshift using `rules = [{}]` above and then `rules[0] = {...}`
      rules.unshift({
        n: name,
        p: precedence2,
        o: (
          // number of declarations (descending)
          Math.max(0, 15 - numberOfDeclarations) + // greatest precedence of properties
          // if there is no property precedence this is most likely a custom property only declaration
          // these have the highest precedence
          1.5 * Math.min(maxPropertyPrecedence || 15, 15)
        ),
        r: conditions2,
        // stringified declarations
        d: declarations
      }), rules.sort(compareTwindRules)
    );
  }(style2, convert(rule, context, precedence, conditions), context);
}
function resolveThemeFunction(value, theme) {
  return value.replace(/theme\((["'`])?(.+?)\1(?:\s*,\s*(["'`])?(.+?)\3)?\)/g, (_, __, key, ___, defaultValue = "") => {
    let value2 = theme(key, defaultValue);
    return "function" == typeof value2 && /color|fill|stroke/i.test(key) ? toColorValue(value2) : "" + asArray(value2).filter((v) => Object(v) !== v);
  });
}
function merge(rules, name) {
  let current;
  let result = [];
  for (let rule of rules)
    if (rule.d && rule.n) {
      if ((current == null ? void 0 : current.p) == rule.p && "" + current.r == "" + rule.r) {
        current.c = [
          current.c,
          rule.c
        ].filter(Boolean).join(" ");
        current.d = current.d + ";" + rule.d;
      } else
        result.push(current = {
          ...rule,
          n: rule.n && name
        });
    } else result.push({
      ...rule,
      n: rule.n && name
    });
  return result;
}
function translate(rules, context, precedence = Layer.u, conditions, important) {
  let result = [];
  for (let rule of rules) for (let cssRule of function(rule2, context2, precedence2, conditions2, important2) {
    rule2 = {
      ...rule2,
      i: rule2.i || important2
    };
    let resolved = function(rule3, context3) {
      let factory = registry.get(rule3.n);
      return factory ? factory(rule3, context3) : context3.r(rule3.n, "dark" == rule3.v[0]);
    }(rule2, context2);
    return resolved ? (
      // a list of class names
      "string" == typeof resolved ? ({ r: conditions2, p: precedence2 } = convert(rule2, context2, precedence2, conditions2), merge(translate(parse(resolved), context2, precedence2, conditions2, rule2.i), rule2.n)) : Array.isArray(resolved) ? resolved.map((rule3) => {
        var precedence1, layer;
        return {
          o: 0,
          ...rule3,
          r: [
            ...asArray(conditions2),
            ...asArray(rule3.r)
          ],
          p: (precedence1 = precedence2, layer = rule3.p ?? precedence2, precedence1 & ~Layer.o | layer)
        };
      }) : serialize(resolved, rule2, context2, precedence2, conditions2)
    ) : (
      // propagate className as is
      [
        {
          c: toClassName(rule2),
          p: 0,
          o: 0,
          r: []
        }
      ]
    );
  }(rule, context, precedence, conditions, important)) result.splice(sortedInsertionIndex(result, cssRule), 0, cssRule);
  return result;
}
function translateWith(name, layer, rules, context, precedence, conditions, important, useOrderOfRules) {
  return merge((useOrderOfRules ? rules.flatMap((rule) => translate([
    rule
  ], context, precedence, conditions, important)) : translate(rules, context, precedence, conditions, important)).map((rule) => {
    return (
      // do not move defaults
      // move only rules with a name unless they are in the base layer
      rule.p & Layer.o && (rule.n || layer == Layer.b) ? {
        ...rule,
        p: rule.p & ~Layer.o | layer,
        o: 0
      } : rule
    );
  }), name);
}
function define(className, layer, rules, useOrderOfRules) {
  var factory;
  return factory = (rule, context) => {
    let { n: name, p: precedence, r: conditions, i: important } = convert(rule, context, layer);
    return rules && translateWith(name, layer, rules, context, precedence, conditions, important, useOrderOfRules);
  }, registry.set(className, factory), className;
}
function createRule(active2, current, loc) {
  if ("(" != active2[active2.length - 1]) {
    let variants = [], important = false, negated = false, name = "";
    for (let value of active2) if (!("(" == value || /[~@]$/.test(value))) {
      if ("!" == value[0]) {
        value = value.slice(1);
        important = !important;
      }
      if (value.endsWith(":")) {
        variants["dark:" == value ? "unshift" : "push"](value.slice(0, -1));
        continue;
      }
      if ("-" == value[0]) {
        value = value.slice(1);
        negated = !negated;
      }
      value.endsWith("-") && (value = value.slice(0, -1));
      value && "&" != value && (name += (name && "-") + value);
    }
    if (name) {
      negated && (name = "-" + name);
      current[0].push(Object.defineProperties({
        n: name,
        v: variants.filter(uniq),
        i: important
      }, {
        a: {
          value: [
            ...active2
          ]
        },
        l: {
          value: loc
        }
      }));
    }
  }
}
function uniq(value, index, values) {
  return values.indexOf(value) == index;
}
var cache = /* @__PURE__ */ new Map();
function parse(token) {
  let parsed = cache.get(token);
  if (!parsed) {
    let active2 = [], current = [
      []
    ], startIndex = 0, skip = 0, comment = null, position = 0, commit = (isRule, endOffset = 0) => {
      if (startIndex != position) {
        active2.push(token.slice(startIndex, position + endOffset));
        isRule && createRule(active2, current, [
          startIndex,
          position + endOffset
        ]);
      }
      startIndex = position + 1;
    };
    for (; position < token.length; position++) {
      let char = token[position];
      if (skip) "\\" != token[position - 1] && (skip += +("[" == char) || -("]" == char));
      else if ("[" == char)
        skip += 1;
      else if (comment) {
        if ("\\" != token[position - 1] && comment.test(token.slice(position))) {
          comment = null;
          startIndex = position + RegExp.lastMatch.length;
        }
      } else if ("/" == char && "\\" != token[position - 1] && ("*" == token[position + 1] || "/" == token[position + 1]))
        comment = "*" == token[position + 1] ? /^\*\// : /^[\r\n]/;
      else if ("(" == char) {
        commit();
        active2.push(char);
      } else if (":" == char) ":" != token[position + 1] && commit(false, 1);
      else if (/[\s,)]/.test(char)) {
        commit(true);
        let lastGroup = active2.lastIndexOf("(");
        if (")" == char) {
          let nested = active2[lastGroup - 1];
          if (/[~@]$/.test(nested)) {
            let rules = current.shift();
            active2.length = lastGroup;
            createRule([
              ...active2,
              "#"
            ], current, [
              startIndex,
              position
            ]);
            let { v } = current[0].pop();
            for (let rule of rules)
              rule.v.splice(+("dark" == rule.v[0]) - +("dark" == v[0]), v.length);
            createRule([
              ...active2,
              define(
                // named nested
                nested.length > 1 ? nested.slice(0, -1) + hash(JSON.stringify([
                  nested,
                  rules
                ])) : nested + "(" + format(rules) + ")",
                Layer.a,
                rules,
                /@$/.test(nested)
              )
            ], current, [
              startIndex,
              position
            ]);
          }
          lastGroup = active2.lastIndexOf("(", lastGroup - 1);
        }
        active2.length = lastGroup + 1;
      } else /[~@]/.test(char) && "(" == token[position + 1] && // start nested block
      // ~(...) or button~(...)
      // @(...) or button@(...)
      current.unshift([]);
    }
    commit(true);
    cache.set(token, parsed = current[0]);
  }
  return parsed;
}
function interleave(strings, interpolations, handle) {
  return interpolations.reduce((result, interpolation, index) => result + handle(interpolation) + strings[index + 1], strings[0]);
}
function interpolate(strings, interpolations) {
  return Array.isArray(strings) && Array.isArray(strings.raw) ? interleave(strings, interpolations, (value) => toString(value).trim()) : interpolations.filter(Boolean).reduce((result, value) => result + toString(value), strings ? toString(strings) : "");
}
function toString(value) {
  let tmp, result = "";
  if (value && "object" == typeof value) {
    if (Array.isArray(value)) (tmp = interpolate(value[0], value.slice(1))) && (result += " " + tmp);
    else for (let key in value) value[key] && (result += " " + key);
  } else null != value && "boolean" != typeof value && (result += " " + value);
  return result;
}
var apply = alias("@");
var shortcut = alias("~");
function alias(marker) {
  return new Proxy(function alias2(strings, ...interpolations) {
    return alias$("", strings, interpolations);
  }, {
    get(target, name) {
      return name in target ? target[name] : function namedAlias(strings, ...interpolations) {
        return alias$(name, strings, interpolations);
      };
    }
  });
  function alias$(name, strings, interpolations) {
    return format(parse(name + marker + "(" + interpolate(strings, interpolations) + ")"));
  }
}
function astish(strings, interpolations) {
  return Array.isArray(strings) ? astish$(interleave(strings, interpolations, (interpolation) => null != interpolation && "boolean" != typeof interpolation ? interpolation : "")) : "string" == typeof strings ? astish$(strings) : [
    strings
  ];
}
var newRule = / *(?:(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}))/g;
function astish$(css2) {
  let block;
  css2 = // Remove comments (multiline and single line)
  css2.replace(/\/\*[^]*?\*\/|\s\s+|\n/gm, " ");
  let tree = [
    {}
  ], rules = [
    tree[0]
  ], conditions = [];
  for (; block = newRule.exec(css2); ) {
    if (block[4]) {
      tree.shift();
      conditions.shift();
    }
    if (block[3]) {
      conditions.unshift(block[3]);
      tree.unshift({});
      rules.push(conditions.reduce((body, condition) => ({
        [condition]: body
      }), tree[0]));
    } else if (!block[4]) {
      if (tree[0][block[1]]) {
        tree.unshift({});
        rules.push(conditions.reduce((body, condition) => ({
          [condition]: body
        }), tree[0]));
      }
      tree[0][block[1]] = block[2];
    }
  }
  return rules;
}
function css(strings, ...interpolations) {
  var _a;
  var factory;
  let ast = astish(strings, interpolations), className = (((_a = ast.find((o) => o.label)) == null ? void 0 : _a.label) || "css") + hash(JSON.stringify(ast));
  return factory = (rule, context) => merge(ast.flatMap((css2) => serialize(css2, rule, context, Layer.o)), className), registry.set(className, factory), className;
}
var animation = new Proxy(function animation2(animation2, waypoints) {
  return animation$("animation", animation2, waypoints);
}, {
  get(target, name) {
    return name in target ? target[name] : function namedAnimation(animation3, waypoints) {
      return animation$(name, animation3, waypoints);
    };
  }
});
function animation$(label, animation3, waypoints) {
  return {
    toString() {
      return css({
        label,
        "@layer components": {
          ..."object" == typeof animation3 ? animation3 : {
            animation: animation3
          },
          animationName: "" + waypoints
        }
      });
    }
  };
}
function match(pattern, resolve, convert2) {
  return [
    pattern,
    fromMatch(resolve, convert2)
  ];
}
function fromMatch(resolve, convert2) {
  return "function" == typeof resolve ? resolve : "string" == typeof resolve && /^[\w-]+$/.test(resolve) ? (
    // a CSS property alias
    (match2, context) => ({
      [resolve]: convert2 ? convert2(match2, context) : maybeNegate(match2, 1)
    })
  ) : (match2) => (
    // CSSObject, shortcut or apply
    resolve || {
      [match2[1]]: maybeNegate(match2, 2)
    }
  );
}
function maybeNegate(match2, offset, value = match2.slice(offset).find(Boolean) || match2.$$ || match2.input) {
  return "-" == match2.input[0] ? `calc(${value} * -1)` : value;
}
function matchTheme(pattern, section, resolve, convert2) {
  return [
    pattern,
    fromTheme(section, resolve, convert2)
  ];
}
function fromTheme(section, resolve, convert2) {
  let factory = "string" == typeof resolve ? (match2, context) => ({
    [resolve]: convert2 ? convert2(match2, context) : match2._
  }) : resolve || (({ 1: $1, _ }, context, section2) => ({
    [$1 || section2]: _
  }));
  return (
    /** The found theme value */
    // indirection wrapper to remove autocomplete functions from production bundles
    withAutocomplete((match2, context) => {
      let themeSection = camelize(section || match2[1]), value = context.theme(themeSection, match2.$$) ?? arbitrary(match2.$$, themeSection, context);
      if (null != value) return match2._ = maybeNegate(match2, 0, value), factory(match2, context, themeSection);
    }, (match2, context) => {
      let themeSection = camelize(section || match2[1]), isKeyLookup = match2.input.endsWith("-");
      if (isKeyLookup) return Object.entries(context.theme(themeSection) || {}).filter(([key, value2]) => key && "DEFAULT" != key && (!/color|fill|stroke/i.test(themeSection) || [
        "string",
        "function"
      ].includes(typeof value2))).map(([key, value2]) => ({
        suffix: key.replace(/-DEFAULT/g, ""),
        theme: {
          section: themeSection,
          key
        },
        color: /color|fill|stroke/i.test(themeSection) && toColorValue(value2, {
          opacityValue: "1"
        })
      })).concat([
        {
          suffix: "["
        }
      ]);
      let value = context.theme(themeSection, "DEFAULT");
      return value ? [
        {
          suffix: "",
          theme: {
            section: themeSection,
            key: "DEFAULT"
          },
          color: /color|fill|stroke/i.test(themeSection) && toColorValue(value, {
            opacityValue: "1"
          })
        }
      ] : [];
    })
  );
}
function matchColor(pattern, options = {}, resolve) {
  return [
    pattern,
    colorFromTheme(options, resolve)
  ];
}
function colorFromTheme(options = {}, resolve) {
  return withAutocomplete((match2, context) => {
    let { section = camelize(match2[0]).replace("-", "") + "Color" } = options, [colorMatch, opacityMatch] = parseValue(match2.$$);
    if (!colorMatch) return;
    let colorValue = context.theme(section, colorMatch) || arbitrary(colorMatch, section, context);
    if (!colorValue || "object" == typeof colorValue) return;
    let {
      // text- -> --tw-text-opacity
      // ring-offset(?:-|$) -> --tw-ring-offset-opacity
      // TODO move this default into preset-tailwind?
      opacityVariable = `--tw-${match2[0].replace(/-$/, "")}-opacity`,
      opacitySection = section.replace("Color", "Opacity"),
      property = section,
      selector
    } = options, opacityValue = context.theme(opacitySection, opacityMatch || "DEFAULT") || opacityMatch && arbitrary(opacityMatch, opacitySection, context), create = resolve || (({ _ }) => {
      let properties2 = toCSS(property, _);
      return selector ? {
        [selector]: properties2
      } : properties2;
    });
    match2._ = {
      value: toColorValue(colorValue, {
        opacityVariable: opacityVariable || void 0,
        opacityValue: opacityValue || void 0
      }),
      color: (options2) => toColorValue(colorValue, options2),
      opacityVariable: opacityVariable || void 0,
      opacityValue: opacityValue || void 0
    };
    let properties = create(match2, context);
    if (!match2.dark) {
      let darkColorValue = context.d(section, colorMatch, colorValue);
      if (darkColorValue && darkColorValue !== colorValue) {
        match2._ = {
          value: toColorValue(darkColorValue, {
            opacityVariable: opacityVariable || void 0,
            opacityValue: opacityValue || "1"
          }),
          color: (options2) => toColorValue(darkColorValue, options2),
          opacityVariable: opacityVariable || void 0,
          opacityValue: opacityValue || void 0
        };
        properties = {
          "&": properties,
          [context.v("dark")]: create(match2, context)
        };
      }
    }
    return properties;
  }, (match2, context) => {
    let { section = camelize(match2[0]).replace("-", "") + "Color", opacitySection = section.replace("Color", "Opacity") } = options, isKeyLookup = match2.input.endsWith("-"), opacities = Object.entries(context.theme(opacitySection) || {}).filter(([key, value2]) => "DEFAULT" != key && /^[\w-]+$/.test(key) && "string" == typeof value2);
    if (isKeyLookup)
      return Object.entries(context.theme(section) || {}).filter(([key, value2]) => key && "DEFAULT" != key && [
        "string",
        "function"
      ].includes(typeof value2)).map(([key, value2]) => ({
        suffix: key.replace(/-DEFAULT/g, ""),
        theme: {
          section,
          key
        },
        color: toColorValue(value2, {
          opacityValue: context.theme(opacitySection, "DEFAULT") || "1"
        }),
        modifiers: ("function" == typeof value2 || "string" == typeof value2 && (value2.includes("<alpha-value>") || "#" == value2[0] && (4 == value2.length || 7 == value2.length))) && opacities.map(([key2, opacityValue]) => ({
          modifier: key2,
          theme: {
            section: opacitySection,
            key: key2
          },
          color: toColorValue(value2, {
            opacityValue
          })
        })).concat([
          {
            modifier: "[",
            color: toColorValue(value2, {
              opacityValue: "1"
            })
          }
        ])
      })).concat([
        {
          suffix: "["
        }
      ]);
    let value = context.theme(section, "DEFAULT");
    return value ? [
      {
        suffix: "",
        theme: {
          section,
          key: "DEFAULT"
        },
        color: toColorValue(value, {
          opacityValue: context.theme(opacitySection, "DEFAULT") || "1"
        }),
        modifiers: ("function" == typeof value || "string" == typeof value && (value.includes("<alpha-value>") || "#" == value[0] && (4 == value.length || 7 == value.length))) && opacities.map(([key, opacityValue]) => ({
          modifier: key,
          theme: {
            section: opacitySection,
            key
          },
          color: toColorValue(value, {
            opacityValue
          })
        })).concat([
          {
            modifier: "[",
            color: toColorValue(value, {
              opacityValue: "1"
            })
          }
        ])
      }
    ] : [];
  });
}
function parseValue(input) {
  return (input.match(/^(\[[^\]]+]|[^/]+?)(?:\/(.+))?$/) || []).slice(1);
}
function toCSS(property, value) {
  let properties = {};
  if ("string" == typeof value) properties[property] = value;
  else {
    value.opacityVariable && value.value.includes(value.opacityVariable) && (properties[value.opacityVariable] = value.opacityValue || "1");
    properties[property] = value.value;
  }
  return properties;
}
function arbitrary(value, section, context) {
  if ("[" == value[0] && "]" == value.slice(-1)) {
    value = normalize(resolveThemeFunction(value.slice(1, -1), context.theme));
    if (!section) return value;
    if (
      // Respect type hints from the user on ambiguous arbitrary values - https://tailwindcss.com/docs/adding-custom-styles#resolving-ambiguities
      !// If this is a color section and the value is a hex color, color function or color name
      (/color|fill|stroke/i.test(section) && !(/^color:/.test(value) || /^(#|((hsl|rgb)a?|hwb|lab|lch|color)\(|[a-z]+$)/.test(value)) || // url(, [a-z]-gradient(, image(, cross-fade(, image-set(
      /image/i.test(section) && !(/^image:/.test(value) || /^[a-z-]+\(/.test(value)) || // font-*
      // - fontWeight (type: ['lookup', 'number', 'any'])
      // - fontFamily (type: ['lookup', 'generic-name', 'family-name'])
      /weight/i.test(section) && !(/^(number|any):/.test(value) || /^\d+$/.test(value)) || // bg-*
      // - backgroundPosition (type: ['lookup', ['position', { preferOnConflict: true }]])
      // - backgroundSize (type: ['lookup', 'length', 'percentage', 'size'])
      /position/i.test(section) && /^(length|size):/.test(value))
    )
      return value.replace(/^[a-z-]+:/, "");
  }
}
function camelize(value) {
  return value.replace(/-./g, (x) => x[1].toUpperCase());
}
function normalize(value) {
  return (
    // Keep raw strings if it starts with `url(`
    value.includes("url(") ? value.replace(/(.*?)(url\(.*?\))(.*?)/g, (_, before = "", url, after = "") => normalize(before) + url + normalize(after)) : value.replace(/(^|[^\\])_+/g, (fullMatch, characterBefore) => characterBefore + " ".repeat(fullMatch.length - characterBefore.length)).replace(/\\_/g, "_").replace(/(calc|min|max|clamp)\(.+\)/g, (match2) => match2.replace(/(-?\d*\.?\d(?!\b-.+[,)](?![^+\-/*])\D)(?:%|[a-z]+)?|\))([+\-/*])/g, "$1 $2 "))
  );
}
var kAutocomplete = Symbol("@twind/autocomplete");
function withAutocomplete(rule, autocomplete) {
  if (autocomplete) {
    if ("function" == typeof rule) return Object.defineProperty(rule, kAutocomplete, {
      value: autocomplete,
      configurable: true
    });
    let [pattern, resolve, convert2] = asArray(rule);
    return [
      pattern,
      Object.defineProperty(fromMatch(resolve, convert2), kAutocomplete, {
        value: autocomplete,
        configurable: true
      })
    ];
  }
  return rule;
}
function getAutocompleteProvider(resolver) {
  return resolver[kAutocomplete];
}
function cx(strings, ...interpolations) {
  return format(parse(interpolate(strings, interpolations)), " ");
}
function defineConfig({ presets = [], ...userConfig }) {
  let config = {
    darkMode: void 0,
    darkColor: void 0,
    preflight: false !== userConfig.preflight && [],
    theme: {},
    variants: asArray(userConfig.variants),
    rules: asArray(userConfig.rules),
    ignorelist: asArray(userConfig.ignorelist),
    hash: void 0,
    stringify: (property, value) => property + ":" + value,
    finalize: []
  };
  for (let preset of asArray([
    ...presets,
    {
      darkMode: userConfig.darkMode,
      darkColor: userConfig.darkColor,
      preflight: false !== userConfig.preflight && asArray(userConfig.preflight),
      theme: userConfig.theme,
      hash: userConfig.hash,
      stringify: userConfig.stringify,
      finalize: userConfig.finalize
    }
  ])) {
    let { preflight, darkMode = config.darkMode, darkColor = config.darkColor, theme, variants, rules, ignorelist, hash: hash2 = config.hash, stringify: stringify2 = config.stringify, finalize } = "function" == typeof preset ? preset(config) : preset;
    config = {
      // values defined by user or previous presets take precedence
      preflight: false !== config.preflight && false !== preflight && [
        ...config.preflight,
        ...asArray(preflight)
      ],
      darkMode,
      darkColor,
      theme: {
        ...config.theme,
        ...theme,
        extend: {
          ...config.theme.extend,
          ...theme == null ? void 0 : theme.extend
        }
      },
      variants: [
        ...config.variants,
        ...asArray(variants)
      ],
      rules: [
        ...config.rules,
        ...asArray(rules)
      ],
      ignorelist: [
        ...config.ignorelist,
        ...asArray(ignorelist)
      ],
      hash: hash2,
      stringify: stringify2,
      finalize: [
        ...config.finalize,
        ...asArray(finalize)
      ]
    };
  }
  return config;
}
function warn(message, code, detail) {
  if ("function" == typeof dispatchEvent && "function" == typeof CustomEvent) {
    let event = new CustomEvent("warning", {
      detail: {
        message,
        code,
        detail
      },
      cancelable: true
    });
    dispatchEvent(event);
    event.defaultPrevented || console.warn(`[${code}] ${message}`, {
      detail
    });
  } else "object" == typeof process && "function" == typeof process.emitWarning ? (
    // Node.JS
    process.emitWarning(message, {
      code,
      detail
    })
  ) : (
    // Fallback
    console.warn(`[${code}] ${message}`, {
      detail
    })
  );
}
function find(value, list, cache2, getResolver, context, isDark) {
  for (let item of list) {
    let resolver = cache2.get(item);
    resolver || cache2.set(item, resolver = getResolver(item));
    let resolved = resolver(value, context, isDark);
    if (resolved) return resolved;
  }
}
function getVariantResolver(variant) {
  var resolve;
  return createResolve(variant[0], "function" == typeof (resolve = variant[1]) ? resolve : () => resolve);
}
function getRuleResolver(rule) {
  var resolve, convert2;
  return Array.isArray(rule) ? createResolve(rule[0], fromMatch(rule[1], rule[2])) : createResolve(rule, fromMatch(resolve, convert2));
}
function createResolve(patterns, resolve) {
  return createRegExpExecutor(patterns, (value, condition, context, isDark) => {
    let match2 = condition.exec(value);
    if (match2) return (
      // MATCH.$_ = value
      match2.$$ = value.slice(match2[0].length), match2.dark = isDark, resolve(match2, context)
    );
  });
}
function createRegExpExecutor(patterns, run) {
  let conditions = asArray(patterns).map(toCondition);
  return (value, context, isDark) => {
    for (let condition of conditions) {
      let result = run(value, condition, context, isDark);
      if (result) return result;
    }
  };
}
function toCondition(value) {
  return "string" == typeof value ? RegExp("^" + value + (value.includes("$") || "-" == value.slice(-1) ? "" : "$")) : value;
}
function twind(userConfig, sheet) {
  let config = defineConfig(userConfig), context = function({ theme, darkMode, darkColor = noop, variants, rules, hash: hash$1, stringify: stringify2, ignorelist, finalize }) {
    let variantCache = /* @__PURE__ */ new Map(), variantResolvers = /* @__PURE__ */ new Map(), ruleCache = /* @__PURE__ */ new Map(), ruleResolvers = /* @__PURE__ */ new Map(), ignored = createRegExpExecutor(ignorelist, (value, condition) => condition.test(value)), reportedUnknownClasses = /* @__PURE__ */ new Set();
    variants.push([
      "dark",
      Array.isArray(darkMode) || "class" == darkMode ? `${asArray(darkMode)[1] || ".dark"} &` : "string" == typeof darkMode && "media" != darkMode ? darkMode : (
        // a custom selector
        "@media (prefers-color-scheme:dark)"
      )
    ]);
    let h = "function" == typeof hash$1 ? (value) => hash$1(value, hash) : hash$1 ? hash : identity;
    h !== identity && finalize.push((rule) => {
      var _a;
      return {
        ...rule,
        n: rule.n && h(rule.n),
        d: (_a = rule.d) == null ? void 0 : _a.replace(/--(tw(?:-[\w-]+)?)\b/g, (_, property) => "--" + h(property).replace("#", ""))
      };
    });
    let ctx = {
      theme: function({ extend = {}, ...base }) {
        let resolved = {}, resolveContext = {
          get colors() {
            return theme2("colors");
          },
          theme: theme2,
          // Stub implementation as negated values are automatically infered and do _not_ need to be in the theme
          negative() {
            return {};
          },
          breakpoints(screens) {
            let breakpoints = {};
            for (let key in screens) "string" == typeof screens[key] && (breakpoints["screen-" + key] = screens[key]);
            return breakpoints;
          }
        };
        return theme2;
        function theme2(sectionKey, key, defaultValue, opacityValue) {
          if (sectionKey) {
            ({ 1: sectionKey, 2: opacityValue } = // eslint-disable-next-line no-sparse-arrays
            /^(\S+?)(?:\s*\/\s*([^/]+))?$/.exec(sectionKey) || [
              ,
              sectionKey
            ]);
            if (/[.[]/.test(sectionKey)) {
              let path = [];
              sectionKey.replace(/\[([^\]]+)\]|([^.[]+)/g, (_, $1, $2 = $1) => path.push($2));
              sectionKey = path.shift();
              defaultValue = key;
              key = path.join("-");
            }
            let section = resolved[sectionKey] || // two-step deref to allow extend section to reference base section
            Object.assign(Object.assign(
              // Make sure to not get into recursive calls
              resolved[sectionKey] = {},
              deref(base, sectionKey)
            ), deref(extend, sectionKey));
            if (null == key) return section;
            key || (key = "DEFAULT");
            let value = section[key] ?? key.split("-").reduce((obj, prop) => obj == null ? void 0 : obj[prop], section) ?? defaultValue;
            return opacityValue ? toColorValue(value, {
              opacityValue: resolveThemeFunction(opacityValue, theme2)
            }) : value;
          }
          let result = {};
          for (let section1 of [
            ...Object.keys(base),
            ...Object.keys(extend)
          ]) result[section1] = theme2(section1);
          return result;
        }
        function deref(source, section) {
          let value = source[section];
          return ("function" == typeof value && (value = value(resolveContext)), value && /color|fill|stroke/i.test(section)) ? function flattenColorPalette(colors, path = []) {
            let flattend = {};
            for (let key in colors) {
              let value2 = colors[key], keyPath = [
                ...path,
                key
              ];
              flattend[keyPath.join("-")] = value2;
              if ("DEFAULT" == key) {
                keyPath = path;
                flattend[path.join("-")] = value2;
              }
              "object" == typeof value2 && Object.assign(flattend, flattenColorPalette(value2, keyPath));
            }
            return flattend;
          }(value) : value;
        }
      }(theme),
      e: escape,
      h,
      s(property, value) {
        return stringify2(property, value, ctx);
      },
      d(section, key, color) {
        return darkColor(section, key, ctx, color);
      },
      v(value) {
        return variantCache.has(value) || variantCache.set(value, find(value, variants, variantResolvers, getVariantResolver, ctx) || "&:" + value), variantCache.get(value);
      },
      r(className, isDark) {
        let key = JSON.stringify([
          className,
          isDark
        ]);
        if (!ruleCache.has(key)) {
          ruleCache.set(key, !ignored(className, ctx) && find(className, rules, ruleResolvers, getRuleResolver, ctx, isDark));
          {
            let rule = ruleCache.get(key);
            if (null == rule && !reportedUnknownClasses.has(className)) {
              reportedUnknownClasses.add(className);
              warn(`Unknown class ${JSON.stringify(className)} found.`, "TWIND_INVALID_CLASS", className);
            }
          }
        }
        return ruleCache.get(key);
      },
      f(rule) {
        return finalize.reduce((rule2, p) => p(rule2, ctx), rule);
      }
    };
    return ctx;
  }(config), cache2 = /* @__PURE__ */ new Map(), sortedPrecedences = [], insertedRules = /* @__PURE__ */ new Set();
  sheet.resume((className) => cache2.set(className, className), (cssText, rule) => {
    sheet.insert(cssText, sortedPrecedences.length, rule);
    sortedPrecedences.push(rule);
    insertedRules.add(cssText);
  });
  function insert(rule) {
    let finalRule = context.f(rule), cssText = stringify$1(finalRule);
    if (cssText && !insertedRules.has(cssText)) {
      insertedRules.add(cssText);
      let index = sortedInsertionIndex(sortedPrecedences, rule);
      sheet.insert(cssText, index, rule);
      sortedPrecedences.splice(index, 0, rule);
    }
    return finalRule.n;
  }
  return Object.defineProperties(function tw2(tokens) {
    if (!cache2.size) for (let preflight of asArray(config.preflight)) {
      "function" == typeof preflight && (preflight = preflight(context));
      preflight && ("string" == typeof preflight ? translateWith("", Layer.b, parse(preflight), context, Layer.b, [], false, true) : serialize(preflight, {}, context, Layer.b)).forEach(insert);
    }
    tokens = "" + tokens;
    let className = cache2.get(tokens);
    if (!className) {
      let classNames = /* @__PURE__ */ new Set();
      for (let rule of translate(parse(tokens), context)) classNames.add(rule.c).add(insert(rule));
      className = [
        ...classNames
      ].filter(Boolean).join(" ");
      cache2.set(tokens, className).set(className, className);
    }
    return className;
  }, Object.getOwnPropertyDescriptors({
    get target() {
      return sheet.target;
    },
    theme: context.theme,
    config,
    snapshot() {
      let restoreSheet = sheet.snapshot(), insertedRules$ = new Set(insertedRules), cache$ = new Map(cache2), sortedPrecedences$ = [
        ...sortedPrecedences
      ];
      return () => {
        restoreSheet();
        insertedRules = insertedRules$;
        cache2 = cache$;
        sortedPrecedences = sortedPrecedences$;
      };
    },
    clear() {
      sheet.clear();
      insertedRules = /* @__PURE__ */ new Set();
      cache2 = /* @__PURE__ */ new Map();
      sortedPrecedences = [];
    },
    destroy() {
      this.clear();
      sheet.destroy();
    }
  }));
}
function changed(a, b) {
  return a != b && "" + a.split(" ").sort() != "" + b.split(" ").sort();
}
function mo(tw2) {
  let observer = new MutationObserver(handleMutationRecords);
  return {
    observe(target) {
      observer.observe(target, {
        attributeFilter: [
          "class"
        ],
        subtree: true,
        childList: true
      });
      handleClassAttributeChange(target);
      handleMutationRecords([
        {
          target,
          type: ""
        }
      ]);
    },
    disconnect() {
      observer.disconnect();
    }
  };
  function handleMutationRecords(records) {
    for (let { type, target } of records) if ("a" == type[0])
      handleClassAttributeChange(target);
    else
      for (let el of target.querySelectorAll("[class]")) handleClassAttributeChange(el);
    observer.takeRecords();
  }
  function handleClassAttributeChange(target) {
    var _a;
    let className;
    let tokens = (_a = target.getAttribute) == null ? void 0 : _a.call(target, "class");
    tokens && changed(tokens, className = tw2(tokens)) && // Not using `target.className = ...` as that is read-only for SVGElements
    target.setAttribute("class", className);
  }
}
function observe(tw$1 = tw, target = "undefined" != typeof document && document.documentElement) {
  if (target) {
    let observer = mo(tw$1);
    observer.observe(target);
    let { destroy } = tw$1;
    tw$1.destroy = () => {
      observer.disconnect();
      destroy.call(tw$1);
    };
  }
  return tw$1;
}
function getStyleElement(selector) {
  let style2 = document.querySelector(selector || 'style[data-twind=""]');
  if (!style2 || "STYLE" != style2.tagName) {
    style2 = document.createElement("style");
    document.head.prepend(style2);
  }
  return style2.dataset.twind = "claimed", style2;
}
function cssom(element) {
  let target = (element == null ? void 0 : element.cssRules) ? element : (element && "string" != typeof element ? element : getStyleElement(element)).sheet;
  return {
    target,
    snapshot() {
      let rules = Array.from(target.cssRules, (rule) => rule.cssText);
      return () => {
        this.clear();
        rules.forEach(this.insert);
      };
    },
    clear() {
      for (let index = target.cssRules.length; index--; ) target.deleteRule(index);
    },
    destroy() {
      var _a;
      (_a = target.ownerNode) == null ? void 0 : _a.remove();
    },
    insert(cssText, index) {
      try {
        target.insertRule(cssText, index);
      } catch (error) {
        target.insertRule(":root{}", index);
        /:-[mwo]/.test(cssText) || warn(error.message, "TWIND_INVALID_CSS", cssText);
      }
    },
    resume: noop
  };
}
function dom(element) {
  let target = element && "string" != typeof element ? element : getStyleElement(element);
  return {
    target,
    snapshot() {
      let rules = Array.from(target.childNodes, (node) => node.textContent);
      return () => {
        this.clear();
        rules.forEach(this.insert);
      };
    },
    clear() {
      target.textContent = "";
    },
    destroy() {
      target.remove();
    },
    insert(cssText, index) {
      target.insertBefore(document.createTextNode(cssText), target.childNodes[index] || null);
    },
    resume: noop
  };
}
function virtual(includeResumeData) {
  let target = [];
  return {
    target,
    snapshot() {
      let rules = [
        ...target
      ];
      return () => {
        target.splice(0, target.length, ...rules);
      };
    },
    clear() {
      target.length = 0;
    },
    destroy() {
      this.clear();
    },
    insert(css2, index, rule) {
      target.splice(index, 0, includeResumeData ? `/*!${rule.p.toString(36)},${(2 * rule.o).toString(36)}${rule.n ? "," + rule.n : ""}*/${css2}` : css2);
    },
    resume: noop
  };
}
function getSheet(useDOMSheet, disableResume) {
  let sheet = "undefined" == typeof document ? virtual(!disableResume) : useDOMSheet ? dom() : cssom();
  return disableResume || (sheet.resume = resume), sheet;
}
function stringify(target) {
  return (
    // prefer the raw text content of a CSSStyleSheet as it may include the resume data
    (target.ownerNode || target).textContent || (target.cssRules ? Array.from(target.cssRules, (rule) => rule.cssText) : asArray(target)).join("")
  );
}
function resume(addClassName, insert) {
  let textContent = stringify(this.target), RE = /\/\*!([\da-z]+),([\da-z]+)(?:,(.+?))?\*\//g;
  if (RE.test(textContent)) {
    var match2;
    let lastMatch;
    RE.lastIndex = 0;
    this.clear();
    if ("undefined" != typeof document) for (let el of document.querySelectorAll("[class]")) addClassName(el.getAttribute("class"));
    for (; match2 = RE.exec(textContent), lastMatch && insert(
      // grep the cssText from the previous match end up to this match start
      textContent.slice(lastMatch.index + lastMatch[0].length, match2 == null ? void 0 : match2.index),
      {
        p: parseInt(lastMatch[1], 36),
        o: parseInt(lastMatch[2], 36) / 2,
        n: lastMatch[3]
      }
    ), lastMatch = match2; ) ;
  }
}
function auto(install2) {
  if ("undefined" != typeof document && document.currentScript) {
    let cancelAutoInstall = () => observer.disconnect(), observer = new MutationObserver((mutationsList) => {
      for (let { target } of mutationsList)
        if (target === document.body) {
          install2();
          return cancelAutoInstall();
        }
    });
    return observer.observe(document.documentElement, {
      childList: true,
      subtree: true
    }), cancelAutoInstall;
  }
  return noop;
}
function assertActive() {
  if (!active) throw Error("No active twind instance found. Make sure to call setup or install before accessing tw.");
}
var tw = new Proxy(
  // just exposing the active as tw should work with most bundlers
  // as ES module export can be re-assigned BUT some bundlers to not honor this
  // -> using a delegation proxy here
  noop,
  {
    apply(_target, _thisArg, args) {
      return assertActive(), active(args[0]);
    },
    get(target, property) {
      if (!active && property in target)
        return target[property];
      assertActive();
      let value = active[property];
      return "function" == typeof value ? function() {
        return assertActive(), // eslint-disable-next-line prefer-rest-params
        value.apply(active, arguments);
      } : value;
    }
  }
);
function setup(config = {}, sheet = getSheet, target) {
  return active == null ? void 0 : active.destroy(), active = observe(twind(config, "function" == typeof sheet ? sheet() : sheet), target);
}
var injectGlobal = function(strings, ...interpolations) {
  ("function" == typeof this ? this : tw)(css({
    "@layer base": astish(strings, interpolations)
  }));
};
function install(config, isProduction = false) {
  let config$ = defineConfig(config);
  return setup({
    ...config$,
    // in production use short hashed class names
    hash: config$.hash ?? isProduction
  }, () => getSheet(!isProduction));
}
var keyframes = function bind(thisArg) {
  return new Proxy(function keyframes2(strings, ...interpolations) {
    return keyframes$(thisArg, "", strings, interpolations);
  }, {
    get(target, name) {
      return "bind" === name ? bind : name in target ? target[name] : function namedKeyframes(strings, ...interpolations) {
        return keyframes$(thisArg, name, strings, interpolations);
      };
    }
  });
}();
function keyframes$(thisArg, name, strings, interpolations) {
  return {
    toString() {
      let ast = astish(strings, interpolations), keyframeName = escape(name + hash(JSON.stringify([
        name,
        ast
      ])));
      return (
        // lazy access tw
        ("function" == typeof thisArg ? thisArg : tw)(css({
          [`@keyframes ${keyframeName}`]: astish(strings, interpolations)
        })), keyframeName
      );
    }
  };
}
function inline(markup, options = {}) {
  let { tw: tw$1 = tw, minify = identity } = "function" == typeof options ? {
    tw: options
  } : options, { html, css: css2 } = extract(markup, tw$1);
  return html.replace("</head>", `<style data-twind>${minify(css2, html)}</style></head>`);
}
function extract(html, tw$1 = tw) {
  let restore = tw$1.snapshot(), result = {
    html: consume(html, tw$1),
    css: stringify(tw$1.target)
  };
  return restore(), result;
}
function consume(markup, tw$1 = tw) {
  let result = "", lastChunkStart = 0;
  return !function(markup2, onClass) {
    let mode = 1, startIndex = 0, quote = "", attributeName = "", commit = (currentIndex) => {
      5 == mode && "class" == attributeName && false === onClass(startIndex, currentIndex, quote) && (markup2 = "");
    };
    for (let position = 0; position < markup2.length; position++) {
      let char = markup2[position];
      if (1 == mode) "<" == char && (mode = "!--" == markup2.substr(position + 1, 3) ? 4 : 3);
      else if (4 == mode) ">" == char && "--" == markup2.slice(position - 2, position) && (mode = 1);
      else if (quote) {
        if (char == quote && "\\" != markup2[position - 1]) {
          commit(position);
          mode = 2;
          quote = "";
        }
      } else if ('"' == char || "'" == char) {
        quote = char;
        startIndex += 1;
      } else if (">" == char) {
        commit(position);
        mode = 1;
      } else if (mode) {
        if ("=" == char) {
          attributeName = markup2.slice(startIndex, position);
          mode = 5;
          startIndex = position + 1;
        } else if ("/" == char && (mode < 5 || ">" == markup2[position + 1])) {
          commit(position);
          mode = // For now we are using a simple parser adapted from htm (https://github.com/developit/htm/blob/master/src/build.mjs)
          // If we find any issues we can switch to something more sophisticated like
          // - https://github.com/acrazing/html5parser
          // - https://github.com/fb55/htmlparser2
          0;
        } else if (/\s/.test(char)) {
          commit(position);
          mode = 2;
          startIndex = position + 1;
        }
      }
    }
  }(markup, (startIndex, endIndex, quote) => {
    var quote1;
    let value = markup.slice(startIndex, endIndex), className = tw$1(
      // const value = markup.slice(startIndex, endIndex)
      // Lets handle some special react cases:
      //   * arbitrary values for `content-`
      //     <span class="before:content-[&#x27;asas&#x27;]"></span>
      //     <span class="before:content-[&quot;asas&quot;]"></span>
      //
      //   * self-referenced groups
      //     <span class="flex(&amp; col)"></span>
      //
      //     If a class name contains `'`, `"`, or `&` those will be replaced with HTML entities
      //     To fix this we replace those for depending on the actual symbol that is being used
      //     As an alternative we could always escape class names direcly in twind like react does
      //     but this works for now
      ('"' == (quote1 = quote) ? (
        // `'` -> &#39; &apos; &#x27;
        value.replace(/(=|\[)(?:&#39;|&apos;|&#x27;)|(?:&#39;|&apos;|&#x27;)(])/g, "$1'$2")
      ) : "'" == quote1 ? (
        // `"` -> &#34; &quot; &#x22;
        value.replace(/(=|\[)(?:&#34;|&quot;|&#x22;)|(?:&#34;|&quot;|&#x22;)(])/g, '$1"$2')
      ) : value).replace(/(&#38;|&amp;|&#x26;)/g, "&")
    );
    if (changed(value, className)) {
      quote = quote ? "" : '"';
      result += markup.slice(lastChunkStart, startIndex) + quote + className + quote;
      lastChunkStart = endIndex;
    }
  }), // Combine the current result with the tail-end of the input
  result + markup.slice(lastChunkStart, markup.length);
}
var style = (base, config) => "function" == typeof base ? createStyle(config, base) : createStyle(base);
function createStyle(config = {}, parent) {
  let { label = "style", base, props: variants = {}, defaults: localDefaults, when = [] } = config, defaults = {
    ...parent == null ? void 0 : parent.defaults,
    ...localDefaults
  }, id = hash(JSON.stringify([
    label,
    parent == null ? void 0 : parent.className,
    base,
    variants,
    defaults,
    when
  ])), className = register("", base || "", Layer.c);
  function register(mq, token, layer) {
    return define(
      // `<name>#<id>` or `<parent>~<name>#<id>`
      ((parent ? parent.className.replace(/#.+$/, "~") : "") + label + mq + id).replace(/[: ,()[\]]/, ""),
      layer,
      token && parse(token)
    );
  }
  return Object.defineProperties(function style2(allProps) {
    let isWithinRuleDeclaration, token;
    if (Array.isArray(allProps)) {
      isWithinRuleDeclaration = true;
      allProps = Object.fromEntries(new URLSearchParams(allProps[1]).entries());
    }
    let props = {
      ...defaults,
      ...allProps
    }, classNames = isWithinRuleDeclaration ? "" : (parent ? parent(props) + " " : "") + className;
    for (let variantKey in variants) {
      let variant = variants[variantKey], propsValue = props[variantKey];
      if (propsValue === Object(propsValue)) {
        let mq = "";
        token = "";
        for (let breakpoint in propsValue) {
          let breakpointToken = variant[propsValue[breakpoint]];
          if (breakpointToken) {
            mq += "@" + breakpoint + "-" + propsValue[breakpoint];
            token += (token && " ") + ("_" == breakpoint ? breakpointToken : breakpoint + ":(" + breakpointToken + ")");
          }
        }
        token && (classNames += " " + register("--" + variantKey + "-" + mq, token, 402653184));
      } else (token = variant[propsValue]) && (classNames += " " + register("--" + variantKey + "-" + propsValue, token, 402653184));
    }
    return (
      /* Shifts.layer */
      when.forEach((match2, index) => {
        let mq = "";
        for (let variantKey in match2[0]) {
          let propsValue = props[variantKey];
          if (propsValue !== Object(propsValue) && "" + propsValue == "" + match2[0][variantKey]) mq += (mq && "_") + variantKey + "-" + propsValue;
          else {
            mq = "";
            break;
          }
        }
        mq && (token = match2[1]) && (classNames += " " + register("-" + index + "--" + mq, token, 536870912));
      }), /* Shifts.layer */
      classNames
    );
  }, Object.getOwnPropertyDescriptors({
    className,
    defaults,
    selector: "." + escape(className)
  }));
}
var tx = function(strings, ...interpolations) {
  return ("function" == typeof this ? this : tw)(interpolate(strings, interpolations));
};

export {
  escape,
  hash,
  mql,
  asArray,
  identity,
  noop,
  toColorValue,
  autoDarkColor,
  parse,
  apply,
  shortcut,
  css,
  animation,
  match,
  fromMatch,
  matchTheme,
  fromTheme,
  matchColor,
  colorFromTheme,
  parseValue,
  toCSS,
  arbitrary,
  normalize,
  withAutocomplete,
  getAutocompleteProvider,
  cx,
  defineConfig,
  twind,
  mo,
  observe,
  cssom,
  dom,
  virtual,
  getSheet,
  stringify,
  auto,
  tw,
  setup,
  injectGlobal,
  install,
  keyframes,
  inline,
  extract,
  consume,
  style,
  tx
};
//# sourceMappingURL=chunk-O5ZJBDAH.js.map
