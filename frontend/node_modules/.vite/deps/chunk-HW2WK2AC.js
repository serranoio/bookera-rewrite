import {
  require_buffer
} from "./chunk-JV5O2B6D.js";
import {
  __commonJS,
  __export,
  __publicField,
  __toESM
} from "./chunk-2TUXWMP5.js";

// node_modules/eventemitter3/index.js
var require_eventemitter3 = __commonJS({
  "node_modules/eventemitter3/index.js"(exports, module) {
    "use strict";
    var has = Object.prototype.hasOwnProperty;
    var prefix = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__) prefix = false;
    }
    function EE(fn, context, once) {
      this.fn = fn;
      this.context = context;
      this.once = once || false;
    }
    function addListener(emitter, event, fn, context, once) {
      if (typeof fn !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
      if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
      else emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0) emitter._events = new Events();
      else delete emitter._events[evt];
    }
    function EventEmitter2() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter2.prototype.eventNames = function eventNames() {
      var names = [], events, name;
      if (this._eventsCount === 0) return names;
      for (name in events = this._events) {
        if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
      }
      return names;
    };
    EventEmitter2.prototype.listeners = function listeners(event) {
      var evt = prefix ? prefix + event : event, handlers = this._events[evt];
      if (!handlers) return [];
      if (handlers.fn) return [handlers.fn];
      for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
        ee[i] = handlers[i].fn;
      }
      return ee;
    };
    EventEmitter2.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event, listeners = this._events[evt];
      if (!listeners) return 0;
      if (listeners.fn) return 1;
      return listeners.length;
    };
    EventEmitter2.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return false;
      var listeners = this._events[evt], len = arguments.length, args, i;
      if (listeners.fn) {
        if (listeners.once) this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a2), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for (i = 1, args = new Array(len - 1); i < len; i++) {
          args[i - 1] = arguments[i];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length = listeners.length, j;
        for (i = 0; i < length; i++) {
          if (listeners[i].once) this.removeListener(event, listeners[i].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i].fn.call(listeners[i].context);
              break;
            case 2:
              listeners[i].fn.call(listeners[i].context, a1);
              break;
            case 3:
              listeners[i].fn.call(listeners[i].context, a1, a2);
              break;
            case 4:
              listeners[i].fn.call(listeners[i].context, a1, a2, a3);
              break;
            default:
              if (!args) for (j = 1, args = new Array(len - 1); j < len; j++) {
                args[j - 1] = arguments[j];
              }
              listeners[i].fn.apply(listeners[i].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter2.prototype.on = function on(event, fn, context) {
      return addListener(this, event, fn, context, false);
    };
    EventEmitter2.prototype.once = function once(event, fn, context) {
      return addListener(this, event, fn, context, true);
    };
    EventEmitter2.prototype.removeListener = function removeListener(event, fn, context, once) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i = 0, events = [], length = listeners.length; i < length; i++) {
          if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
            events.push(listeners[i]);
          }
        }
        if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
        else clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt]) clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
    EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
    EventEmitter2.prefixed = prefix;
    EventEmitter2.EventEmitter = EventEmitter2;
    if ("undefined" !== typeof module) {
      module.exports = EventEmitter2;
    }
  }
});

// node_modules/readable-stream/lib/ours/primordials.js
var require_primordials = __commonJS({
  "node_modules/readable-stream/lib/ours/primordials.js"(exports, module) {
    "use strict";
    var AggregateError = class extends Error {
      constructor(errors) {
        if (!Array.isArray(errors)) {
          throw new TypeError(`Expected input to be an Array, got ${typeof errors}`);
        }
        let message = "";
        for (let i = 0; i < errors.length; i++) {
          message += `    ${errors[i].stack}
`;
        }
        super(message);
        this.name = "AggregateError";
        this.errors = errors;
      }
    };
    module.exports = {
      AggregateError,
      ArrayIsArray(self2) {
        return Array.isArray(self2);
      },
      ArrayPrototypeIncludes(self2, el) {
        return self2.includes(el);
      },
      ArrayPrototypeIndexOf(self2, el) {
        return self2.indexOf(el);
      },
      ArrayPrototypeJoin(self2, sep) {
        return self2.join(sep);
      },
      ArrayPrototypeMap(self2, fn) {
        return self2.map(fn);
      },
      ArrayPrototypePop(self2, el) {
        return self2.pop(el);
      },
      ArrayPrototypePush(self2, el) {
        return self2.push(el);
      },
      ArrayPrototypeSlice(self2, start, end) {
        return self2.slice(start, end);
      },
      Error,
      FunctionPrototypeCall(fn, thisArgs, ...args) {
        return fn.call(thisArgs, ...args);
      },
      FunctionPrototypeSymbolHasInstance(self2, instance) {
        return Function.prototype[Symbol.hasInstance].call(self2, instance);
      },
      MathFloor: Math.floor,
      Number,
      NumberIsInteger: Number.isInteger,
      NumberIsNaN: Number.isNaN,
      NumberMAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER,
      NumberMIN_SAFE_INTEGER: Number.MIN_SAFE_INTEGER,
      NumberParseInt: Number.parseInt,
      ObjectDefineProperties(self2, props) {
        return Object.defineProperties(self2, props);
      },
      ObjectDefineProperty(self2, name, prop) {
        return Object.defineProperty(self2, name, prop);
      },
      ObjectGetOwnPropertyDescriptor(self2, name) {
        return Object.getOwnPropertyDescriptor(self2, name);
      },
      ObjectKeys(obj) {
        return Object.keys(obj);
      },
      ObjectSetPrototypeOf(target, proto) {
        return Object.setPrototypeOf(target, proto);
      },
      Promise,
      PromisePrototypeCatch(self2, fn) {
        return self2.catch(fn);
      },
      PromisePrototypeThen(self2, thenFn, catchFn) {
        return self2.then(thenFn, catchFn);
      },
      PromiseReject(err) {
        return Promise.reject(err);
      },
      PromiseResolve(val) {
        return Promise.resolve(val);
      },
      ReflectApply: Reflect.apply,
      RegExpPrototypeTest(self2, value) {
        return self2.test(value);
      },
      SafeSet: Set,
      String,
      StringPrototypeSlice(self2, start, end) {
        return self2.slice(start, end);
      },
      StringPrototypeToLowerCase(self2) {
        return self2.toLowerCase();
      },
      StringPrototypeToUpperCase(self2) {
        return self2.toUpperCase();
      },
      StringPrototypeTrim(self2) {
        return self2.trim();
      },
      Symbol,
      SymbolFor: Symbol.for,
      SymbolAsyncIterator: Symbol.asyncIterator,
      SymbolHasInstance: Symbol.hasInstance,
      SymbolIterator: Symbol.iterator,
      SymbolDispose: Symbol.dispose || Symbol("Symbol.dispose"),
      SymbolAsyncDispose: Symbol.asyncDispose || Symbol("Symbol.asyncDispose"),
      TypedArrayPrototypeSet(self2, buf, len) {
        return self2.set(buf, len);
      },
      Boolean,
      Uint8Array
    };
  }
});

// node_modules/readable-stream/lib/ours/util/inspect.js
var require_inspect = __commonJS({
  "node_modules/readable-stream/lib/ours/util/inspect.js"(exports, module) {
    "use strict";
    module.exports = {
      format(format, ...args) {
        return format.replace(/%([sdifj])/g, function(...[_unused, type]) {
          const replacement = args.shift();
          if (type === "f") {
            return replacement.toFixed(6);
          } else if (type === "j") {
            return JSON.stringify(replacement);
          } else if (type === "s" && typeof replacement === "object") {
            const ctor = replacement.constructor !== Object ? replacement.constructor.name : "";
            return `${ctor} {}`.trim();
          } else {
            return replacement.toString();
          }
        });
      },
      inspect(value) {
        switch (typeof value) {
          case "string":
            if (value.includes("'")) {
              if (!value.includes('"')) {
                return `"${value}"`;
              } else if (!value.includes("`") && !value.includes("${")) {
                return `\`${value}\``;
              }
            }
            return `'${value}'`;
          case "number":
            if (isNaN(value)) {
              return "NaN";
            } else if (Object.is(value, -0)) {
              return String(value);
            }
            return value;
          case "bigint":
            return `${String(value)}n`;
          case "boolean":
          case "undefined":
            return String(value);
          case "object":
            return "{}";
        }
      }
    };
  }
});

// node_modules/readable-stream/lib/ours/errors.js
var require_errors = __commonJS({
  "node_modules/readable-stream/lib/ours/errors.js"(exports, module) {
    "use strict";
    var { format, inspect } = require_inspect();
    var { AggregateError: CustomAggregateError } = require_primordials();
    var AggregateError = globalThis.AggregateError || CustomAggregateError;
    var kIsNodeError = Symbol("kIsNodeError");
    var kTypes = [
      "string",
      "function",
      "number",
      "object",
      // Accept 'Function' and 'Object' as alternative to the lower cased version.
      "Function",
      "Object",
      "boolean",
      "bigint",
      "symbol"
    ];
    var classRegExp = /^([A-Z][a-z0-9]*)+$/;
    var nodeInternalPrefix = "__node_internal_";
    var codes = {};
    function assert(value, message) {
      if (!value) {
        throw new codes.ERR_INTERNAL_ASSERTION(message);
      }
    }
    function addNumericalSeparator(val) {
      let res = "";
      let i = val.length;
      const start = val[0] === "-" ? 1 : 0;
      for (; i >= start + 4; i -= 3) {
        res = `_${val.slice(i - 3, i)}${res}`;
      }
      return `${val.slice(0, i)}${res}`;
    }
    function getMessage(key, msg, args) {
      if (typeof msg === "function") {
        assert(
          msg.length <= args.length,
          // Default options do not count.
          `Code: ${key}; The provided arguments length (${args.length}) does not match the required ones (${msg.length}).`
        );
        return msg(...args);
      }
      const expectedLength = (msg.match(/%[dfijoOs]/g) || []).length;
      assert(
        expectedLength === args.length,
        `Code: ${key}; The provided arguments length (${args.length}) does not match the required ones (${expectedLength}).`
      );
      if (args.length === 0) {
        return msg;
      }
      return format(msg, ...args);
    }
    function E(code, message, Base) {
      if (!Base) {
        Base = Error;
      }
      class NodeError extends Base {
        constructor(...args) {
          super(getMessage(code, message, args));
        }
        toString() {
          return `${this.name} [${code}]: ${this.message}`;
        }
      }
      Object.defineProperties(NodeError.prototype, {
        name: {
          value: Base.name,
          writable: true,
          enumerable: false,
          configurable: true
        },
        toString: {
          value() {
            return `${this.name} [${code}]: ${this.message}`;
          },
          writable: true,
          enumerable: false,
          configurable: true
        }
      });
      NodeError.prototype.code = code;
      NodeError.prototype[kIsNodeError] = true;
      codes[code] = NodeError;
    }
    function hideStackFrames(fn) {
      const hidden = nodeInternalPrefix + fn.name;
      Object.defineProperty(fn, "name", {
        value: hidden
      });
      return fn;
    }
    function aggregateTwoErrors(innerError, outerError) {
      if (innerError && outerError && innerError !== outerError) {
        if (Array.isArray(outerError.errors)) {
          outerError.errors.push(innerError);
          return outerError;
        }
        const err = new AggregateError([outerError, innerError], outerError.message);
        err.code = outerError.code;
        return err;
      }
      return innerError || outerError;
    }
    var AbortError = class extends Error {
      constructor(message = "The operation was aborted", options = void 0) {
        if (options !== void 0 && typeof options !== "object") {
          throw new codes.ERR_INVALID_ARG_TYPE("options", "Object", options);
        }
        super(message, options);
        this.code = "ABORT_ERR";
        this.name = "AbortError";
      }
    };
    E("ERR_ASSERTION", "%s", Error);
    E(
      "ERR_INVALID_ARG_TYPE",
      (name, expected, actual) => {
        assert(typeof name === "string", "'name' must be a string");
        if (!Array.isArray(expected)) {
          expected = [expected];
        }
        let msg = "The ";
        if (name.endsWith(" argument")) {
          msg += `${name} `;
        } else {
          msg += `"${name}" ${name.includes(".") ? "property" : "argument"} `;
        }
        msg += "must be ";
        const types3 = [];
        const instances = [];
        const other = [];
        for (const value of expected) {
          assert(typeof value === "string", "All expected entries have to be of type string");
          if (kTypes.includes(value)) {
            types3.push(value.toLowerCase());
          } else if (classRegExp.test(value)) {
            instances.push(value);
          } else {
            assert(value !== "object", 'The value "object" should be written as "Object"');
            other.push(value);
          }
        }
        if (instances.length > 0) {
          const pos = types3.indexOf("object");
          if (pos !== -1) {
            types3.splice(types3, pos, 1);
            instances.push("Object");
          }
        }
        if (types3.length > 0) {
          switch (types3.length) {
            case 1:
              msg += `of type ${types3[0]}`;
              break;
            case 2:
              msg += `one of type ${types3[0]} or ${types3[1]}`;
              break;
            default: {
              const last = types3.pop();
              msg += `one of type ${types3.join(", ")}, or ${last}`;
            }
          }
          if (instances.length > 0 || other.length > 0) {
            msg += " or ";
          }
        }
        if (instances.length > 0) {
          switch (instances.length) {
            case 1:
              msg += `an instance of ${instances[0]}`;
              break;
            case 2:
              msg += `an instance of ${instances[0]} or ${instances[1]}`;
              break;
            default: {
              const last = instances.pop();
              msg += `an instance of ${instances.join(", ")}, or ${last}`;
            }
          }
          if (other.length > 0) {
            msg += " or ";
          }
        }
        switch (other.length) {
          case 0:
            break;
          case 1:
            if (other[0].toLowerCase() !== other[0]) {
              msg += "an ";
            }
            msg += `${other[0]}`;
            break;
          case 2:
            msg += `one of ${other[0]} or ${other[1]}`;
            break;
          default: {
            const last = other.pop();
            msg += `one of ${other.join(", ")}, or ${last}`;
          }
        }
        if (actual == null) {
          msg += `. Received ${actual}`;
        } else if (typeof actual === "function" && actual.name) {
          msg += `. Received function ${actual.name}`;
        } else if (typeof actual === "object") {
          var _actual$constructor;
          if ((_actual$constructor = actual.constructor) !== null && _actual$constructor !== void 0 && _actual$constructor.name) {
            msg += `. Received an instance of ${actual.constructor.name}`;
          } else {
            const inspected = inspect(actual, {
              depth: -1
            });
            msg += `. Received ${inspected}`;
          }
        } else {
          let inspected = inspect(actual, {
            colors: false
          });
          if (inspected.length > 25) {
            inspected = `${inspected.slice(0, 25)}...`;
          }
          msg += `. Received type ${typeof actual} (${inspected})`;
        }
        return msg;
      },
      TypeError
    );
    E(
      "ERR_INVALID_ARG_VALUE",
      (name, value, reason = "is invalid") => {
        let inspected = inspect(value);
        if (inspected.length > 128) {
          inspected = inspected.slice(0, 128) + "...";
        }
        const type = name.includes(".") ? "property" : "argument";
        return `The ${type} '${name}' ${reason}. Received ${inspected}`;
      },
      TypeError
    );
    E(
      "ERR_INVALID_RETURN_VALUE",
      (input, name, value) => {
        var _value$constructor;
        const type = value !== null && value !== void 0 && (_value$constructor = value.constructor) !== null && _value$constructor !== void 0 && _value$constructor.name ? `instance of ${value.constructor.name}` : `type ${typeof value}`;
        return `Expected ${input} to be returned from the "${name}" function but got ${type}.`;
      },
      TypeError
    );
    E(
      "ERR_MISSING_ARGS",
      (...args) => {
        assert(args.length > 0, "At least one arg needs to be specified");
        let msg;
        const len = args.length;
        args = (Array.isArray(args) ? args : [args]).map((a) => `"${a}"`).join(" or ");
        switch (len) {
          case 1:
            msg += `The ${args[0]} argument`;
            break;
          case 2:
            msg += `The ${args[0]} and ${args[1]} arguments`;
            break;
          default:
            {
              const last = args.pop();
              msg += `The ${args.join(", ")}, and ${last} arguments`;
            }
            break;
        }
        return `${msg} must be specified`;
      },
      TypeError
    );
    E(
      "ERR_OUT_OF_RANGE",
      (str, range, input) => {
        assert(range, 'Missing "range" argument');
        let received;
        if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
          received = addNumericalSeparator(String(input));
        } else if (typeof input === "bigint") {
          received = String(input);
          const limit = BigInt(2) ** BigInt(32);
          if (input > limit || input < -limit) {
            received = addNumericalSeparator(received);
          }
          received += "n";
        } else {
          received = inspect(input);
        }
        return `The value of "${str}" is out of range. It must be ${range}. Received ${received}`;
      },
      RangeError
    );
    E("ERR_MULTIPLE_CALLBACK", "Callback called multiple times", Error);
    E("ERR_METHOD_NOT_IMPLEMENTED", "The %s method is not implemented", Error);
    E("ERR_STREAM_ALREADY_FINISHED", "Cannot call %s after a stream was finished", Error);
    E("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable", Error);
    E("ERR_STREAM_DESTROYED", "Cannot call %s after a stream was destroyed", Error);
    E("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    E("ERR_STREAM_PREMATURE_CLOSE", "Premature close", Error);
    E("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF", Error);
    E("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event", Error);
    E("ERR_STREAM_WRITE_AFTER_END", "write after end", Error);
    E("ERR_UNKNOWN_ENCODING", "Unknown encoding: %s", TypeError);
    module.exports = {
      AbortError,
      aggregateTwoErrors: hideStackFrames(aggregateTwoErrors),
      hideStackFrames,
      codes
    };
  }
});

// node_modules/abort-controller/browser.js
var require_browser = __commonJS({
  "node_modules/abort-controller/browser.js"(exports, module) {
    "use strict";
    var { AbortController, AbortSignal } = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : (
      /* otherwise */
      void 0
    );
    module.exports = AbortController;
    module.exports.AbortSignal = AbortSignal;
    module.exports.default = AbortController;
  }
});

// node_modules/events/events.js
var require_events = __commonJS({
  "node_modules/events/events.js"(exports, module) {
    "use strict";
    var R = typeof Reflect === "object" ? Reflect : null;
    var ReflectApply = R && typeof R.apply === "function" ? R.apply : function ReflectApply2(target, receiver, args) {
      return Function.prototype.apply.call(target, receiver, args);
    };
    var ReflectOwnKeys;
    if (R && typeof R.ownKeys === "function") {
      ReflectOwnKeys = R.ownKeys;
    } else if (Object.getOwnPropertySymbols) {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
      };
    } else {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target);
      };
    }
    function ProcessEmitWarning(warning) {
      if (console && console.warn) console.warn(warning);
    }
    var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
      return value !== value;
    };
    function EventEmitter2() {
      EventEmitter2.init.call(this);
    }
    module.exports = EventEmitter2;
    module.exports.once = once;
    EventEmitter2.EventEmitter = EventEmitter2;
    EventEmitter2.prototype._events = void 0;
    EventEmitter2.prototype._eventsCount = 0;
    EventEmitter2.prototype._maxListeners = void 0;
    var defaultMaxListeners = 10;
    function checkListener(listener) {
      if (typeof listener !== "function") {
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
      }
    }
    Object.defineProperty(EventEmitter2, "defaultMaxListeners", {
      enumerable: true,
      get: function() {
        return defaultMaxListeners;
      },
      set: function(arg) {
        if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
          throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
        }
        defaultMaxListeners = arg;
      }
    });
    EventEmitter2.init = function() {
      if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
      }
      this._maxListeners = this._maxListeners || void 0;
    };
    EventEmitter2.prototype.setMaxListeners = function setMaxListeners(n) {
      if (typeof n !== "number" || n < 0 || NumberIsNaN(n)) {
        throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + ".");
      }
      this._maxListeners = n;
      return this;
    };
    function _getMaxListeners(that) {
      if (that._maxListeners === void 0)
        return EventEmitter2.defaultMaxListeners;
      return that._maxListeners;
    }
    EventEmitter2.prototype.getMaxListeners = function getMaxListeners() {
      return _getMaxListeners(this);
    };
    EventEmitter2.prototype.emit = function emit(type) {
      var args = [];
      for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
      var doError = type === "error";
      var events = this._events;
      if (events !== void 0)
        doError = doError && events.error === void 0;
      else if (!doError)
        return false;
      if (doError) {
        var er;
        if (args.length > 0)
          er = args[0];
        if (er instanceof Error) {
          throw er;
        }
        var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
        err.context = er;
        throw err;
      }
      var handler = events[type];
      if (handler === void 0)
        return false;
      if (typeof handler === "function") {
        ReflectApply(handler, this, args);
      } else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for (var i = 0; i < len; ++i)
          ReflectApply(listeners[i], this, args);
      }
      return true;
    };
    function _addListener(target, type, listener, prepend) {
      var m;
      var events;
      var existing;
      checkListener(listener);
      events = target._events;
      if (events === void 0) {
        events = target._events = /* @__PURE__ */ Object.create(null);
        target._eventsCount = 0;
      } else {
        if (events.newListener !== void 0) {
          target.emit(
            "newListener",
            type,
            listener.listener ? listener.listener : listener
          );
          events = target._events;
        }
        existing = events[type];
      }
      if (existing === void 0) {
        existing = events[type] = listener;
        ++target._eventsCount;
      } else {
        if (typeof existing === "function") {
          existing = events[type] = prepend ? [listener, existing] : [existing, listener];
        } else if (prepend) {
          existing.unshift(listener);
        } else {
          existing.push(listener);
        }
        m = _getMaxListeners(target);
        if (m > 0 && existing.length > m && !existing.warned) {
          existing.warned = true;
          var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
          w.name = "MaxListenersExceededWarning";
          w.emitter = target;
          w.type = type;
          w.count = existing.length;
          ProcessEmitWarning(w);
        }
      }
      return target;
    }
    EventEmitter2.prototype.addListener = function addListener(type, listener) {
      return _addListener(this, type, listener, false);
    };
    EventEmitter2.prototype.on = EventEmitter2.prototype.addListener;
    EventEmitter2.prototype.prependListener = function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };
    function onceWrapper() {
      if (!this.fired) {
        this.target.removeListener(this.type, this.wrapFn);
        this.fired = true;
        if (arguments.length === 0)
          return this.listener.call(this.target);
        return this.listener.apply(this.target, arguments);
      }
    }
    function _onceWrap(target, type, listener) {
      var state = { fired: false, wrapFn: void 0, target, type, listener };
      var wrapped = onceWrapper.bind(state);
      wrapped.listener = listener;
      state.wrapFn = wrapped;
      return wrapped;
    }
    EventEmitter2.prototype.once = function once2(type, listener) {
      checkListener(listener);
      this.on(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter2.prototype.prependOnceListener = function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter2.prototype.removeListener = function removeListener(type, listener) {
      var list, events, position, i, originalListener;
      checkListener(listener);
      events = this._events;
      if (events === void 0)
        return this;
      list = events[type];
      if (list === void 0)
        return this;
      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = /* @__PURE__ */ Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit("removeListener", type, list.listener || listener);
        }
      } else if (typeof list !== "function") {
        position = -1;
        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }
        if (position < 0)
          return this;
        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }
        if (list.length === 1)
          events[type] = list[0];
        if (events.removeListener !== void 0)
          this.emit("removeListener", type, originalListener || listener);
      }
      return this;
    };
    EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
    EventEmitter2.prototype.removeAllListeners = function removeAllListeners(type) {
      var listeners, events, i;
      events = this._events;
      if (events === void 0)
        return this;
      if (events.removeListener === void 0) {
        if (arguments.length === 0) {
          this._events = /* @__PURE__ */ Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== void 0) {
          if (--this._eventsCount === 0)
            this._events = /* @__PURE__ */ Object.create(null);
          else
            delete events[type];
        }
        return this;
      }
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === "removeListener") continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners("removeListener");
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
        return this;
      }
      listeners = events[type];
      if (typeof listeners === "function") {
        this.removeListener(type, listeners);
      } else if (listeners !== void 0) {
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }
      return this;
    };
    function _listeners(target, type, unwrap) {
      var events = target._events;
      if (events === void 0)
        return [];
      var evlistener = events[type];
      if (evlistener === void 0)
        return [];
      if (typeof evlistener === "function")
        return unwrap ? [evlistener.listener || evlistener] : [evlistener];
      return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
    }
    EventEmitter2.prototype.listeners = function listeners(type) {
      return _listeners(this, type, true);
    };
    EventEmitter2.prototype.rawListeners = function rawListeners(type) {
      return _listeners(this, type, false);
    };
    EventEmitter2.listenerCount = function(emitter, type) {
      if (typeof emitter.listenerCount === "function") {
        return emitter.listenerCount(type);
      } else {
        return listenerCount.call(emitter, type);
      }
    };
    EventEmitter2.prototype.listenerCount = listenerCount;
    function listenerCount(type) {
      var events = this._events;
      if (events !== void 0) {
        var evlistener = events[type];
        if (typeof evlistener === "function") {
          return 1;
        } else if (evlistener !== void 0) {
          return evlistener.length;
        }
      }
      return 0;
    }
    EventEmitter2.prototype.eventNames = function eventNames() {
      return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
    };
    function arrayClone(arr, n) {
      var copy = new Array(n);
      for (var i = 0; i < n; ++i)
        copy[i] = arr[i];
      return copy;
    }
    function spliceOne(list, index) {
      for (; index + 1 < list.length; index++)
        list[index] = list[index + 1];
      list.pop();
    }
    function unwrapListeners(arr) {
      var ret = new Array(arr.length);
      for (var i = 0; i < ret.length; ++i) {
        ret[i] = arr[i].listener || arr[i];
      }
      return ret;
    }
    function once(emitter, name) {
      return new Promise(function(resolve2, reject) {
        function errorListener(err) {
          emitter.removeListener(name, resolver);
          reject(err);
        }
        function resolver() {
          if (typeof emitter.removeListener === "function") {
            emitter.removeListener("error", errorListener);
          }
          resolve2([].slice.call(arguments));
        }
        ;
        eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
        if (name !== "error") {
          addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
        }
      });
    }
    function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
      if (typeof emitter.on === "function") {
        eventTargetAgnosticAddListener(emitter, "error", handler, flags);
      }
    }
    function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
      if (typeof emitter.on === "function") {
        if (flags.once) {
          emitter.once(name, listener);
        } else {
          emitter.on(name, listener);
        }
      } else if (typeof emitter.addEventListener === "function") {
        emitter.addEventListener(name, function wrapListener(arg) {
          if (flags.once) {
            emitter.removeEventListener(name, wrapListener);
          }
          listener(arg);
        });
      } else {
        throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
      }
    }
  }
});

// node_modules/readable-stream/lib/ours/util.js
var require_util = __commonJS({
  "node_modules/readable-stream/lib/ours/util.js"(exports, module) {
    "use strict";
    var bufferModule = require_buffer();
    var { format, inspect } = require_inspect();
    var {
      codes: { ERR_INVALID_ARG_TYPE }
    } = require_errors();
    var { kResistStopPropagation, AggregateError, SymbolDispose } = require_primordials();
    var AbortSignal = globalThis.AbortSignal || require_browser().AbortSignal;
    var AbortController = globalThis.AbortController || require_browser().AbortController;
    var AsyncFunction = Object.getPrototypeOf(async function() {
    }).constructor;
    var Blob2 = globalThis.Blob || bufferModule.Blob;
    var isBlob = typeof Blob2 !== "undefined" ? function isBlob2(b) {
      return b instanceof Blob2;
    } : function isBlob2(b) {
      return false;
    };
    var validateAbortSignal = (signal, name) => {
      if (signal !== void 0 && (signal === null || typeof signal !== "object" || !("aborted" in signal))) {
        throw new ERR_INVALID_ARG_TYPE(name, "AbortSignal", signal);
      }
    };
    var validateFunction = (value, name) => {
      if (typeof value !== "function") {
        throw new ERR_INVALID_ARG_TYPE(name, "Function", value);
      }
    };
    module.exports = {
      AggregateError,
      kEmptyObject: Object.freeze({}),
      once(callback) {
        let called = false;
        return function(...args) {
          if (called) {
            return;
          }
          called = true;
          callback.apply(this, args);
        };
      },
      createDeferredPromise: function() {
        let resolve2;
        let reject;
        const promise = new Promise((res, rej) => {
          resolve2 = res;
          reject = rej;
        });
        return {
          promise,
          resolve: resolve2,
          reject
        };
      },
      promisify(fn) {
        return new Promise((resolve2, reject) => {
          fn((err, ...args) => {
            if (err) {
              return reject(err);
            }
            return resolve2(...args);
          });
        });
      },
      debuglog() {
        return function() {
        };
      },
      format,
      inspect,
      types: {
        isAsyncFunction(fn) {
          return fn instanceof AsyncFunction;
        },
        isArrayBufferView(arr) {
          return ArrayBuffer.isView(arr);
        }
      },
      isBlob,
      deprecate(fn, message) {
        return fn;
      },
      addAbortListener: require_events().addAbortListener || function addAbortListener(signal, listener) {
        if (signal === void 0) {
          throw new ERR_INVALID_ARG_TYPE("signal", "AbortSignal", signal);
        }
        validateAbortSignal(signal, "signal");
        validateFunction(listener, "listener");
        let removeEventListener;
        if (signal.aborted) {
          queueMicrotask(() => listener());
        } else {
          signal.addEventListener("abort", listener, {
            __proto__: null,
            once: true,
            [kResistStopPropagation]: true
          });
          removeEventListener = () => {
            signal.removeEventListener("abort", listener);
          };
        }
        return {
          __proto__: null,
          [SymbolDispose]() {
            var _removeEventListener;
            (_removeEventListener = removeEventListener) === null || _removeEventListener === void 0 ? void 0 : _removeEventListener();
          }
        };
      },
      AbortSignalAny: AbortSignal.any || function AbortSignalAny(signals) {
        if (signals.length === 1) {
          return signals[0];
        }
        const ac = new AbortController();
        const abort = () => ac.abort();
        signals.forEach((signal) => {
          validateAbortSignal(signal, "signals");
          signal.addEventListener("abort", abort, {
            once: true
          });
        });
        ac.signal.addEventListener(
          "abort",
          () => {
            signals.forEach((signal) => signal.removeEventListener("abort", abort));
          },
          {
            once: true
          }
        );
        return ac.signal;
      }
    };
    module.exports.promisify.custom = Symbol.for("nodejs.util.promisify.custom");
  }
});

// node_modules/readable-stream/lib/internal/validators.js
var require_validators = __commonJS({
  "node_modules/readable-stream/lib/internal/validators.js"(exports, module) {
    "use strict";
    var {
      ArrayIsArray,
      ArrayPrototypeIncludes,
      ArrayPrototypeJoin,
      ArrayPrototypeMap,
      NumberIsInteger,
      NumberIsNaN,
      NumberMAX_SAFE_INTEGER,
      NumberMIN_SAFE_INTEGER,
      NumberParseInt,
      ObjectPrototypeHasOwnProperty,
      RegExpPrototypeExec,
      String: String2,
      StringPrototypeToUpperCase,
      StringPrototypeTrim
    } = require_primordials();
    var {
      hideStackFrames,
      codes: { ERR_SOCKET_BAD_PORT, ERR_INVALID_ARG_TYPE, ERR_INVALID_ARG_VALUE, ERR_OUT_OF_RANGE, ERR_UNKNOWN_SIGNAL }
    } = require_errors();
    var { normalizeEncoding } = require_util();
    var { isAsyncFunction, isArrayBufferView } = require_util().types;
    var signals = {};
    function isInt32(value) {
      return value === (value | 0);
    }
    function isUint32(value) {
      return value === value >>> 0;
    }
    var octalReg = /^[0-7]+$/;
    var modeDesc = "must be a 32-bit unsigned integer or an octal string";
    function parseFileMode(value, name, def) {
      if (typeof value === "undefined") {
        value = def;
      }
      if (typeof value === "string") {
        if (RegExpPrototypeExec(octalReg, value) === null) {
          throw new ERR_INVALID_ARG_VALUE(name, value, modeDesc);
        }
        value = NumberParseInt(value, 8);
      }
      validateUint32(value, name);
      return value;
    }
    var validateInteger = hideStackFrames((value, name, min = NumberMIN_SAFE_INTEGER, max = NumberMAX_SAFE_INTEGER) => {
      if (typeof value !== "number") throw new ERR_INVALID_ARG_TYPE(name, "number", value);
      if (!NumberIsInteger(value)) throw new ERR_OUT_OF_RANGE(name, "an integer", value);
      if (value < min || value > max) throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);
    });
    var validateInt32 = hideStackFrames((value, name, min = -2147483648, max = 2147483647) => {
      if (typeof value !== "number") {
        throw new ERR_INVALID_ARG_TYPE(name, "number", value);
      }
      if (!NumberIsInteger(value)) {
        throw new ERR_OUT_OF_RANGE(name, "an integer", value);
      }
      if (value < min || value > max) {
        throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);
      }
    });
    var validateUint32 = hideStackFrames((value, name, positive = false) => {
      if (typeof value !== "number") {
        throw new ERR_INVALID_ARG_TYPE(name, "number", value);
      }
      if (!NumberIsInteger(value)) {
        throw new ERR_OUT_OF_RANGE(name, "an integer", value);
      }
      const min = positive ? 1 : 0;
      const max = 4294967295;
      if (value < min || value > max) {
        throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);
      }
    });
    function validateString(value, name) {
      if (typeof value !== "string") throw new ERR_INVALID_ARG_TYPE(name, "string", value);
    }
    function validateNumber(value, name, min = void 0, max) {
      if (typeof value !== "number") throw new ERR_INVALID_ARG_TYPE(name, "number", value);
      if (min != null && value < min || max != null && value > max || (min != null || max != null) && NumberIsNaN(value)) {
        throw new ERR_OUT_OF_RANGE(
          name,
          `${min != null ? `>= ${min}` : ""}${min != null && max != null ? " && " : ""}${max != null ? `<= ${max}` : ""}`,
          value
        );
      }
    }
    var validateOneOf = hideStackFrames((value, name, oneOf) => {
      if (!ArrayPrototypeIncludes(oneOf, value)) {
        const allowed = ArrayPrototypeJoin(
          ArrayPrototypeMap(oneOf, (v) => typeof v === "string" ? `'${v}'` : String2(v)),
          ", "
        );
        const reason = "must be one of: " + allowed;
        throw new ERR_INVALID_ARG_VALUE(name, value, reason);
      }
    });
    function validateBoolean(value, name) {
      if (typeof value !== "boolean") throw new ERR_INVALID_ARG_TYPE(name, "boolean", value);
    }
    function getOwnPropertyValueOrDefault(options, key, defaultValue) {
      return options == null || !ObjectPrototypeHasOwnProperty(options, key) ? defaultValue : options[key];
    }
    var validateObject = hideStackFrames((value, name, options = null) => {
      const allowArray = getOwnPropertyValueOrDefault(options, "allowArray", false);
      const allowFunction = getOwnPropertyValueOrDefault(options, "allowFunction", false);
      const nullable = getOwnPropertyValueOrDefault(options, "nullable", false);
      if (!nullable && value === null || !allowArray && ArrayIsArray(value) || typeof value !== "object" && (!allowFunction || typeof value !== "function")) {
        throw new ERR_INVALID_ARG_TYPE(name, "Object", value);
      }
    });
    var validateDictionary = hideStackFrames((value, name) => {
      if (value != null && typeof value !== "object" && typeof value !== "function") {
        throw new ERR_INVALID_ARG_TYPE(name, "a dictionary", value);
      }
    });
    var validateArray = hideStackFrames((value, name, minLength = 0) => {
      if (!ArrayIsArray(value)) {
        throw new ERR_INVALID_ARG_TYPE(name, "Array", value);
      }
      if (value.length < minLength) {
        const reason = `must be longer than ${minLength}`;
        throw new ERR_INVALID_ARG_VALUE(name, value, reason);
      }
    });
    function validateStringArray(value, name) {
      validateArray(value, name);
      for (let i = 0; i < value.length; i++) {
        validateString(value[i], `${name}[${i}]`);
      }
    }
    function validateBooleanArray(value, name) {
      validateArray(value, name);
      for (let i = 0; i < value.length; i++) {
        validateBoolean(value[i], `${name}[${i}]`);
      }
    }
    function validateAbortSignalArray(value, name) {
      validateArray(value, name);
      for (let i = 0; i < value.length; i++) {
        const signal = value[i];
        const indexedName = `${name}[${i}]`;
        if (signal == null) {
          throw new ERR_INVALID_ARG_TYPE(indexedName, "AbortSignal", signal);
        }
        validateAbortSignal(signal, indexedName);
      }
    }
    function validateSignalName(signal, name = "signal") {
      validateString(signal, name);
      if (signals[signal] === void 0) {
        if (signals[StringPrototypeToUpperCase(signal)] !== void 0) {
          throw new ERR_UNKNOWN_SIGNAL(signal + " (signals must use all capital letters)");
        }
        throw new ERR_UNKNOWN_SIGNAL(signal);
      }
    }
    var validateBuffer = hideStackFrames((buffer, name = "buffer") => {
      if (!isArrayBufferView(buffer)) {
        throw new ERR_INVALID_ARG_TYPE(name, ["Buffer", "TypedArray", "DataView"], buffer);
      }
    });
    function validateEncoding(data, encoding) {
      const normalizedEncoding = normalizeEncoding(encoding);
      const length = data.length;
      if (normalizedEncoding === "hex" && length % 2 !== 0) {
        throw new ERR_INVALID_ARG_VALUE("encoding", encoding, `is invalid for data of length ${length}`);
      }
    }
    function validatePort(port, name = "Port", allowZero = true) {
      if (typeof port !== "number" && typeof port !== "string" || typeof port === "string" && StringPrototypeTrim(port).length === 0 || +port !== +port >>> 0 || port > 65535 || port === 0 && !allowZero) {
        throw new ERR_SOCKET_BAD_PORT(name, port, allowZero);
      }
      return port | 0;
    }
    var validateAbortSignal = hideStackFrames((signal, name) => {
      if (signal !== void 0 && (signal === null || typeof signal !== "object" || !("aborted" in signal))) {
        throw new ERR_INVALID_ARG_TYPE(name, "AbortSignal", signal);
      }
    });
    var validateFunction = hideStackFrames((value, name) => {
      if (typeof value !== "function") throw new ERR_INVALID_ARG_TYPE(name, "Function", value);
    });
    var validatePlainFunction = hideStackFrames((value, name) => {
      if (typeof value !== "function" || isAsyncFunction(value)) throw new ERR_INVALID_ARG_TYPE(name, "Function", value);
    });
    var validateUndefined = hideStackFrames((value, name) => {
      if (value !== void 0) throw new ERR_INVALID_ARG_TYPE(name, "undefined", value);
    });
    function validateUnion(value, name, union) {
      if (!ArrayPrototypeIncludes(union, value)) {
        throw new ERR_INVALID_ARG_TYPE(name, `('${ArrayPrototypeJoin(union, "|")}')`, value);
      }
    }
    var linkValueRegExp = /^(?:<[^>]*>)(?:\s*;\s*[^;"\s]+(?:=(")?[^;"\s]*\1)?)*$/;
    function validateLinkHeaderFormat(value, name) {
      if (typeof value === "undefined" || !RegExpPrototypeExec(linkValueRegExp, value)) {
        throw new ERR_INVALID_ARG_VALUE(
          name,
          value,
          'must be an array or string of format "</styles.css>; rel=preload; as=style"'
        );
      }
    }
    function validateLinkHeaderValue(hints) {
      if (typeof hints === "string") {
        validateLinkHeaderFormat(hints, "hints");
        return hints;
      } else if (ArrayIsArray(hints)) {
        const hintsLength = hints.length;
        let result = "";
        if (hintsLength === 0) {
          return result;
        }
        for (let i = 0; i < hintsLength; i++) {
          const link3 = hints[i];
          validateLinkHeaderFormat(link3, "hints");
          result += link3;
          if (i !== hintsLength - 1) {
            result += ", ";
          }
        }
        return result;
      }
      throw new ERR_INVALID_ARG_VALUE(
        "hints",
        hints,
        'must be an array or string of format "</styles.css>; rel=preload; as=style"'
      );
    }
    module.exports = {
      isInt32,
      isUint32,
      parseFileMode,
      validateArray,
      validateStringArray,
      validateBooleanArray,
      validateAbortSignalArray,
      validateBoolean,
      validateBuffer,
      validateDictionary,
      validateEncoding,
      validateFunction,
      validateInt32,
      validateInteger,
      validateNumber,
      validateObject,
      validateOneOf,
      validatePlainFunction,
      validatePort,
      validateSignalName,
      validateString,
      validateUint32,
      validateUndefined,
      validateUnion,
      validateAbortSignal,
      validateLinkHeaderValue
    };
  }
});

// node_modules/process/browser.js
var require_browser2 = __commonJS({
  "node_modules/process/browser.js"(exports, module) {
    var process = module.exports = {};
    var cachedSetTimeout;
    var cachedClearTimeout;
    function defaultSetTimout() {
      throw new Error("setTimeout has not been defined");
    }
    function defaultClearTimeout() {
      throw new Error("clearTimeout has not been defined");
    }
    (function() {
      try {
        if (typeof setTimeout === "function") {
          cachedSetTimeout = setTimeout;
        } else {
          cachedSetTimeout = defaultSetTimout;
        }
      } catch (e) {
        cachedSetTimeout = defaultSetTimout;
      }
      try {
        if (typeof clearTimeout === "function") {
          cachedClearTimeout = clearTimeout;
        } else {
          cachedClearTimeout = defaultClearTimeout;
        }
      } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
      }
    })();
    function runTimeout(fun) {
      if (cachedSetTimeout === setTimeout) {
        return setTimeout(fun, 0);
      }
      if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
      }
      try {
        return cachedSetTimeout(fun, 0);
      } catch (e) {
        try {
          return cachedSetTimeout.call(null, fun, 0);
        } catch (e2) {
          return cachedSetTimeout.call(this, fun, 0);
        }
      }
    }
    function runClearTimeout(marker) {
      if (cachedClearTimeout === clearTimeout) {
        return clearTimeout(marker);
      }
      if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
      }
      try {
        return cachedClearTimeout(marker);
      } catch (e) {
        try {
          return cachedClearTimeout.call(null, marker);
        } catch (e2) {
          return cachedClearTimeout.call(this, marker);
        }
      }
    }
    var queue = [];
    var draining = false;
    var currentQueue;
    var queueIndex = -1;
    function cleanUpNextTick() {
      if (!draining || !currentQueue) {
        return;
      }
      draining = false;
      if (currentQueue.length) {
        queue = currentQueue.concat(queue);
      } else {
        queueIndex = -1;
      }
      if (queue.length) {
        drainQueue();
      }
    }
    function drainQueue() {
      if (draining) {
        return;
      }
      var timeout = runTimeout(cleanUpNextTick);
      draining = true;
      var len = queue.length;
      while (len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
          if (currentQueue) {
            currentQueue[queueIndex].run();
          }
        }
        queueIndex = -1;
        len = queue.length;
      }
      currentQueue = null;
      draining = false;
      runClearTimeout(timeout);
    }
    process.nextTick = function(fun) {
      var args = new Array(arguments.length - 1);
      if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
          args[i - 1] = arguments[i];
        }
      }
      queue.push(new Item(fun, args));
      if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
      }
    };
    function Item(fun, array) {
      this.fun = fun;
      this.array = array;
    }
    Item.prototype.run = function() {
      this.fun.apply(null, this.array);
    };
    process.title = "browser";
    process.browser = true;
    process.env = {};
    process.argv = [];
    process.version = "";
    process.versions = {};
    function noop() {
    }
    process.on = noop;
    process.addListener = noop;
    process.once = noop;
    process.off = noop;
    process.removeListener = noop;
    process.removeAllListeners = noop;
    process.emit = noop;
    process.prependListener = noop;
    process.prependOnceListener = noop;
    process.listeners = function(name) {
      return [];
    };
    process.binding = function(name) {
      throw new Error("process.binding is not supported");
    };
    process.cwd = function() {
      return "/";
    };
    process.chdir = function(dir) {
      throw new Error("process.chdir is not supported");
    };
    process.umask = function() {
      return 0;
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/utils.js
var require_utils = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/utils.js"(exports, module) {
    "use strict";
    var { SymbolAsyncIterator, SymbolIterator, SymbolFor } = require_primordials();
    var kIsDestroyed = SymbolFor("nodejs.stream.destroyed");
    var kIsErrored = SymbolFor("nodejs.stream.errored");
    var kIsReadable = SymbolFor("nodejs.stream.readable");
    var kIsWritable = SymbolFor("nodejs.stream.writable");
    var kIsDisturbed = SymbolFor("nodejs.stream.disturbed");
    var kIsClosedPromise = SymbolFor("nodejs.webstream.isClosedPromise");
    var kControllerErrorFunction = SymbolFor("nodejs.webstream.controllerErrorFunction");
    function isReadableNodeStream(obj, strict = false) {
      var _obj$_readableState;
      return !!(obj && typeof obj.pipe === "function" && typeof obj.on === "function" && (!strict || typeof obj.pause === "function" && typeof obj.resume === "function") && (!obj._writableState || ((_obj$_readableState = obj._readableState) === null || _obj$_readableState === void 0 ? void 0 : _obj$_readableState.readable) !== false) && // Duplex
      (!obj._writableState || obj._readableState));
    }
    function isWritableNodeStream(obj) {
      var _obj$_writableState;
      return !!(obj && typeof obj.write === "function" && typeof obj.on === "function" && (!obj._readableState || ((_obj$_writableState = obj._writableState) === null || _obj$_writableState === void 0 ? void 0 : _obj$_writableState.writable) !== false));
    }
    function isDuplexNodeStream(obj) {
      return !!(obj && typeof obj.pipe === "function" && obj._readableState && typeof obj.on === "function" && typeof obj.write === "function");
    }
    function isNodeStream(obj) {
      return obj && (obj._readableState || obj._writableState || typeof obj.write === "function" && typeof obj.on === "function" || typeof obj.pipe === "function" && typeof obj.on === "function");
    }
    function isReadableStream(obj) {
      return !!(obj && !isNodeStream(obj) && typeof obj.pipeThrough === "function" && typeof obj.getReader === "function" && typeof obj.cancel === "function");
    }
    function isWritableStream(obj) {
      return !!(obj && !isNodeStream(obj) && typeof obj.getWriter === "function" && typeof obj.abort === "function");
    }
    function isTransformStream(obj) {
      return !!(obj && !isNodeStream(obj) && typeof obj.readable === "object" && typeof obj.writable === "object");
    }
    function isWebStream(obj) {
      return isReadableStream(obj) || isWritableStream(obj) || isTransformStream(obj);
    }
    function isIterable(obj, isAsync) {
      if (obj == null) return false;
      if (isAsync === true) return typeof obj[SymbolAsyncIterator] === "function";
      if (isAsync === false) return typeof obj[SymbolIterator] === "function";
      return typeof obj[SymbolAsyncIterator] === "function" || typeof obj[SymbolIterator] === "function";
    }
    function isDestroyed(stream) {
      if (!isNodeStream(stream)) return null;
      const wState = stream._writableState;
      const rState = stream._readableState;
      const state = wState || rState;
      return !!(stream.destroyed || stream[kIsDestroyed] || state !== null && state !== void 0 && state.destroyed);
    }
    function isWritableEnded(stream) {
      if (!isWritableNodeStream(stream)) return null;
      if (stream.writableEnded === true) return true;
      const wState = stream._writableState;
      if (wState !== null && wState !== void 0 && wState.errored) return false;
      if (typeof (wState === null || wState === void 0 ? void 0 : wState.ended) !== "boolean") return null;
      return wState.ended;
    }
    function isWritableFinished(stream, strict) {
      if (!isWritableNodeStream(stream)) return null;
      if (stream.writableFinished === true) return true;
      const wState = stream._writableState;
      if (wState !== null && wState !== void 0 && wState.errored) return false;
      if (typeof (wState === null || wState === void 0 ? void 0 : wState.finished) !== "boolean") return null;
      return !!(wState.finished || strict === false && wState.ended === true && wState.length === 0);
    }
    function isReadableEnded(stream) {
      if (!isReadableNodeStream(stream)) return null;
      if (stream.readableEnded === true) return true;
      const rState = stream._readableState;
      if (!rState || rState.errored) return false;
      if (typeof (rState === null || rState === void 0 ? void 0 : rState.ended) !== "boolean") return null;
      return rState.ended;
    }
    function isReadableFinished(stream, strict) {
      if (!isReadableNodeStream(stream)) return null;
      const rState = stream._readableState;
      if (rState !== null && rState !== void 0 && rState.errored) return false;
      if (typeof (rState === null || rState === void 0 ? void 0 : rState.endEmitted) !== "boolean") return null;
      return !!(rState.endEmitted || strict === false && rState.ended === true && rState.length === 0);
    }
    function isReadable2(stream) {
      if (stream && stream[kIsReadable] != null) return stream[kIsReadable];
      if (typeof (stream === null || stream === void 0 ? void 0 : stream.readable) !== "boolean") return null;
      if (isDestroyed(stream)) return false;
      return isReadableNodeStream(stream) && stream.readable && !isReadableFinished(stream);
    }
    function isWritable(stream) {
      if (stream && stream[kIsWritable] != null) return stream[kIsWritable];
      if (typeof (stream === null || stream === void 0 ? void 0 : stream.writable) !== "boolean") return null;
      if (isDestroyed(stream)) return false;
      return isWritableNodeStream(stream) && stream.writable && !isWritableEnded(stream);
    }
    function isFinished(stream, opts) {
      if (!isNodeStream(stream)) {
        return null;
      }
      if (isDestroyed(stream)) {
        return true;
      }
      if ((opts === null || opts === void 0 ? void 0 : opts.readable) !== false && isReadable2(stream)) {
        return false;
      }
      if ((opts === null || opts === void 0 ? void 0 : opts.writable) !== false && isWritable(stream)) {
        return false;
      }
      return true;
    }
    function isWritableErrored(stream) {
      var _stream$_writableStat, _stream$_writableStat2;
      if (!isNodeStream(stream)) {
        return null;
      }
      if (stream.writableErrored) {
        return stream.writableErrored;
      }
      return (_stream$_writableStat = (_stream$_writableStat2 = stream._writableState) === null || _stream$_writableStat2 === void 0 ? void 0 : _stream$_writableStat2.errored) !== null && _stream$_writableStat !== void 0 ? _stream$_writableStat : null;
    }
    function isReadableErrored(stream) {
      var _stream$_readableStat, _stream$_readableStat2;
      if (!isNodeStream(stream)) {
        return null;
      }
      if (stream.readableErrored) {
        return stream.readableErrored;
      }
      return (_stream$_readableStat = (_stream$_readableStat2 = stream._readableState) === null || _stream$_readableStat2 === void 0 ? void 0 : _stream$_readableStat2.errored) !== null && _stream$_readableStat !== void 0 ? _stream$_readableStat : null;
    }
    function isClosed(stream) {
      if (!isNodeStream(stream)) {
        return null;
      }
      if (typeof stream.closed === "boolean") {
        return stream.closed;
      }
      const wState = stream._writableState;
      const rState = stream._readableState;
      if (typeof (wState === null || wState === void 0 ? void 0 : wState.closed) === "boolean" || typeof (rState === null || rState === void 0 ? void 0 : rState.closed) === "boolean") {
        return (wState === null || wState === void 0 ? void 0 : wState.closed) || (rState === null || rState === void 0 ? void 0 : rState.closed);
      }
      if (typeof stream._closed === "boolean" && isOutgoingMessage(stream)) {
        return stream._closed;
      }
      return null;
    }
    function isOutgoingMessage(stream) {
      return typeof stream._closed === "boolean" && typeof stream._defaultKeepAlive === "boolean" && typeof stream._removedConnection === "boolean" && typeof stream._removedContLen === "boolean";
    }
    function isServerResponse(stream) {
      return typeof stream._sent100 === "boolean" && isOutgoingMessage(stream);
    }
    function isServerRequest(stream) {
      var _stream$req;
      return typeof stream._consuming === "boolean" && typeof stream._dumped === "boolean" && ((_stream$req = stream.req) === null || _stream$req === void 0 ? void 0 : _stream$req.upgradeOrConnect) === void 0;
    }
    function willEmitClose(stream) {
      if (!isNodeStream(stream)) return null;
      const wState = stream._writableState;
      const rState = stream._readableState;
      const state = wState || rState;
      return !state && isServerResponse(stream) || !!(state && state.autoDestroy && state.emitClose && state.closed === false);
    }
    function isDisturbed(stream) {
      var _stream$kIsDisturbed;
      return !!(stream && ((_stream$kIsDisturbed = stream[kIsDisturbed]) !== null && _stream$kIsDisturbed !== void 0 ? _stream$kIsDisturbed : stream.readableDidRead || stream.readableAborted));
    }
    function isErrored(stream) {
      var _ref, _ref2, _ref3, _ref4, _ref5, _stream$kIsErrored, _stream$_readableStat3, _stream$_writableStat3, _stream$_readableStat4, _stream$_writableStat4;
      return !!(stream && ((_ref = (_ref2 = (_ref3 = (_ref4 = (_ref5 = (_stream$kIsErrored = stream[kIsErrored]) !== null && _stream$kIsErrored !== void 0 ? _stream$kIsErrored : stream.readableErrored) !== null && _ref5 !== void 0 ? _ref5 : stream.writableErrored) !== null && _ref4 !== void 0 ? _ref4 : (_stream$_readableStat3 = stream._readableState) === null || _stream$_readableStat3 === void 0 ? void 0 : _stream$_readableStat3.errorEmitted) !== null && _ref3 !== void 0 ? _ref3 : (_stream$_writableStat3 = stream._writableState) === null || _stream$_writableStat3 === void 0 ? void 0 : _stream$_writableStat3.errorEmitted) !== null && _ref2 !== void 0 ? _ref2 : (_stream$_readableStat4 = stream._readableState) === null || _stream$_readableStat4 === void 0 ? void 0 : _stream$_readableStat4.errored) !== null && _ref !== void 0 ? _ref : (_stream$_writableStat4 = stream._writableState) === null || _stream$_writableStat4 === void 0 ? void 0 : _stream$_writableStat4.errored));
    }
    module.exports = {
      isDestroyed,
      kIsDestroyed,
      isDisturbed,
      kIsDisturbed,
      isErrored,
      kIsErrored,
      isReadable: isReadable2,
      kIsReadable,
      kIsClosedPromise,
      kControllerErrorFunction,
      kIsWritable,
      isClosed,
      isDuplexNodeStream,
      isFinished,
      isIterable,
      isReadableNodeStream,
      isReadableStream,
      isReadableEnded,
      isReadableFinished,
      isReadableErrored,
      isNodeStream,
      isWebStream,
      isWritable,
      isWritableNodeStream,
      isWritableStream,
      isWritableEnded,
      isWritableFinished,
      isWritableErrored,
      isServerRequest,
      isServerResponse,
      willEmitClose,
      isTransformStream
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/end-of-stream.js
var require_end_of_stream = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/end-of-stream.js"(exports, module) {
    "use strict";
    var process = require_browser2();
    var { AbortError, codes } = require_errors();
    var { ERR_INVALID_ARG_TYPE, ERR_STREAM_PREMATURE_CLOSE } = codes;
    var { kEmptyObject, once } = require_util();
    var { validateAbortSignal, validateFunction, validateObject, validateBoolean } = require_validators();
    var { Promise: Promise2, PromisePrototypeThen, SymbolDispose } = require_primordials();
    var {
      isClosed,
      isReadable: isReadable2,
      isReadableNodeStream,
      isReadableStream,
      isReadableFinished,
      isReadableErrored,
      isWritable,
      isWritableNodeStream,
      isWritableStream,
      isWritableFinished,
      isWritableErrored,
      isNodeStream,
      willEmitClose: _willEmitClose,
      kIsClosedPromise
    } = require_utils();
    var addAbortListener;
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    var nop2 = () => {
    };
    function eos(stream, options, callback) {
      var _options$readable, _options$writable;
      if (arguments.length === 2) {
        callback = options;
        options = kEmptyObject;
      } else if (options == null) {
        options = kEmptyObject;
      } else {
        validateObject(options, "options");
      }
      validateFunction(callback, "callback");
      validateAbortSignal(options.signal, "options.signal");
      callback = once(callback);
      if (isReadableStream(stream) || isWritableStream(stream)) {
        return eosWeb(stream, options, callback);
      }
      if (!isNodeStream(stream)) {
        throw new ERR_INVALID_ARG_TYPE("stream", ["ReadableStream", "WritableStream", "Stream"], stream);
      }
      const readable = (_options$readable = options.readable) !== null && _options$readable !== void 0 ? _options$readable : isReadableNodeStream(stream);
      const writable = (_options$writable = options.writable) !== null && _options$writable !== void 0 ? _options$writable : isWritableNodeStream(stream);
      const wState = stream._writableState;
      const rState = stream._readableState;
      const onlegacyfinish = () => {
        if (!stream.writable) {
          onfinish();
        }
      };
      let willEmitClose = _willEmitClose(stream) && isReadableNodeStream(stream) === readable && isWritableNodeStream(stream) === writable;
      let writableFinished = isWritableFinished(stream, false);
      const onfinish = () => {
        writableFinished = true;
        if (stream.destroyed) {
          willEmitClose = false;
        }
        if (willEmitClose && (!stream.readable || readable)) {
          return;
        }
        if (!readable || readableFinished) {
          callback.call(stream);
        }
      };
      let readableFinished = isReadableFinished(stream, false);
      const onend = () => {
        readableFinished = true;
        if (stream.destroyed) {
          willEmitClose = false;
        }
        if (willEmitClose && (!stream.writable || writable)) {
          return;
        }
        if (!writable || writableFinished) {
          callback.call(stream);
        }
      };
      const onerror = (err) => {
        callback.call(stream, err);
      };
      let closed = isClosed(stream);
      const onclose = () => {
        closed = true;
        const errored = isWritableErrored(stream) || isReadableErrored(stream);
        if (errored && typeof errored !== "boolean") {
          return callback.call(stream, errored);
        }
        if (readable && !readableFinished && isReadableNodeStream(stream, true)) {
          if (!isReadableFinished(stream, false)) return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE());
        }
        if (writable && !writableFinished) {
          if (!isWritableFinished(stream, false)) return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE());
        }
        callback.call(stream);
      };
      const onclosed = () => {
        closed = true;
        const errored = isWritableErrored(stream) || isReadableErrored(stream);
        if (errored && typeof errored !== "boolean") {
          return callback.call(stream, errored);
        }
        callback.call(stream);
      };
      const onrequest = () => {
        stream.req.on("finish", onfinish);
      };
      if (isRequest(stream)) {
        stream.on("complete", onfinish);
        if (!willEmitClose) {
          stream.on("abort", onclose);
        }
        if (stream.req) {
          onrequest();
        } else {
          stream.on("request", onrequest);
        }
      } else if (writable && !wState) {
        stream.on("end", onlegacyfinish);
        stream.on("close", onlegacyfinish);
      }
      if (!willEmitClose && typeof stream.aborted === "boolean") {
        stream.on("aborted", onclose);
      }
      stream.on("end", onend);
      stream.on("finish", onfinish);
      if (options.error !== false) {
        stream.on("error", onerror);
      }
      stream.on("close", onclose);
      if (closed) {
        process.nextTick(onclose);
      } else if (wState !== null && wState !== void 0 && wState.errorEmitted || rState !== null && rState !== void 0 && rState.errorEmitted) {
        if (!willEmitClose) {
          process.nextTick(onclosed);
        }
      } else if (!readable && (!willEmitClose || isReadable2(stream)) && (writableFinished || isWritable(stream) === false)) {
        process.nextTick(onclosed);
      } else if (!writable && (!willEmitClose || isWritable(stream)) && (readableFinished || isReadable2(stream) === false)) {
        process.nextTick(onclosed);
      } else if (rState && stream.req && stream.aborted) {
        process.nextTick(onclosed);
      }
      const cleanup = () => {
        callback = nop2;
        stream.removeListener("aborted", onclose);
        stream.removeListener("complete", onfinish);
        stream.removeListener("abort", onclose);
        stream.removeListener("request", onrequest);
        if (stream.req) stream.req.removeListener("finish", onfinish);
        stream.removeListener("end", onlegacyfinish);
        stream.removeListener("close", onlegacyfinish);
        stream.removeListener("finish", onfinish);
        stream.removeListener("end", onend);
        stream.removeListener("error", onerror);
        stream.removeListener("close", onclose);
      };
      if (options.signal && !closed) {
        const abort = () => {
          const endCallback = callback;
          cleanup();
          endCallback.call(
            stream,
            new AbortError(void 0, {
              cause: options.signal.reason
            })
          );
        };
        if (options.signal.aborted) {
          process.nextTick(abort);
        } else {
          addAbortListener = addAbortListener || require_util().addAbortListener;
          const disposable = addAbortListener(options.signal, abort);
          const originalCallback = callback;
          callback = once((...args) => {
            disposable[SymbolDispose]();
            originalCallback.apply(stream, args);
          });
        }
      }
      return cleanup;
    }
    function eosWeb(stream, options, callback) {
      let isAborted = false;
      let abort = nop2;
      if (options.signal) {
        abort = () => {
          isAborted = true;
          callback.call(
            stream,
            new AbortError(void 0, {
              cause: options.signal.reason
            })
          );
        };
        if (options.signal.aborted) {
          process.nextTick(abort);
        } else {
          addAbortListener = addAbortListener || require_util().addAbortListener;
          const disposable = addAbortListener(options.signal, abort);
          const originalCallback = callback;
          callback = once((...args) => {
            disposable[SymbolDispose]();
            originalCallback.apply(stream, args);
          });
        }
      }
      const resolverFn = (...args) => {
        if (!isAborted) {
          process.nextTick(() => callback.apply(stream, args));
        }
      };
      PromisePrototypeThen(stream[kIsClosedPromise].promise, resolverFn, resolverFn);
      return nop2;
    }
    function finished(stream, opts) {
      var _opts;
      let autoCleanup = false;
      if (opts === null) {
        opts = kEmptyObject;
      }
      if ((_opts = opts) !== null && _opts !== void 0 && _opts.cleanup) {
        validateBoolean(opts.cleanup, "cleanup");
        autoCleanup = opts.cleanup;
      }
      return new Promise2((resolve2, reject) => {
        const cleanup = eos(stream, opts, (err) => {
          if (autoCleanup) {
            cleanup();
          }
          if (err) {
            reject(err);
          } else {
            resolve2();
          }
        });
      });
    }
    module.exports = eos;
    module.exports.finished = finished;
  }
});

// node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/destroy.js"(exports, module) {
    "use strict";
    var process = require_browser2();
    var {
      aggregateTwoErrors,
      codes: { ERR_MULTIPLE_CALLBACK },
      AbortError
    } = require_errors();
    var { Symbol: Symbol2 } = require_primordials();
    var { kIsDestroyed, isDestroyed, isFinished, isServerRequest } = require_utils();
    var kDestroy = Symbol2("kDestroy");
    var kConstruct = Symbol2("kConstruct");
    function checkError(err, w, r) {
      if (err) {
        err.stack;
        if (w && !w.errored) {
          w.errored = err;
        }
        if (r && !r.errored) {
          r.errored = err;
        }
      }
    }
    function destroy(err, cb) {
      const r = this._readableState;
      const w = this._writableState;
      const s = w || r;
      if (w !== null && w !== void 0 && w.destroyed || r !== null && r !== void 0 && r.destroyed) {
        if (typeof cb === "function") {
          cb();
        }
        return this;
      }
      checkError(err, w, r);
      if (w) {
        w.destroyed = true;
      }
      if (r) {
        r.destroyed = true;
      }
      if (!s.constructed) {
        this.once(kDestroy, function(er) {
          _destroy(this, aggregateTwoErrors(er, err), cb);
        });
      } else {
        _destroy(this, err, cb);
      }
      return this;
    }
    function _destroy(self2, err, cb) {
      let called = false;
      function onDestroy(err2) {
        if (called) {
          return;
        }
        called = true;
        const r = self2._readableState;
        const w = self2._writableState;
        checkError(err2, w, r);
        if (w) {
          w.closed = true;
        }
        if (r) {
          r.closed = true;
        }
        if (typeof cb === "function") {
          cb(err2);
        }
        if (err2) {
          process.nextTick(emitErrorCloseNT, self2, err2);
        } else {
          process.nextTick(emitCloseNT, self2);
        }
      }
      try {
        self2._destroy(err || null, onDestroy);
      } catch (err2) {
        onDestroy(err2);
      }
    }
    function emitErrorCloseNT(self2, err) {
      emitErrorNT(self2, err);
      emitCloseNT(self2);
    }
    function emitCloseNT(self2) {
      const r = self2._readableState;
      const w = self2._writableState;
      if (w) {
        w.closeEmitted = true;
      }
      if (r) {
        r.closeEmitted = true;
      }
      if (w !== null && w !== void 0 && w.emitClose || r !== null && r !== void 0 && r.emitClose) {
        self2.emit("close");
      }
    }
    function emitErrorNT(self2, err) {
      const r = self2._readableState;
      const w = self2._writableState;
      if (w !== null && w !== void 0 && w.errorEmitted || r !== null && r !== void 0 && r.errorEmitted) {
        return;
      }
      if (w) {
        w.errorEmitted = true;
      }
      if (r) {
        r.errorEmitted = true;
      }
      self2.emit("error", err);
    }
    function undestroy() {
      const r = this._readableState;
      const w = this._writableState;
      if (r) {
        r.constructed = true;
        r.closed = false;
        r.closeEmitted = false;
        r.destroyed = false;
        r.errored = null;
        r.errorEmitted = false;
        r.reading = false;
        r.ended = r.readable === false;
        r.endEmitted = r.readable === false;
      }
      if (w) {
        w.constructed = true;
        w.destroyed = false;
        w.closed = false;
        w.closeEmitted = false;
        w.errored = null;
        w.errorEmitted = false;
        w.finalCalled = false;
        w.prefinished = false;
        w.ended = w.writable === false;
        w.ending = w.writable === false;
        w.finished = w.writable === false;
      }
    }
    function errorOrDestroy(stream, err, sync) {
      const r = stream._readableState;
      const w = stream._writableState;
      if (w !== null && w !== void 0 && w.destroyed || r !== null && r !== void 0 && r.destroyed) {
        return this;
      }
      if (r !== null && r !== void 0 && r.autoDestroy || w !== null && w !== void 0 && w.autoDestroy)
        stream.destroy(err);
      else if (err) {
        err.stack;
        if (w && !w.errored) {
          w.errored = err;
        }
        if (r && !r.errored) {
          r.errored = err;
        }
        if (sync) {
          process.nextTick(emitErrorNT, stream, err);
        } else {
          emitErrorNT(stream, err);
        }
      }
    }
    function construct(stream, cb) {
      if (typeof stream._construct !== "function") {
        return;
      }
      const r = stream._readableState;
      const w = stream._writableState;
      if (r) {
        r.constructed = false;
      }
      if (w) {
        w.constructed = false;
      }
      stream.once(kConstruct, cb);
      if (stream.listenerCount(kConstruct) > 1) {
        return;
      }
      process.nextTick(constructNT, stream);
    }
    function constructNT(stream) {
      let called = false;
      function onConstruct(err) {
        if (called) {
          errorOrDestroy(stream, err !== null && err !== void 0 ? err : new ERR_MULTIPLE_CALLBACK());
          return;
        }
        called = true;
        const r = stream._readableState;
        const w = stream._writableState;
        const s = w || r;
        if (r) {
          r.constructed = true;
        }
        if (w) {
          w.constructed = true;
        }
        if (s.destroyed) {
          stream.emit(kDestroy, err);
        } else if (err) {
          errorOrDestroy(stream, err, true);
        } else {
          process.nextTick(emitConstructNT, stream);
        }
      }
      try {
        stream._construct((err) => {
          process.nextTick(onConstruct, err);
        });
      } catch (err) {
        process.nextTick(onConstruct, err);
      }
    }
    function emitConstructNT(stream) {
      stream.emit(kConstruct);
    }
    function isRequest(stream) {
      return (stream === null || stream === void 0 ? void 0 : stream.setHeader) && typeof stream.abort === "function";
    }
    function emitCloseLegacy(stream) {
      stream.emit("close");
    }
    function emitErrorCloseLegacy(stream, err) {
      stream.emit("error", err);
      process.nextTick(emitCloseLegacy, stream);
    }
    function destroyer(stream, err) {
      if (!stream || isDestroyed(stream)) {
        return;
      }
      if (!err && !isFinished(stream)) {
        err = new AbortError();
      }
      if (isServerRequest(stream)) {
        stream.socket = null;
        stream.destroy(err);
      } else if (isRequest(stream)) {
        stream.abort();
      } else if (isRequest(stream.req)) {
        stream.req.abort();
      } else if (typeof stream.destroy === "function") {
        stream.destroy(err);
      } else if (typeof stream.close === "function") {
        stream.close();
      } else if (err) {
        process.nextTick(emitErrorCloseLegacy, stream, err);
      } else {
        process.nextTick(emitCloseLegacy, stream);
      }
      if (!stream.destroyed) {
        stream[kIsDestroyed] = true;
      }
    }
    module.exports = {
      construct,
      destroyer,
      destroy,
      undestroy,
      errorOrDestroy
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/legacy.js
var require_legacy = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/legacy.js"(exports, module) {
    "use strict";
    var { ArrayIsArray, ObjectSetPrototypeOf } = require_primordials();
    var { EventEmitter: EE } = require_events();
    function Stream(opts) {
      EE.call(this, opts);
    }
    ObjectSetPrototypeOf(Stream.prototype, EE.prototype);
    ObjectSetPrototypeOf(Stream, EE);
    Stream.prototype.pipe = function(dest, options) {
      const source = this;
      function ondata(chunk) {
        if (dest.writable && dest.write(chunk) === false && source.pause) {
          source.pause();
        }
      }
      source.on("data", ondata);
      function ondrain() {
        if (source.readable && source.resume) {
          source.resume();
        }
      }
      dest.on("drain", ondrain);
      if (!dest._isStdio && (!options || options.end !== false)) {
        source.on("end", onend);
        source.on("close", onclose);
      }
      let didOnEnd = false;
      function onend() {
        if (didOnEnd) return;
        didOnEnd = true;
        dest.end();
      }
      function onclose() {
        if (didOnEnd) return;
        didOnEnd = true;
        if (typeof dest.destroy === "function") dest.destroy();
      }
      function onerror(er) {
        cleanup();
        if (EE.listenerCount(this, "error") === 0) {
          this.emit("error", er);
        }
      }
      prependListener(source, "error", onerror);
      prependListener(dest, "error", onerror);
      function cleanup() {
        source.removeListener("data", ondata);
        dest.removeListener("drain", ondrain);
        source.removeListener("end", onend);
        source.removeListener("close", onclose);
        source.removeListener("error", onerror);
        dest.removeListener("error", onerror);
        source.removeListener("end", cleanup);
        source.removeListener("close", cleanup);
        dest.removeListener("close", cleanup);
      }
      source.on("end", cleanup);
      source.on("close", cleanup);
      dest.on("close", cleanup);
      dest.emit("pipe", source);
      return dest;
    };
    function prependListener(emitter, event, fn) {
      if (typeof emitter.prependListener === "function") return emitter.prependListener(event, fn);
      if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);
      else if (ArrayIsArray(emitter._events[event])) emitter._events[event].unshift(fn);
      else emitter._events[event] = [fn, emitter._events[event]];
    }
    module.exports = {
      Stream,
      prependListener
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/add-abort-signal.js
var require_add_abort_signal = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/add-abort-signal.js"(exports, module) {
    "use strict";
    var { SymbolDispose } = require_primordials();
    var { AbortError, codes } = require_errors();
    var { isNodeStream, isWebStream, kControllerErrorFunction } = require_utils();
    var eos = require_end_of_stream();
    var { ERR_INVALID_ARG_TYPE } = codes;
    var addAbortListener;
    var validateAbortSignal = (signal, name) => {
      if (typeof signal !== "object" || !("aborted" in signal)) {
        throw new ERR_INVALID_ARG_TYPE(name, "AbortSignal", signal);
      }
    };
    module.exports.addAbortSignal = function addAbortSignal(signal, stream) {
      validateAbortSignal(signal, "signal");
      if (!isNodeStream(stream) && !isWebStream(stream)) {
        throw new ERR_INVALID_ARG_TYPE("stream", ["ReadableStream", "WritableStream", "Stream"], stream);
      }
      return module.exports.addAbortSignalNoValidate(signal, stream);
    };
    module.exports.addAbortSignalNoValidate = function(signal, stream) {
      if (typeof signal !== "object" || !("aborted" in signal)) {
        return stream;
      }
      const onAbort = isNodeStream(stream) ? () => {
        stream.destroy(
          new AbortError(void 0, {
            cause: signal.reason
          })
        );
      } : () => {
        stream[kControllerErrorFunction](
          new AbortError(void 0, {
            cause: signal.reason
          })
        );
      };
      if (signal.aborted) {
        onAbort();
      } else {
        addAbortListener = addAbortListener || require_util().addAbortListener;
        const disposable = addAbortListener(signal, onAbort);
        eos(stream, disposable[SymbolDispose]);
      }
      return stream;
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/buffer_list.js
var require_buffer_list = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/buffer_list.js"(exports, module) {
    "use strict";
    var { StringPrototypeSlice, SymbolIterator, TypedArrayPrototypeSet, Uint8Array: Uint8Array2 } = require_primordials();
    var { Buffer: Buffer4 } = require_buffer();
    var { inspect } = require_util();
    module.exports = class BufferList {
      constructor() {
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      push(v) {
        const entry = {
          data: v,
          next: null
        };
        if (this.length > 0) this.tail.next = entry;
        else this.head = entry;
        this.tail = entry;
        ++this.length;
      }
      unshift(v) {
        const entry = {
          data: v,
          next: this.head
        };
        if (this.length === 0) this.tail = entry;
        this.head = entry;
        ++this.length;
      }
      shift() {
        if (this.length === 0) return;
        const ret = this.head.data;
        if (this.length === 1) this.head = this.tail = null;
        else this.head = this.head.next;
        --this.length;
        return ret;
      }
      clear() {
        this.head = this.tail = null;
        this.length = 0;
      }
      join(s) {
        if (this.length === 0) return "";
        let p = this.head;
        let ret = "" + p.data;
        while ((p = p.next) !== null) ret += s + p.data;
        return ret;
      }
      concat(n) {
        if (this.length === 0) return Buffer4.alloc(0);
        const ret = Buffer4.allocUnsafe(n >>> 0);
        let p = this.head;
        let i = 0;
        while (p) {
          TypedArrayPrototypeSet(ret, p.data, i);
          i += p.data.length;
          p = p.next;
        }
        return ret;
      }
      // Consumes a specified amount of bytes or characters from the buffered data.
      consume(n, hasStrings) {
        const data = this.head.data;
        if (n < data.length) {
          const slice = data.slice(0, n);
          this.head.data = data.slice(n);
          return slice;
        }
        if (n === data.length) {
          return this.shift();
        }
        return hasStrings ? this._getString(n) : this._getBuffer(n);
      }
      first() {
        return this.head.data;
      }
      *[SymbolIterator]() {
        for (let p = this.head; p; p = p.next) {
          yield p.data;
        }
      }
      // Consumes a specified amount of characters from the buffered data.
      _getString(n) {
        let ret = "";
        let p = this.head;
        let c = 0;
        do {
          const str = p.data;
          if (n > str.length) {
            ret += str;
            n -= str.length;
          } else {
            if (n === str.length) {
              ret += str;
              ++c;
              if (p.next) this.head = p.next;
              else this.head = this.tail = null;
            } else {
              ret += StringPrototypeSlice(str, 0, n);
              this.head = p;
              p.data = StringPrototypeSlice(str, n);
            }
            break;
          }
          ++c;
        } while ((p = p.next) !== null);
        this.length -= c;
        return ret;
      }
      // Consumes a specified amount of bytes from the buffered data.
      _getBuffer(n) {
        const ret = Buffer4.allocUnsafe(n);
        const retLen = n;
        let p = this.head;
        let c = 0;
        do {
          const buf = p.data;
          if (n > buf.length) {
            TypedArrayPrototypeSet(ret, buf, retLen - n);
            n -= buf.length;
          } else {
            if (n === buf.length) {
              TypedArrayPrototypeSet(ret, buf, retLen - n);
              ++c;
              if (p.next) this.head = p.next;
              else this.head = this.tail = null;
            } else {
              TypedArrayPrototypeSet(ret, new Uint8Array2(buf.buffer, buf.byteOffset, n), retLen - n);
              this.head = p;
              p.data = buf.slice(n);
            }
            break;
          }
          ++c;
        } while ((p = p.next) !== null);
        this.length -= c;
        return ret;
      }
      // Make sure the linked list only shows the minimal necessary information.
      [Symbol.for("nodejs.util.inspect.custom")](_, options) {
        return inspect(this, {
          ...options,
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: false
        });
      }
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/state.js
var require_state = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/state.js"(exports, module) {
    "use strict";
    var { MathFloor, NumberIsInteger } = require_primordials();
    var { validateInteger } = require_validators();
    var { ERR_INVALID_ARG_VALUE } = require_errors().codes;
    var defaultHighWaterMarkBytes = 16 * 1024;
    var defaultHighWaterMarkObjectMode = 16;
    function highWaterMarkFrom(options, isDuplex, duplexKey) {
      return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
    }
    function getDefaultHighWaterMark(objectMode) {
      return objectMode ? defaultHighWaterMarkObjectMode : defaultHighWaterMarkBytes;
    }
    function setDefaultHighWaterMark(objectMode, value) {
      validateInteger(value, "value", 0);
      if (objectMode) {
        defaultHighWaterMarkObjectMode = value;
      } else {
        defaultHighWaterMarkBytes = value;
      }
    }
    function getHighWaterMark(state, options, duplexKey, isDuplex) {
      const hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
      if (hwm != null) {
        if (!NumberIsInteger(hwm) || hwm < 0) {
          const name = isDuplex ? `options.${duplexKey}` : "options.highWaterMark";
          throw new ERR_INVALID_ARG_VALUE(name, hwm);
        }
        return MathFloor(hwm);
      }
      return getDefaultHighWaterMark(state.objectMode);
    }
    module.exports = {
      getHighWaterMark,
      getDefaultHighWaterMark,
      setDefaultHighWaterMark
    };
  }
});

// node_modules/string_decoder/node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  "node_modules/string_decoder/node_modules/safe-buffer/index.js"(exports, module) {
    var buffer = require_buffer();
    var Buffer4 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer4.from && Buffer4.alloc && Buffer4.allocUnsafe && Buffer4.allocUnsafeSlow) {
      module.exports = buffer;
    } else {
      copyProps(buffer, exports);
      exports.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer4(arg, encodingOrOffset, length);
    }
    SafeBuffer.prototype = Object.create(Buffer4.prototype);
    copyProps(Buffer4, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer4(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer4(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer4(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// node_modules/string_decoder/lib/string_decoder.js
var require_string_decoder = __commonJS({
  "node_modules/string_decoder/lib/string_decoder.js"(exports) {
    "use strict";
    var Buffer4 = require_safe_buffer().Buffer;
    var isEncoding = Buffer4.isEncoding || function(encoding) {
      encoding = "" + encoding;
      switch (encoding && encoding.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function _normalizeEncoding(enc) {
      if (!enc) return "utf8";
      var retried;
      while (true) {
        switch (enc) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return enc;
          default:
            if (retried) return;
            enc = ("" + enc).toLowerCase();
            retried = true;
        }
      }
    }
    function normalizeEncoding(enc) {
      var nenc = _normalizeEncoding(enc);
      if (typeof nenc !== "string" && (Buffer4.isEncoding === isEncoding || !isEncoding(enc))) throw new Error("Unknown encoding: " + enc);
      return nenc || enc;
    }
    exports.StringDecoder = StringDecoder;
    function StringDecoder(encoding) {
      this.encoding = normalizeEncoding(encoding);
      var nb;
      switch (this.encoding) {
        case "utf16le":
          this.text = utf16Text;
          this.end = utf16End;
          nb = 4;
          break;
        case "utf8":
          this.fillLast = utf8FillLast;
          nb = 4;
          break;
        case "base64":
          this.text = base64Text;
          this.end = base64End;
          nb = 3;
          break;
        default:
          this.write = simpleWrite;
          this.end = simpleEnd;
          return;
      }
      this.lastNeed = 0;
      this.lastTotal = 0;
      this.lastChar = Buffer4.allocUnsafe(nb);
    }
    StringDecoder.prototype.write = function(buf) {
      if (buf.length === 0) return "";
      var r;
      var i;
      if (this.lastNeed) {
        r = this.fillLast(buf);
        if (r === void 0) return "";
        i = this.lastNeed;
        this.lastNeed = 0;
      } else {
        i = 0;
      }
      if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
      return r || "";
    };
    StringDecoder.prototype.end = utf8End;
    StringDecoder.prototype.text = utf8Text;
    StringDecoder.prototype.fillLast = function(buf) {
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
      this.lastNeed -= buf.length;
    };
    function utf8CheckByte(byte) {
      if (byte <= 127) return 0;
      else if (byte >> 5 === 6) return 2;
      else if (byte >> 4 === 14) return 3;
      else if (byte >> 3 === 30) return 4;
      return byte >> 6 === 2 ? -1 : -2;
    }
    function utf8CheckIncomplete(self2, buf, i) {
      var j = buf.length - 1;
      if (j < i) return 0;
      var nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) self2.lastNeed = nb - 1;
        return nb;
      }
      if (--j < i || nb === -2) return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) self2.lastNeed = nb - 2;
        return nb;
      }
      if (--j < i || nb === -2) return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) {
          if (nb === 2) nb = 0;
          else self2.lastNeed = nb - 3;
        }
        return nb;
      }
      return 0;
    }
    function utf8CheckExtraBytes(self2, buf, p) {
      if ((buf[0] & 192) !== 128) {
        self2.lastNeed = 0;
        return "�";
      }
      if (self2.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 192) !== 128) {
          self2.lastNeed = 1;
          return "�";
        }
        if (self2.lastNeed > 2 && buf.length > 2) {
          if ((buf[2] & 192) !== 128) {
            self2.lastNeed = 2;
            return "�";
          }
        }
      }
    }
    function utf8FillLast(buf) {
      var p = this.lastTotal - this.lastNeed;
      var r = utf8CheckExtraBytes(this, buf, p);
      if (r !== void 0) return r;
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, p, 0, buf.length);
      this.lastNeed -= buf.length;
    }
    function utf8Text(buf, i) {
      var total = utf8CheckIncomplete(this, buf, i);
      if (!this.lastNeed) return buf.toString("utf8", i);
      this.lastTotal = total;
      var end = buf.length - (total - this.lastNeed);
      buf.copy(this.lastChar, 0, end);
      return buf.toString("utf8", i, end);
    }
    function utf8End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) return r + "�";
      return r;
    }
    function utf16Text(buf, i) {
      if ((buf.length - i) % 2 === 0) {
        var r = buf.toString("utf16le", i);
        if (r) {
          var c = r.charCodeAt(r.length - 1);
          if (c >= 55296 && c <= 56319) {
            this.lastNeed = 2;
            this.lastTotal = 4;
            this.lastChar[0] = buf[buf.length - 2];
            this.lastChar[1] = buf[buf.length - 1];
            return r.slice(0, -1);
          }
        }
        return r;
      }
      this.lastNeed = 1;
      this.lastTotal = 2;
      this.lastChar[0] = buf[buf.length - 1];
      return buf.toString("utf16le", i, buf.length - 1);
    }
    function utf16End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r + this.lastChar.toString("utf16le", 0, end);
      }
      return r;
    }
    function base64Text(buf, i) {
      var n = (buf.length - i) % 3;
      if (n === 0) return buf.toString("base64", i);
      this.lastNeed = 3 - n;
      this.lastTotal = 3;
      if (n === 1) {
        this.lastChar[0] = buf[buf.length - 1];
      } else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
      }
      return buf.toString("base64", i, buf.length - n);
    }
    function base64End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
      return r;
    }
    function simpleWrite(buf) {
      return buf.toString(this.encoding);
    }
    function simpleEnd(buf) {
      return buf && buf.length ? this.write(buf) : "";
    }
  }
});

// node_modules/readable-stream/lib/internal/streams/from.js
var require_from = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/from.js"(exports, module) {
    "use strict";
    var process = require_browser2();
    var { PromisePrototypeThen, SymbolAsyncIterator, SymbolIterator } = require_primordials();
    var { Buffer: Buffer4 } = require_buffer();
    var { ERR_INVALID_ARG_TYPE, ERR_STREAM_NULL_VALUES } = require_errors().codes;
    function from(Readable2, iterable, opts) {
      let iterator;
      if (typeof iterable === "string" || iterable instanceof Buffer4) {
        return new Readable2({
          objectMode: true,
          ...opts,
          read() {
            this.push(iterable);
            this.push(null);
          }
        });
      }
      let isAsync;
      if (iterable && iterable[SymbolAsyncIterator]) {
        isAsync = true;
        iterator = iterable[SymbolAsyncIterator]();
      } else if (iterable && iterable[SymbolIterator]) {
        isAsync = false;
        iterator = iterable[SymbolIterator]();
      } else {
        throw new ERR_INVALID_ARG_TYPE("iterable", ["Iterable"], iterable);
      }
      const readable = new Readable2({
        objectMode: true,
        highWaterMark: 1,
        // TODO(ronag): What options should be allowed?
        ...opts
      });
      let reading = false;
      readable._read = function() {
        if (!reading) {
          reading = true;
          next();
        }
      };
      readable._destroy = function(error, cb) {
        PromisePrototypeThen(
          close2(error),
          () => process.nextTick(cb, error),
          // nextTick is here in case cb throws
          (e) => process.nextTick(cb, e || error)
        );
      };
      async function close2(error) {
        const hadError = error !== void 0 && error !== null;
        const hasThrow = typeof iterator.throw === "function";
        if (hadError && hasThrow) {
          const { value, done } = await iterator.throw(error);
          await value;
          if (done) {
            return;
          }
        }
        if (typeof iterator.return === "function") {
          const { value } = await iterator.return();
          await value;
        }
      }
      async function next() {
        for (; ; ) {
          try {
            const { value, done } = isAsync ? await iterator.next() : iterator.next();
            if (done) {
              readable.push(null);
            } else {
              const res = value && typeof value.then === "function" ? await value : value;
              if (res === null) {
                reading = false;
                throw new ERR_STREAM_NULL_VALUES();
              } else if (readable.push(res)) {
                continue;
              } else {
                reading = false;
              }
            }
          } catch (err) {
            readable.destroy(err);
          }
          break;
        }
      }
      return readable;
    }
    module.exports = from;
  }
});

// node_modules/readable-stream/lib/internal/streams/readable.js
var require_readable = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/readable.js"(exports, module) {
    "use strict";
    var process = require_browser2();
    var {
      ArrayPrototypeIndexOf,
      NumberIsInteger,
      NumberIsNaN,
      NumberParseInt,
      ObjectDefineProperties,
      ObjectKeys,
      ObjectSetPrototypeOf,
      Promise: Promise2,
      SafeSet,
      SymbolAsyncDispose,
      SymbolAsyncIterator,
      Symbol: Symbol2
    } = require_primordials();
    module.exports = Readable2;
    Readable2.ReadableState = ReadableState;
    var { EventEmitter: EE } = require_events();
    var { Stream, prependListener } = require_legacy();
    var { Buffer: Buffer4 } = require_buffer();
    var { addAbortSignal } = require_add_abort_signal();
    var eos = require_end_of_stream();
    var debug = require_util().debuglog("stream", (fn) => {
      debug = fn;
    });
    var BufferList = require_buffer_list();
    var destroyImpl = require_destroy();
    var { getHighWaterMark, getDefaultHighWaterMark } = require_state();
    var {
      aggregateTwoErrors,
      codes: {
        ERR_INVALID_ARG_TYPE,
        ERR_METHOD_NOT_IMPLEMENTED,
        ERR_OUT_OF_RANGE,
        ERR_STREAM_PUSH_AFTER_EOF,
        ERR_STREAM_UNSHIFT_AFTER_END_EVENT
      },
      AbortError
    } = require_errors();
    var { validateObject } = require_validators();
    var kPaused = Symbol2("kPaused");
    var { StringDecoder } = require_string_decoder();
    var from = require_from();
    ObjectSetPrototypeOf(Readable2.prototype, Stream.prototype);
    ObjectSetPrototypeOf(Readable2, Stream);
    var nop2 = () => {
    };
    var { errorOrDestroy } = destroyImpl;
    var kObjectMode = 1 << 0;
    var kEnded = 1 << 1;
    var kEndEmitted = 1 << 2;
    var kReading = 1 << 3;
    var kConstructed = 1 << 4;
    var kSync = 1 << 5;
    var kNeedReadable = 1 << 6;
    var kEmittedReadable = 1 << 7;
    var kReadableListening = 1 << 8;
    var kResumeScheduled = 1 << 9;
    var kErrorEmitted = 1 << 10;
    var kEmitClose = 1 << 11;
    var kAutoDestroy = 1 << 12;
    var kDestroyed = 1 << 13;
    var kClosed = 1 << 14;
    var kCloseEmitted = 1 << 15;
    var kMultiAwaitDrain = 1 << 16;
    var kReadingMore = 1 << 17;
    var kDataEmitted = 1 << 18;
    function makeBitMapDescriptor(bit) {
      return {
        enumerable: false,
        get() {
          return (this.state & bit) !== 0;
        },
        set(value) {
          if (value) this.state |= bit;
          else this.state &= ~bit;
        }
      };
    }
    ObjectDefineProperties(ReadableState.prototype, {
      objectMode: makeBitMapDescriptor(kObjectMode),
      ended: makeBitMapDescriptor(kEnded),
      endEmitted: makeBitMapDescriptor(kEndEmitted),
      reading: makeBitMapDescriptor(kReading),
      // Stream is still being constructed and cannot be
      // destroyed until construction finished or failed.
      // Async construction is opt in, therefore we start as
      // constructed.
      constructed: makeBitMapDescriptor(kConstructed),
      // A flag to be able to tell if the event 'readable'/'data' is emitted
      // immediately, or on a later tick.  We set this to true at first, because
      // any actions that shouldn't happen until "later" should generally also
      // not happen before the first read call.
      sync: makeBitMapDescriptor(kSync),
      // Whenever we return null, then we set a flag to say
      // that we're awaiting a 'readable' event emission.
      needReadable: makeBitMapDescriptor(kNeedReadable),
      emittedReadable: makeBitMapDescriptor(kEmittedReadable),
      readableListening: makeBitMapDescriptor(kReadableListening),
      resumeScheduled: makeBitMapDescriptor(kResumeScheduled),
      // True if the error was already emitted and should not be thrown again.
      errorEmitted: makeBitMapDescriptor(kErrorEmitted),
      emitClose: makeBitMapDescriptor(kEmitClose),
      autoDestroy: makeBitMapDescriptor(kAutoDestroy),
      // Has it been destroyed.
      destroyed: makeBitMapDescriptor(kDestroyed),
      // Indicates whether the stream has finished destroying.
      closed: makeBitMapDescriptor(kClosed),
      // True if close has been emitted or would have been emitted
      // depending on emitClose.
      closeEmitted: makeBitMapDescriptor(kCloseEmitted),
      multiAwaitDrain: makeBitMapDescriptor(kMultiAwaitDrain),
      // If true, a maybeReadMore has been scheduled.
      readingMore: makeBitMapDescriptor(kReadingMore),
      dataEmitted: makeBitMapDescriptor(kDataEmitted)
    });
    function ReadableState(options, stream, isDuplex) {
      if (typeof isDuplex !== "boolean") isDuplex = stream instanceof require_duplex();
      this.state = kEmitClose | kAutoDestroy | kConstructed | kSync;
      if (options && options.objectMode) this.state |= kObjectMode;
      if (isDuplex && options && options.readableObjectMode) this.state |= kObjectMode;
      this.highWaterMark = options ? getHighWaterMark(this, options, "readableHighWaterMark", isDuplex) : getDefaultHighWaterMark(false);
      this.buffer = new BufferList();
      this.length = 0;
      this.pipes = [];
      this.flowing = null;
      this[kPaused] = null;
      if (options && options.emitClose === false) this.state &= ~kEmitClose;
      if (options && options.autoDestroy === false) this.state &= ~kAutoDestroy;
      this.errored = null;
      this.defaultEncoding = options && options.defaultEncoding || "utf8";
      this.awaitDrainWriters = null;
      this.decoder = null;
      this.encoding = null;
      if (options && options.encoding) {
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    function Readable2(options) {
      if (!(this instanceof Readable2)) return new Readable2(options);
      const isDuplex = this instanceof require_duplex();
      this._readableState = new ReadableState(options, this, isDuplex);
      if (options) {
        if (typeof options.read === "function") this._read = options.read;
        if (typeof options.destroy === "function") this._destroy = options.destroy;
        if (typeof options.construct === "function") this._construct = options.construct;
        if (options.signal && !isDuplex) addAbortSignal(options.signal, this);
      }
      Stream.call(this, options);
      destroyImpl.construct(this, () => {
        if (this._readableState.needReadable) {
          maybeReadMore(this, this._readableState);
        }
      });
    }
    Readable2.prototype.destroy = destroyImpl.destroy;
    Readable2.prototype._undestroy = destroyImpl.undestroy;
    Readable2.prototype._destroy = function(err, cb) {
      cb(err);
    };
    Readable2.prototype[EE.captureRejectionSymbol] = function(err) {
      this.destroy(err);
    };
    Readable2.prototype[SymbolAsyncDispose] = function() {
      let error;
      if (!this.destroyed) {
        error = this.readableEnded ? null : new AbortError();
        this.destroy(error);
      }
      return new Promise2((resolve2, reject) => eos(this, (err) => err && err !== error ? reject(err) : resolve2(null)));
    };
    Readable2.prototype.push = function(chunk, encoding) {
      return readableAddChunk(this, chunk, encoding, false);
    };
    Readable2.prototype.unshift = function(chunk, encoding) {
      return readableAddChunk(this, chunk, encoding, true);
    };
    function readableAddChunk(stream, chunk, encoding, addToFront) {
      debug("readableAddChunk", chunk);
      const state = stream._readableState;
      let err;
      if ((state.state & kObjectMode) === 0) {
        if (typeof chunk === "string") {
          encoding = encoding || state.defaultEncoding;
          if (state.encoding !== encoding) {
            if (addToFront && state.encoding) {
              chunk = Buffer4.from(chunk, encoding).toString(state.encoding);
            } else {
              chunk = Buffer4.from(chunk, encoding);
              encoding = "";
            }
          }
        } else if (chunk instanceof Buffer4) {
          encoding = "";
        } else if (Stream._isUint8Array(chunk)) {
          chunk = Stream._uint8ArrayToBuffer(chunk);
          encoding = "";
        } else if (chunk != null) {
          err = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
        }
      }
      if (err) {
        errorOrDestroy(stream, err);
      } else if (chunk === null) {
        state.state &= ~kReading;
        onEofChunk(stream, state);
      } else if ((state.state & kObjectMode) !== 0 || chunk && chunk.length > 0) {
        if (addToFront) {
          if ((state.state & kEndEmitted) !== 0) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
          else if (state.destroyed || state.errored) return false;
          else addChunk(stream, state, chunk, true);
        } else if (state.ended) {
          errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
        } else if (state.destroyed || state.errored) {
          return false;
        } else {
          state.state &= ~kReading;
          if (state.decoder && !encoding) {
            chunk = state.decoder.write(chunk);
            if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);
            else maybeReadMore(stream, state);
          } else {
            addChunk(stream, state, chunk, false);
          }
        }
      } else if (!addToFront) {
        state.state &= ~kReading;
        maybeReadMore(stream, state);
      }
      return !state.ended && (state.length < state.highWaterMark || state.length === 0);
    }
    function addChunk(stream, state, chunk, addToFront) {
      if (state.flowing && state.length === 0 && !state.sync && stream.listenerCount("data") > 0) {
        if ((state.state & kMultiAwaitDrain) !== 0) {
          state.awaitDrainWriters.clear();
        } else {
          state.awaitDrainWriters = null;
        }
        state.dataEmitted = true;
        stream.emit("data", chunk);
      } else {
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront) state.buffer.unshift(chunk);
        else state.buffer.push(chunk);
        if ((state.state & kNeedReadable) !== 0) emitReadable(stream);
      }
      maybeReadMore(stream, state);
    }
    Readable2.prototype.isPaused = function() {
      const state = this._readableState;
      return state[kPaused] === true || state.flowing === false;
    };
    Readable2.prototype.setEncoding = function(enc) {
      const decoder2 = new StringDecoder(enc);
      this._readableState.decoder = decoder2;
      this._readableState.encoding = this._readableState.decoder.encoding;
      const buffer = this._readableState.buffer;
      let content = "";
      for (const data of buffer) {
        content += decoder2.write(data);
      }
      buffer.clear();
      if (content !== "") buffer.push(content);
      this._readableState.length = content.length;
      return this;
    };
    var MAX_HWM = 1073741824;
    function computeNewHighWaterMark(n) {
      if (n > MAX_HWM) {
        throw new ERR_OUT_OF_RANGE("size", "<= 1GiB", n);
      } else {
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
      }
      return n;
    }
    function howMuchToRead(n, state) {
      if (n <= 0 || state.length === 0 && state.ended) return 0;
      if ((state.state & kObjectMode) !== 0) return 1;
      if (NumberIsNaN(n)) {
        if (state.flowing && state.length) return state.buffer.first().length;
        return state.length;
      }
      if (n <= state.length) return n;
      return state.ended ? state.length : 0;
    }
    Readable2.prototype.read = function(n) {
      debug("read", n);
      if (n === void 0) {
        n = NaN;
      } else if (!NumberIsInteger(n)) {
        n = NumberParseInt(n, 10);
      }
      const state = this._readableState;
      const nOrig = n;
      if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
      if (n !== 0) state.state &= ~kEmittedReadable;
      if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended) endReadable(this);
        else emitReadable(this);
        return null;
      }
      n = howMuchToRead(n, state);
      if (n === 0 && state.ended) {
        if (state.length === 0) endReadable(this);
        return null;
      }
      let doRead = (state.state & kNeedReadable) !== 0;
      debug("need readable", doRead);
      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
      }
      if (state.ended || state.reading || state.destroyed || state.errored || !state.constructed) {
        doRead = false;
        debug("reading, ended or constructing", doRead);
      } else if (doRead) {
        debug("do read");
        state.state |= kReading | kSync;
        if (state.length === 0) state.state |= kNeedReadable;
        try {
          this._read(state.highWaterMark);
        } catch (err) {
          errorOrDestroy(this, err);
        }
        state.state &= ~kSync;
        if (!state.reading) n = howMuchToRead(nOrig, state);
      }
      let ret;
      if (n > 0) ret = fromList(n, state);
      else ret = null;
      if (ret === null) {
        state.needReadable = state.length <= state.highWaterMark;
        n = 0;
      } else {
        state.length -= n;
        if (state.multiAwaitDrain) {
          state.awaitDrainWriters.clear();
        } else {
          state.awaitDrainWriters = null;
        }
      }
      if (state.length === 0) {
        if (!state.ended) state.needReadable = true;
        if (nOrig !== n && state.ended) endReadable(this);
      }
      if (ret !== null && !state.errorEmitted && !state.closeEmitted) {
        state.dataEmitted = true;
        this.emit("data", ret);
      }
      return ret;
    };
    function onEofChunk(stream, state) {
      debug("onEofChunk");
      if (state.ended) return;
      if (state.decoder) {
        const chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      if (state.sync) {
        emitReadable(stream);
      } else {
        state.needReadable = false;
        state.emittedReadable = true;
        emitReadable_(stream);
      }
    }
    function emitReadable(stream) {
      const state = stream._readableState;
      debug("emitReadable", state.needReadable, state.emittedReadable);
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug("emitReadable", state.flowing);
        state.emittedReadable = true;
        process.nextTick(emitReadable_, stream);
      }
    }
    function emitReadable_(stream) {
      const state = stream._readableState;
      debug("emitReadable_", state.destroyed, state.length, state.ended);
      if (!state.destroyed && !state.errored && (state.length || state.ended)) {
        stream.emit("readable");
        state.emittedReadable = false;
      }
      state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
      flow(stream);
    }
    function maybeReadMore(stream, state) {
      if (!state.readingMore && state.constructed) {
        state.readingMore = true;
        process.nextTick(maybeReadMore_, stream, state);
      }
    }
    function maybeReadMore_(stream, state) {
      while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
        const len = state.length;
        debug("maybeReadMore read 0");
        stream.read(0);
        if (len === state.length)
          break;
      }
      state.readingMore = false;
    }
    Readable2.prototype._read = function(n) {
      throw new ERR_METHOD_NOT_IMPLEMENTED("_read()");
    };
    Readable2.prototype.pipe = function(dest, pipeOpts) {
      const src = this;
      const state = this._readableState;
      if (state.pipes.length === 1) {
        if (!state.multiAwaitDrain) {
          state.multiAwaitDrain = true;
          state.awaitDrainWriters = new SafeSet(state.awaitDrainWriters ? [state.awaitDrainWriters] : []);
        }
      }
      state.pipes.push(dest);
      debug("pipe count=%d opts=%j", state.pipes.length, pipeOpts);
      const doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
      const endFn = doEnd ? onend : unpipe;
      if (state.endEmitted) process.nextTick(endFn);
      else src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        debug("onunpipe");
        if (readable === src) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
            unpipeInfo.hasUnpiped = true;
            cleanup();
          }
        }
      }
      function onend() {
        debug("onend");
        dest.end();
      }
      let ondrain;
      let cleanedUp = false;
      function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        if (ondrain) {
          dest.removeListener("drain", ondrain);
        }
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (ondrain && state.awaitDrainWriters && (!dest._writableState || dest._writableState.needDrain)) ondrain();
      }
      function pause() {
        if (!cleanedUp) {
          if (state.pipes.length === 1 && state.pipes[0] === dest) {
            debug("false write response, pause", 0);
            state.awaitDrainWriters = dest;
            state.multiAwaitDrain = false;
          } else if (state.pipes.length > 1 && state.pipes.includes(dest)) {
            debug("false write response, pause", state.awaitDrainWriters.size);
            state.awaitDrainWriters.add(dest);
          }
          src.pause();
        }
        if (!ondrain) {
          ondrain = pipeOnDrain(src, dest);
          dest.on("drain", ondrain);
        }
      }
      src.on("data", ondata);
      function ondata(chunk) {
        debug("ondata");
        const ret = dest.write(chunk);
        debug("dest.write", ret);
        if (ret === false) {
          pause();
        }
      }
      function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (dest.listenerCount("error") === 0) {
          const s = dest._writableState || dest._readableState;
          if (s && !s.errorEmitted) {
            errorOrDestroy(dest, er);
          } else {
            dest.emit("error", er);
          }
        }
      }
      prependListener(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
      }
      dest.emit("pipe", src);
      if (dest.writableNeedDrain === true) {
        pause();
      } else if (!state.flowing) {
        debug("pipe resume");
        src.resume();
      }
      return dest;
    };
    function pipeOnDrain(src, dest) {
      return function pipeOnDrainFunctionResult() {
        const state = src._readableState;
        if (state.awaitDrainWriters === dest) {
          debug("pipeOnDrain", 1);
          state.awaitDrainWriters = null;
        } else if (state.multiAwaitDrain) {
          debug("pipeOnDrain", state.awaitDrainWriters.size);
          state.awaitDrainWriters.delete(dest);
        }
        if ((!state.awaitDrainWriters || state.awaitDrainWriters.size === 0) && src.listenerCount("data")) {
          src.resume();
        }
      };
    }
    Readable2.prototype.unpipe = function(dest) {
      const state = this._readableState;
      const unpipeInfo = {
        hasUnpiped: false
      };
      if (state.pipes.length === 0) return this;
      if (!dest) {
        const dests = state.pipes;
        state.pipes = [];
        this.pause();
        for (let i = 0; i < dests.length; i++)
          dests[i].emit("unpipe", this, {
            hasUnpiped: false
          });
        return this;
      }
      const index = ArrayPrototypeIndexOf(state.pipes, dest);
      if (index === -1) return this;
      state.pipes.splice(index, 1);
      if (state.pipes.length === 0) this.pause();
      dest.emit("unpipe", this, unpipeInfo);
      return this;
    };
    Readable2.prototype.on = function(ev, fn) {
      const res = Stream.prototype.on.call(this, ev, fn);
      const state = this._readableState;
      if (ev === "data") {
        state.readableListening = this.listenerCount("readable") > 0;
        if (state.flowing !== false) this.resume();
      } else if (ev === "readable") {
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.flowing = false;
          state.emittedReadable = false;
          debug("on readable", state.length, state.reading);
          if (state.length) {
            emitReadable(this);
          } else if (!state.reading) {
            process.nextTick(nReadingNextTick, this);
          }
        }
      }
      return res;
    };
    Readable2.prototype.addListener = Readable2.prototype.on;
    Readable2.prototype.removeListener = function(ev, fn) {
      const res = Stream.prototype.removeListener.call(this, ev, fn);
      if (ev === "readable") {
        process.nextTick(updateReadableListening, this);
      }
      return res;
    };
    Readable2.prototype.off = Readable2.prototype.removeListener;
    Readable2.prototype.removeAllListeners = function(ev) {
      const res = Stream.prototype.removeAllListeners.apply(this, arguments);
      if (ev === "readable" || ev === void 0) {
        process.nextTick(updateReadableListening, this);
      }
      return res;
    };
    function updateReadableListening(self2) {
      const state = self2._readableState;
      state.readableListening = self2.listenerCount("readable") > 0;
      if (state.resumeScheduled && state[kPaused] === false) {
        state.flowing = true;
      } else if (self2.listenerCount("data") > 0) {
        self2.resume();
      } else if (!state.readableListening) {
        state.flowing = null;
      }
    }
    function nReadingNextTick(self2) {
      debug("readable nexttick read 0");
      self2.read(0);
    }
    Readable2.prototype.resume = function() {
      const state = this._readableState;
      if (!state.flowing) {
        debug("resume");
        state.flowing = !state.readableListening;
        resume(this, state);
      }
      state[kPaused] = false;
      return this;
    };
    function resume(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        process.nextTick(resume_, stream, state);
      }
    }
    function resume_(stream, state) {
      debug("resume", state.reading);
      if (!state.reading) {
        stream.read(0);
      }
      state.resumeScheduled = false;
      stream.emit("resume");
      flow(stream);
      if (state.flowing && !state.reading) stream.read(0);
    }
    Readable2.prototype.pause = function() {
      debug("call pause flowing=%j", this._readableState.flowing);
      if (this._readableState.flowing !== false) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      this._readableState[kPaused] = true;
      return this;
    };
    function flow(stream) {
      const state = stream._readableState;
      debug("flow", state.flowing);
      while (state.flowing && stream.read() !== null) ;
    }
    Readable2.prototype.wrap = function(stream) {
      let paused = false;
      stream.on("data", (chunk) => {
        if (!this.push(chunk) && stream.pause) {
          paused = true;
          stream.pause();
        }
      });
      stream.on("end", () => {
        this.push(null);
      });
      stream.on("error", (err) => {
        errorOrDestroy(this, err);
      });
      stream.on("close", () => {
        this.destroy();
      });
      stream.on("destroy", () => {
        this.destroy();
      });
      this._read = () => {
        if (paused && stream.resume) {
          paused = false;
          stream.resume();
        }
      };
      const streamKeys = ObjectKeys(stream);
      for (let j = 1; j < streamKeys.length; j++) {
        const i = streamKeys[j];
        if (this[i] === void 0 && typeof stream[i] === "function") {
          this[i] = stream[i].bind(stream);
        }
      }
      return this;
    };
    Readable2.prototype[SymbolAsyncIterator] = function() {
      return streamToAsyncIterator(this);
    };
    Readable2.prototype.iterator = function(options) {
      if (options !== void 0) {
        validateObject(options, "options");
      }
      return streamToAsyncIterator(this, options);
    };
    function streamToAsyncIterator(stream, options) {
      if (typeof stream.read !== "function") {
        stream = Readable2.wrap(stream, {
          objectMode: true
        });
      }
      const iter = createAsyncIterator(stream, options);
      iter.stream = stream;
      return iter;
    }
    async function* createAsyncIterator(stream, options) {
      let callback = nop2;
      function next(resolve2) {
        if (this === stream) {
          callback();
          callback = nop2;
        } else {
          callback = resolve2;
        }
      }
      stream.on("readable", next);
      let error;
      const cleanup = eos(
        stream,
        {
          writable: false
        },
        (err) => {
          error = err ? aggregateTwoErrors(error, err) : null;
          callback();
          callback = nop2;
        }
      );
      try {
        while (true) {
          const chunk = stream.destroyed ? null : stream.read();
          if (chunk !== null) {
            yield chunk;
          } else if (error) {
            throw error;
          } else if (error === null) {
            return;
          } else {
            await new Promise2(next);
          }
        }
      } catch (err) {
        error = aggregateTwoErrors(error, err);
        throw error;
      } finally {
        if ((error || (options === null || options === void 0 ? void 0 : options.destroyOnReturn) !== false) && (error === void 0 || stream._readableState.autoDestroy)) {
          destroyImpl.destroyer(stream, null);
        } else {
          stream.off("readable", next);
          cleanup();
        }
      }
    }
    ObjectDefineProperties(Readable2.prototype, {
      readable: {
        __proto__: null,
        get() {
          const r = this._readableState;
          return !!r && r.readable !== false && !r.destroyed && !r.errorEmitted && !r.endEmitted;
        },
        set(val) {
          if (this._readableState) {
            this._readableState.readable = !!val;
          }
        }
      },
      readableDidRead: {
        __proto__: null,
        enumerable: false,
        get: function() {
          return this._readableState.dataEmitted;
        }
      },
      readableAborted: {
        __proto__: null,
        enumerable: false,
        get: function() {
          return !!(this._readableState.readable !== false && (this._readableState.destroyed || this._readableState.errored) && !this._readableState.endEmitted);
        }
      },
      readableHighWaterMark: {
        __proto__: null,
        enumerable: false,
        get: function() {
          return this._readableState.highWaterMark;
        }
      },
      readableBuffer: {
        __proto__: null,
        enumerable: false,
        get: function() {
          return this._readableState && this._readableState.buffer;
        }
      },
      readableFlowing: {
        __proto__: null,
        enumerable: false,
        get: function() {
          return this._readableState.flowing;
        },
        set: function(state) {
          if (this._readableState) {
            this._readableState.flowing = state;
          }
        }
      },
      readableLength: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._readableState.length;
        }
      },
      readableObjectMode: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._readableState ? this._readableState.objectMode : false;
        }
      },
      readableEncoding: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._readableState ? this._readableState.encoding : null;
        }
      },
      errored: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._readableState ? this._readableState.errored : null;
        }
      },
      closed: {
        __proto__: null,
        get() {
          return this._readableState ? this._readableState.closed : false;
        }
      },
      destroyed: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._readableState ? this._readableState.destroyed : false;
        },
        set(value) {
          if (!this._readableState) {
            return;
          }
          this._readableState.destroyed = value;
        }
      },
      readableEnded: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._readableState ? this._readableState.endEmitted : false;
        }
      }
    });
    ObjectDefineProperties(ReadableState.prototype, {
      // Legacy getter for `pipesCount`.
      pipesCount: {
        __proto__: null,
        get() {
          return this.pipes.length;
        }
      },
      // Legacy property for `paused`.
      paused: {
        __proto__: null,
        get() {
          return this[kPaused] !== false;
        },
        set(value) {
          this[kPaused] = !!value;
        }
      }
    });
    Readable2._fromList = fromList;
    function fromList(n, state) {
      if (state.length === 0) return null;
      let ret;
      if (state.objectMode) ret = state.buffer.shift();
      else if (!n || n >= state.length) {
        if (state.decoder) ret = state.buffer.join("");
        else if (state.buffer.length === 1) ret = state.buffer.first();
        else ret = state.buffer.concat(state.length);
        state.buffer.clear();
      } else {
        ret = state.buffer.consume(n, state.decoder);
      }
      return ret;
    }
    function endReadable(stream) {
      const state = stream._readableState;
      debug("endReadable", state.endEmitted);
      if (!state.endEmitted) {
        state.ended = true;
        process.nextTick(endReadableNT, state, stream);
      }
    }
    function endReadableNT(state, stream) {
      debug("endReadableNT", state.endEmitted, state.length);
      if (!state.errored && !state.closeEmitted && !state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.emit("end");
        if (stream.writable && stream.allowHalfOpen === false) {
          process.nextTick(endWritableNT, stream);
        } else if (state.autoDestroy) {
          const wState = stream._writableState;
          const autoDestroy = !wState || wState.autoDestroy && // We don't expect the writable to ever 'finish'
          // if writable is explicitly set to false.
          (wState.finished || wState.writable === false);
          if (autoDestroy) {
            stream.destroy();
          }
        }
      }
    }
    function endWritableNT(stream) {
      const writable = stream.writable && !stream.writableEnded && !stream.destroyed;
      if (writable) {
        stream.end();
      }
    }
    Readable2.from = function(iterable, opts) {
      return from(Readable2, iterable, opts);
    };
    var webStreamsAdapters;
    function lazyWebStreams() {
      if (webStreamsAdapters === void 0) webStreamsAdapters = {};
      return webStreamsAdapters;
    }
    Readable2.fromWeb = function(readableStream, options) {
      return lazyWebStreams().newStreamReadableFromReadableStream(readableStream, options);
    };
    Readable2.toWeb = function(streamReadable, options) {
      return lazyWebStreams().newReadableStreamFromStreamReadable(streamReadable, options);
    };
    Readable2.wrap = function(src, options) {
      var _ref, _src$readableObjectMo;
      return new Readable2({
        objectMode: (_ref = (_src$readableObjectMo = src.readableObjectMode) !== null && _src$readableObjectMo !== void 0 ? _src$readableObjectMo : src.objectMode) !== null && _ref !== void 0 ? _ref : true,
        ...options,
        destroy(err, callback) {
          destroyImpl.destroyer(src, err);
          callback(err);
        }
      }).wrap(src);
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/writable.js
var require_writable = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/writable.js"(exports, module) {
    "use strict";
    var process = require_browser2();
    var {
      ArrayPrototypeSlice,
      Error: Error2,
      FunctionPrototypeSymbolHasInstance,
      ObjectDefineProperty,
      ObjectDefineProperties,
      ObjectSetPrototypeOf,
      StringPrototypeToLowerCase,
      Symbol: Symbol2,
      SymbolHasInstance
    } = require_primordials();
    module.exports = Writable2;
    Writable2.WritableState = WritableState;
    var { EventEmitter: EE } = require_events();
    var Stream = require_legacy().Stream;
    var { Buffer: Buffer4 } = require_buffer();
    var destroyImpl = require_destroy();
    var { addAbortSignal } = require_add_abort_signal();
    var { getHighWaterMark, getDefaultHighWaterMark } = require_state();
    var {
      ERR_INVALID_ARG_TYPE,
      ERR_METHOD_NOT_IMPLEMENTED,
      ERR_MULTIPLE_CALLBACK,
      ERR_STREAM_CANNOT_PIPE,
      ERR_STREAM_DESTROYED,
      ERR_STREAM_ALREADY_FINISHED,
      ERR_STREAM_NULL_VALUES,
      ERR_STREAM_WRITE_AFTER_END,
      ERR_UNKNOWN_ENCODING
    } = require_errors().codes;
    var { errorOrDestroy } = destroyImpl;
    ObjectSetPrototypeOf(Writable2.prototype, Stream.prototype);
    ObjectSetPrototypeOf(Writable2, Stream);
    function nop2() {
    }
    var kOnFinished = Symbol2("kOnFinished");
    function WritableState(options, stream, isDuplex) {
      if (typeof isDuplex !== "boolean") isDuplex = stream instanceof require_duplex();
      this.objectMode = !!(options && options.objectMode);
      if (isDuplex) this.objectMode = this.objectMode || !!(options && options.writableObjectMode);
      this.highWaterMark = options ? getHighWaterMark(this, options, "writableHighWaterMark", isDuplex) : getDefaultHighWaterMark(false);
      this.finalCalled = false;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      this.destroyed = false;
      const noDecode = !!(options && options.decodeStrings === false);
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options && options.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = onwrite.bind(void 0, stream);
      this.writecb = null;
      this.writelen = 0;
      this.afterWriteTickInfo = null;
      resetBuffer(this);
      this.pendingcb = 0;
      this.constructed = true;
      this.prefinished = false;
      this.errorEmitted = false;
      this.emitClose = !options || options.emitClose !== false;
      this.autoDestroy = !options || options.autoDestroy !== false;
      this.errored = null;
      this.closed = false;
      this.closeEmitted = false;
      this[kOnFinished] = [];
    }
    function resetBuffer(state) {
      state.buffered = [];
      state.bufferedIndex = 0;
      state.allBuffers = true;
      state.allNoop = true;
    }
    WritableState.prototype.getBuffer = function getBuffer() {
      return ArrayPrototypeSlice(this.buffered, this.bufferedIndex);
    };
    ObjectDefineProperty(WritableState.prototype, "bufferedRequestCount", {
      __proto__: null,
      get() {
        return this.buffered.length - this.bufferedIndex;
      }
    });
    function Writable2(options) {
      const isDuplex = this instanceof require_duplex();
      if (!isDuplex && !FunctionPrototypeSymbolHasInstance(Writable2, this)) return new Writable2(options);
      this._writableState = new WritableState(options, this, isDuplex);
      if (options) {
        if (typeof options.write === "function") this._write = options.write;
        if (typeof options.writev === "function") this._writev = options.writev;
        if (typeof options.destroy === "function") this._destroy = options.destroy;
        if (typeof options.final === "function") this._final = options.final;
        if (typeof options.construct === "function") this._construct = options.construct;
        if (options.signal) addAbortSignal(options.signal, this);
      }
      Stream.call(this, options);
      destroyImpl.construct(this, () => {
        const state = this._writableState;
        if (!state.writing) {
          clearBuffer(this, state);
        }
        finishMaybe(this, state);
      });
    }
    ObjectDefineProperty(Writable2, SymbolHasInstance, {
      __proto__: null,
      value: function(object) {
        if (FunctionPrototypeSymbolHasInstance(this, object)) return true;
        if (this !== Writable2) return false;
        return object && object._writableState instanceof WritableState;
      }
    });
    Writable2.prototype.pipe = function() {
      errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
    };
    function _write(stream, chunk, encoding, cb) {
      const state = stream._writableState;
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = state.defaultEncoding;
      } else {
        if (!encoding) encoding = state.defaultEncoding;
        else if (encoding !== "buffer" && !Buffer4.isEncoding(encoding)) throw new ERR_UNKNOWN_ENCODING(encoding);
        if (typeof cb !== "function") cb = nop2;
      }
      if (chunk === null) {
        throw new ERR_STREAM_NULL_VALUES();
      } else if (!state.objectMode) {
        if (typeof chunk === "string") {
          if (state.decodeStrings !== false) {
            chunk = Buffer4.from(chunk, encoding);
            encoding = "buffer";
          }
        } else if (chunk instanceof Buffer4) {
          encoding = "buffer";
        } else if (Stream._isUint8Array(chunk)) {
          chunk = Stream._uint8ArrayToBuffer(chunk);
          encoding = "buffer";
        } else {
          throw new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
        }
      }
      let err;
      if (state.ending) {
        err = new ERR_STREAM_WRITE_AFTER_END();
      } else if (state.destroyed) {
        err = new ERR_STREAM_DESTROYED("write");
      }
      if (err) {
        process.nextTick(cb, err);
        errorOrDestroy(stream, err, true);
        return err;
      }
      state.pendingcb++;
      return writeOrBuffer(stream, state, chunk, encoding, cb);
    }
    Writable2.prototype.write = function(chunk, encoding, cb) {
      return _write(this, chunk, encoding, cb) === true;
    };
    Writable2.prototype.cork = function() {
      this._writableState.corked++;
    };
    Writable2.prototype.uncork = function() {
      const state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing) clearBuffer(this, state);
      }
    };
    Writable2.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string") encoding = StringPrototypeToLowerCase(encoding);
      if (!Buffer4.isEncoding(encoding)) throw new ERR_UNKNOWN_ENCODING(encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    function writeOrBuffer(stream, state, chunk, encoding, callback) {
      const len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      const ret = state.length < state.highWaterMark;
      if (!ret) state.needDrain = true;
      if (state.writing || state.corked || state.errored || !state.constructed) {
        state.buffered.push({
          chunk,
          encoding,
          callback
        });
        if (state.allBuffers && encoding !== "buffer") {
          state.allBuffers = false;
        }
        if (state.allNoop && callback !== nop2) {
          state.allNoop = false;
        }
      } else {
        state.writelen = len;
        state.writecb = callback;
        state.writing = true;
        state.sync = true;
        stream._write(chunk, encoding, state.onwrite);
        state.sync = false;
      }
      return ret && !state.errored && !state.destroyed;
    }
    function doWrite(stream, state, writev2, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED("write"));
      else if (writev2) stream._writev(chunk, state.onwrite);
      else stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream, state, er, cb) {
      --state.pendingcb;
      cb(er);
      errorBuffer(state);
      errorOrDestroy(stream, er);
    }
    function onwrite(stream, er) {
      const state = stream._writableState;
      const sync = state.sync;
      const cb = state.writecb;
      if (typeof cb !== "function") {
        errorOrDestroy(stream, new ERR_MULTIPLE_CALLBACK());
        return;
      }
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
      if (er) {
        er.stack;
        if (!state.errored) {
          state.errored = er;
        }
        if (stream._readableState && !stream._readableState.errored) {
          stream._readableState.errored = er;
        }
        if (sync) {
          process.nextTick(onwriteError, stream, state, er, cb);
        } else {
          onwriteError(stream, state, er, cb);
        }
      } else {
        if (state.buffered.length > state.bufferedIndex) {
          clearBuffer(stream, state);
        }
        if (sync) {
          if (state.afterWriteTickInfo !== null && state.afterWriteTickInfo.cb === cb) {
            state.afterWriteTickInfo.count++;
          } else {
            state.afterWriteTickInfo = {
              count: 1,
              cb,
              stream,
              state
            };
            process.nextTick(afterWriteTick, state.afterWriteTickInfo);
          }
        } else {
          afterWrite(stream, state, 1, cb);
        }
      }
    }
    function afterWriteTick({ stream, state, count, cb }) {
      state.afterWriteTickInfo = null;
      return afterWrite(stream, state, count, cb);
    }
    function afterWrite(stream, state, count, cb) {
      const needDrain = !state.ending && !stream.destroyed && state.length === 0 && state.needDrain;
      if (needDrain) {
        state.needDrain = false;
        stream.emit("drain");
      }
      while (count-- > 0) {
        state.pendingcb--;
        cb();
      }
      if (state.destroyed) {
        errorBuffer(state);
      }
      finishMaybe(stream, state);
    }
    function errorBuffer(state) {
      if (state.writing) {
        return;
      }
      for (let n = state.bufferedIndex; n < state.buffered.length; ++n) {
        var _state$errored;
        const { chunk, callback } = state.buffered[n];
        const len = state.objectMode ? 1 : chunk.length;
        state.length -= len;
        callback(
          (_state$errored = state.errored) !== null && _state$errored !== void 0 ? _state$errored : new ERR_STREAM_DESTROYED("write")
        );
      }
      const onfinishCallbacks = state[kOnFinished].splice(0);
      for (let i = 0; i < onfinishCallbacks.length; i++) {
        var _state$errored2;
        onfinishCallbacks[i](
          (_state$errored2 = state.errored) !== null && _state$errored2 !== void 0 ? _state$errored2 : new ERR_STREAM_DESTROYED("end")
        );
      }
      resetBuffer(state);
    }
    function clearBuffer(stream, state) {
      if (state.corked || state.bufferProcessing || state.destroyed || !state.constructed) {
        return;
      }
      const { buffered, bufferedIndex, objectMode } = state;
      const bufferedLength = buffered.length - bufferedIndex;
      if (!bufferedLength) {
        return;
      }
      let i = bufferedIndex;
      state.bufferProcessing = true;
      if (bufferedLength > 1 && stream._writev) {
        state.pendingcb -= bufferedLength - 1;
        const callback = state.allNoop ? nop2 : (err) => {
          for (let n = i; n < buffered.length; ++n) {
            buffered[n].callback(err);
          }
        };
        const chunks = state.allNoop && i === 0 ? buffered : ArrayPrototypeSlice(buffered, i);
        chunks.allBuffers = state.allBuffers;
        doWrite(stream, state, true, state.length, chunks, "", callback);
        resetBuffer(state);
      } else {
        do {
          const { chunk, encoding, callback } = buffered[i];
          buffered[i++] = null;
          const len = objectMode ? 1 : chunk.length;
          doWrite(stream, state, false, len, chunk, encoding, callback);
        } while (i < buffered.length && !state.writing);
        if (i === buffered.length) {
          resetBuffer(state);
        } else if (i > 256) {
          buffered.splice(0, i);
          state.bufferedIndex = 0;
        } else {
          state.bufferedIndex = i;
        }
      }
      state.bufferProcessing = false;
    }
    Writable2.prototype._write = function(chunk, encoding, cb) {
      if (this._writev) {
        this._writev(
          [
            {
              chunk,
              encoding
            }
          ],
          cb
        );
      } else {
        throw new ERR_METHOD_NOT_IMPLEMENTED("_write()");
      }
    };
    Writable2.prototype._writev = null;
    Writable2.prototype.end = function(chunk, encoding, cb) {
      const state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      let err;
      if (chunk !== null && chunk !== void 0) {
        const ret = _write(this, chunk, encoding);
        if (ret instanceof Error2) {
          err = ret;
        }
      }
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (err) {
      } else if (!state.errored && !state.ending) {
        state.ending = true;
        finishMaybe(this, state, true);
        state.ended = true;
      } else if (state.finished) {
        err = new ERR_STREAM_ALREADY_FINISHED("end");
      } else if (state.destroyed) {
        err = new ERR_STREAM_DESTROYED("end");
      }
      if (typeof cb === "function") {
        if (err || state.finished) {
          process.nextTick(cb, err);
        } else {
          state[kOnFinished].push(cb);
        }
      }
      return this;
    };
    function needFinish(state) {
      return state.ending && !state.destroyed && state.constructed && state.length === 0 && !state.errored && state.buffered.length === 0 && !state.finished && !state.writing && !state.errorEmitted && !state.closeEmitted;
    }
    function callFinal(stream, state) {
      let called = false;
      function onFinish(err) {
        if (called) {
          errorOrDestroy(stream, err !== null && err !== void 0 ? err : ERR_MULTIPLE_CALLBACK());
          return;
        }
        called = true;
        state.pendingcb--;
        if (err) {
          const onfinishCallbacks = state[kOnFinished].splice(0);
          for (let i = 0; i < onfinishCallbacks.length; i++) {
            onfinishCallbacks[i](err);
          }
          errorOrDestroy(stream, err, state.sync);
        } else if (needFinish(state)) {
          state.prefinished = true;
          stream.emit("prefinish");
          state.pendingcb++;
          process.nextTick(finish, stream, state);
        }
      }
      state.sync = true;
      state.pendingcb++;
      try {
        stream._final(onFinish);
      } catch (err) {
        onFinish(err);
      }
      state.sync = false;
    }
    function prefinish(stream, state) {
      if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === "function" && !state.destroyed) {
          state.finalCalled = true;
          callFinal(stream, state);
        } else {
          state.prefinished = true;
          stream.emit("prefinish");
        }
      }
    }
    function finishMaybe(stream, state, sync) {
      if (needFinish(state)) {
        prefinish(stream, state);
        if (state.pendingcb === 0) {
          if (sync) {
            state.pendingcb++;
            process.nextTick(
              (stream2, state2) => {
                if (needFinish(state2)) {
                  finish(stream2, state2);
                } else {
                  state2.pendingcb--;
                }
              },
              stream,
              state
            );
          } else if (needFinish(state)) {
            state.pendingcb++;
            finish(stream, state);
          }
        }
      }
    }
    function finish(stream, state) {
      state.pendingcb--;
      state.finished = true;
      const onfinishCallbacks = state[kOnFinished].splice(0);
      for (let i = 0; i < onfinishCallbacks.length; i++) {
        onfinishCallbacks[i]();
      }
      stream.emit("finish");
      if (state.autoDestroy) {
        const rState = stream._readableState;
        const autoDestroy = !rState || rState.autoDestroy && // We don't expect the readable to ever 'end'
        // if readable is explicitly set to false.
        (rState.endEmitted || rState.readable === false);
        if (autoDestroy) {
          stream.destroy();
        }
      }
    }
    ObjectDefineProperties(Writable2.prototype, {
      closed: {
        __proto__: null,
        get() {
          return this._writableState ? this._writableState.closed : false;
        }
      },
      destroyed: {
        __proto__: null,
        get() {
          return this._writableState ? this._writableState.destroyed : false;
        },
        set(value) {
          if (this._writableState) {
            this._writableState.destroyed = value;
          }
        }
      },
      writable: {
        __proto__: null,
        get() {
          const w = this._writableState;
          return !!w && w.writable !== false && !w.destroyed && !w.errored && !w.ending && !w.ended;
        },
        set(val) {
          if (this._writableState) {
            this._writableState.writable = !!val;
          }
        }
      },
      writableFinished: {
        __proto__: null,
        get() {
          return this._writableState ? this._writableState.finished : false;
        }
      },
      writableObjectMode: {
        __proto__: null,
        get() {
          return this._writableState ? this._writableState.objectMode : false;
        }
      },
      writableBuffer: {
        __proto__: null,
        get() {
          return this._writableState && this._writableState.getBuffer();
        }
      },
      writableEnded: {
        __proto__: null,
        get() {
          return this._writableState ? this._writableState.ending : false;
        }
      },
      writableNeedDrain: {
        __proto__: null,
        get() {
          const wState = this._writableState;
          if (!wState) return false;
          return !wState.destroyed && !wState.ending && wState.needDrain;
        }
      },
      writableHighWaterMark: {
        __proto__: null,
        get() {
          return this._writableState && this._writableState.highWaterMark;
        }
      },
      writableCorked: {
        __proto__: null,
        get() {
          return this._writableState ? this._writableState.corked : 0;
        }
      },
      writableLength: {
        __proto__: null,
        get() {
          return this._writableState && this._writableState.length;
        }
      },
      errored: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._writableState ? this._writableState.errored : null;
        }
      },
      writableAborted: {
        __proto__: null,
        enumerable: false,
        get: function() {
          return !!(this._writableState.writable !== false && (this._writableState.destroyed || this._writableState.errored) && !this._writableState.finished);
        }
      }
    });
    var destroy = destroyImpl.destroy;
    Writable2.prototype.destroy = function(err, cb) {
      const state = this._writableState;
      if (!state.destroyed && (state.bufferedIndex < state.buffered.length || state[kOnFinished].length)) {
        process.nextTick(errorBuffer, state);
      }
      destroy.call(this, err, cb);
      return this;
    };
    Writable2.prototype._undestroy = destroyImpl.undestroy;
    Writable2.prototype._destroy = function(err, cb) {
      cb(err);
    };
    Writable2.prototype[EE.captureRejectionSymbol] = function(err) {
      this.destroy(err);
    };
    var webStreamsAdapters;
    function lazyWebStreams() {
      if (webStreamsAdapters === void 0) webStreamsAdapters = {};
      return webStreamsAdapters;
    }
    Writable2.fromWeb = function(writableStream, options) {
      return lazyWebStreams().newStreamWritableFromWritableStream(writableStream, options);
    };
    Writable2.toWeb = function(streamWritable) {
      return lazyWebStreams().newWritableStreamFromStreamWritable(streamWritable);
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/duplexify.js
var require_duplexify = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/duplexify.js"(exports, module) {
    var process = require_browser2();
    var bufferModule = require_buffer();
    var {
      isReadable: isReadable2,
      isWritable,
      isIterable,
      isNodeStream,
      isReadableNodeStream,
      isWritableNodeStream,
      isDuplexNodeStream,
      isReadableStream,
      isWritableStream
    } = require_utils();
    var eos = require_end_of_stream();
    var {
      AbortError,
      codes: { ERR_INVALID_ARG_TYPE, ERR_INVALID_RETURN_VALUE }
    } = require_errors();
    var { destroyer } = require_destroy();
    var Duplex = require_duplex();
    var Readable2 = require_readable();
    var Writable2 = require_writable();
    var { createDeferredPromise } = require_util();
    var from = require_from();
    var Blob2 = globalThis.Blob || bufferModule.Blob;
    var isBlob = typeof Blob2 !== "undefined" ? function isBlob2(b) {
      return b instanceof Blob2;
    } : function isBlob2(b) {
      return false;
    };
    var AbortController = globalThis.AbortController || require_browser().AbortController;
    var { FunctionPrototypeCall } = require_primordials();
    var Duplexify = class extends Duplex {
      constructor(options) {
        super(options);
        if ((options === null || options === void 0 ? void 0 : options.readable) === false) {
          this._readableState.readable = false;
          this._readableState.ended = true;
          this._readableState.endEmitted = true;
        }
        if ((options === null || options === void 0 ? void 0 : options.writable) === false) {
          this._writableState.writable = false;
          this._writableState.ending = true;
          this._writableState.ended = true;
          this._writableState.finished = true;
        }
      }
    };
    module.exports = function duplexify(body, name) {
      if (isDuplexNodeStream(body)) {
        return body;
      }
      if (isReadableNodeStream(body)) {
        return _duplexify({
          readable: body
        });
      }
      if (isWritableNodeStream(body)) {
        return _duplexify({
          writable: body
        });
      }
      if (isNodeStream(body)) {
        return _duplexify({
          writable: false,
          readable: false
        });
      }
      if (isReadableStream(body)) {
        return _duplexify({
          readable: Readable2.fromWeb(body)
        });
      }
      if (isWritableStream(body)) {
        return _duplexify({
          writable: Writable2.fromWeb(body)
        });
      }
      if (typeof body === "function") {
        const { value, write: write2, final, destroy } = fromAsyncGen(body);
        if (isIterable(value)) {
          return from(Duplexify, value, {
            // TODO (ronag): highWaterMark?
            objectMode: true,
            write: write2,
            final,
            destroy
          });
        }
        const then2 = value === null || value === void 0 ? void 0 : value.then;
        if (typeof then2 === "function") {
          let d;
          const promise = FunctionPrototypeCall(
            then2,
            value,
            (val) => {
              if (val != null) {
                throw new ERR_INVALID_RETURN_VALUE("nully", "body", val);
              }
            },
            (err) => {
              destroyer(d, err);
            }
          );
          return d = new Duplexify({
            // TODO (ronag): highWaterMark?
            objectMode: true,
            readable: false,
            write: write2,
            final(cb) {
              final(async () => {
                try {
                  await promise;
                  process.nextTick(cb, null);
                } catch (err) {
                  process.nextTick(cb, err);
                }
              });
            },
            destroy
          });
        }
        throw new ERR_INVALID_RETURN_VALUE("Iterable, AsyncIterable or AsyncFunction", name, value);
      }
      if (isBlob(body)) {
        return duplexify(body.arrayBuffer());
      }
      if (isIterable(body)) {
        return from(Duplexify, body, {
          // TODO (ronag): highWaterMark?
          objectMode: true,
          writable: false
        });
      }
      if (isReadableStream(body === null || body === void 0 ? void 0 : body.readable) && isWritableStream(body === null || body === void 0 ? void 0 : body.writable)) {
        return Duplexify.fromWeb(body);
      }
      if (typeof (body === null || body === void 0 ? void 0 : body.writable) === "object" || typeof (body === null || body === void 0 ? void 0 : body.readable) === "object") {
        const readable = body !== null && body !== void 0 && body.readable ? isReadableNodeStream(body === null || body === void 0 ? void 0 : body.readable) ? body === null || body === void 0 ? void 0 : body.readable : duplexify(body.readable) : void 0;
        const writable = body !== null && body !== void 0 && body.writable ? isWritableNodeStream(body === null || body === void 0 ? void 0 : body.writable) ? body === null || body === void 0 ? void 0 : body.writable : duplexify(body.writable) : void 0;
        return _duplexify({
          readable,
          writable
        });
      }
      const then = body === null || body === void 0 ? void 0 : body.then;
      if (typeof then === "function") {
        let d;
        FunctionPrototypeCall(
          then,
          body,
          (val) => {
            if (val != null) {
              d.push(val);
            }
            d.push(null);
          },
          (err) => {
            destroyer(d, err);
          }
        );
        return d = new Duplexify({
          objectMode: true,
          writable: false,
          read() {
          }
        });
      }
      throw new ERR_INVALID_ARG_TYPE(
        name,
        [
          "Blob",
          "ReadableStream",
          "WritableStream",
          "Stream",
          "Iterable",
          "AsyncIterable",
          "Function",
          "{ readable, writable } pair",
          "Promise"
        ],
        body
      );
    };
    function fromAsyncGen(fn) {
      let { promise, resolve: resolve2 } = createDeferredPromise();
      const ac = new AbortController();
      const signal = ac.signal;
      const value = fn(
        async function* () {
          while (true) {
            const _promise = promise;
            promise = null;
            const { chunk, done, cb } = await _promise;
            process.nextTick(cb);
            if (done) return;
            if (signal.aborted)
              throw new AbortError(void 0, {
                cause: signal.reason
              });
            ({ promise, resolve: resolve2 } = createDeferredPromise());
            yield chunk;
          }
        }(),
        {
          signal
        }
      );
      return {
        value,
        write(chunk, encoding, cb) {
          const _resolve = resolve2;
          resolve2 = null;
          _resolve({
            chunk,
            done: false,
            cb
          });
        },
        final(cb) {
          const _resolve = resolve2;
          resolve2 = null;
          _resolve({
            done: true,
            cb
          });
        },
        destroy(err, cb) {
          ac.abort();
          cb(err);
        }
      };
    }
    function _duplexify(pair) {
      const r = pair.readable && typeof pair.readable.read !== "function" ? Readable2.wrap(pair.readable) : pair.readable;
      const w = pair.writable;
      let readable = !!isReadable2(r);
      let writable = !!isWritable(w);
      let ondrain;
      let onfinish;
      let onreadable;
      let onclose;
      let d;
      function onfinished(err) {
        const cb = onclose;
        onclose = null;
        if (cb) {
          cb(err);
        } else if (err) {
          d.destroy(err);
        }
      }
      d = new Duplexify({
        // TODO (ronag): highWaterMark?
        readableObjectMode: !!(r !== null && r !== void 0 && r.readableObjectMode),
        writableObjectMode: !!(w !== null && w !== void 0 && w.writableObjectMode),
        readable,
        writable
      });
      if (writable) {
        eos(w, (err) => {
          writable = false;
          if (err) {
            destroyer(r, err);
          }
          onfinished(err);
        });
        d._write = function(chunk, encoding, callback) {
          if (w.write(chunk, encoding)) {
            callback();
          } else {
            ondrain = callback;
          }
        };
        d._final = function(callback) {
          w.end();
          onfinish = callback;
        };
        w.on("drain", function() {
          if (ondrain) {
            const cb = ondrain;
            ondrain = null;
            cb();
          }
        });
        w.on("finish", function() {
          if (onfinish) {
            const cb = onfinish;
            onfinish = null;
            cb();
          }
        });
      }
      if (readable) {
        eos(r, (err) => {
          readable = false;
          if (err) {
            destroyer(r, err);
          }
          onfinished(err);
        });
        r.on("readable", function() {
          if (onreadable) {
            const cb = onreadable;
            onreadable = null;
            cb();
          }
        });
        r.on("end", function() {
          d.push(null);
        });
        d._read = function() {
          while (true) {
            const buf = r.read();
            if (buf === null) {
              onreadable = d._read;
              return;
            }
            if (!d.push(buf)) {
              return;
            }
          }
        };
      }
      d._destroy = function(err, callback) {
        if (!err && onclose !== null) {
          err = new AbortError();
        }
        onreadable = null;
        ondrain = null;
        onfinish = null;
        if (onclose === null) {
          callback(err);
        } else {
          onclose = callback;
          destroyer(w, err);
          destroyer(r, err);
        }
      };
      return d;
    }
  }
});

// node_modules/readable-stream/lib/internal/streams/duplex.js
var require_duplex = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/duplex.js"(exports, module) {
    "use strict";
    var {
      ObjectDefineProperties,
      ObjectGetOwnPropertyDescriptor,
      ObjectKeys,
      ObjectSetPrototypeOf
    } = require_primordials();
    module.exports = Duplex;
    var Readable2 = require_readable();
    var Writable2 = require_writable();
    ObjectSetPrototypeOf(Duplex.prototype, Readable2.prototype);
    ObjectSetPrototypeOf(Duplex, Readable2);
    {
      const keys = ObjectKeys(Writable2.prototype);
      for (let i = 0; i < keys.length; i++) {
        const method = keys[i];
        if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable2.prototype[method];
      }
    }
    function Duplex(options) {
      if (!(this instanceof Duplex)) return new Duplex(options);
      Readable2.call(this, options);
      Writable2.call(this, options);
      if (options) {
        this.allowHalfOpen = options.allowHalfOpen !== false;
        if (options.readable === false) {
          this._readableState.readable = false;
          this._readableState.ended = true;
          this._readableState.endEmitted = true;
        }
        if (options.writable === false) {
          this._writableState.writable = false;
          this._writableState.ending = true;
          this._writableState.ended = true;
          this._writableState.finished = true;
        }
      } else {
        this.allowHalfOpen = true;
      }
    }
    ObjectDefineProperties(Duplex.prototype, {
      writable: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable2.prototype, "writable")
      },
      writableHighWaterMark: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable2.prototype, "writableHighWaterMark")
      },
      writableObjectMode: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable2.prototype, "writableObjectMode")
      },
      writableBuffer: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable2.prototype, "writableBuffer")
      },
      writableLength: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable2.prototype, "writableLength")
      },
      writableFinished: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable2.prototype, "writableFinished")
      },
      writableCorked: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable2.prototype, "writableCorked")
      },
      writableEnded: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable2.prototype, "writableEnded")
      },
      writableNeedDrain: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable2.prototype, "writableNeedDrain")
      },
      destroyed: {
        __proto__: null,
        get() {
          if (this._readableState === void 0 || this._writableState === void 0) {
            return false;
          }
          return this._readableState.destroyed && this._writableState.destroyed;
        },
        set(value) {
          if (this._readableState && this._writableState) {
            this._readableState.destroyed = value;
            this._writableState.destroyed = value;
          }
        }
      }
    });
    var webStreamsAdapters;
    function lazyWebStreams() {
      if (webStreamsAdapters === void 0) webStreamsAdapters = {};
      return webStreamsAdapters;
    }
    Duplex.fromWeb = function(pair, options) {
      return lazyWebStreams().newStreamDuplexFromReadableWritablePair(pair, options);
    };
    Duplex.toWeb = function(duplex) {
      return lazyWebStreams().newReadableWritablePairFromDuplex(duplex);
    };
    var duplexify;
    Duplex.from = function(body) {
      if (!duplexify) {
        duplexify = require_duplexify();
      }
      return duplexify(body, "body");
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/transform.js
var require_transform = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/transform.js"(exports, module) {
    "use strict";
    var { ObjectSetPrototypeOf, Symbol: Symbol2 } = require_primordials();
    module.exports = Transform;
    var { ERR_METHOD_NOT_IMPLEMENTED } = require_errors().codes;
    var Duplex = require_duplex();
    var { getHighWaterMark } = require_state();
    ObjectSetPrototypeOf(Transform.prototype, Duplex.prototype);
    ObjectSetPrototypeOf(Transform, Duplex);
    var kCallback = Symbol2("kCallback");
    function Transform(options) {
      if (!(this instanceof Transform)) return new Transform(options);
      const readableHighWaterMark = options ? getHighWaterMark(this, options, "readableHighWaterMark", true) : null;
      if (readableHighWaterMark === 0) {
        options = {
          ...options,
          highWaterMark: null,
          readableHighWaterMark,
          // TODO (ronag): 0 is not optimal since we have
          // a "bug" where we check needDrain before calling _write and not after.
          // Refs: https://github.com/nodejs/node/pull/32887
          // Refs: https://github.com/nodejs/node/pull/35941
          writableHighWaterMark: options.writableHighWaterMark || 0
        };
      }
      Duplex.call(this, options);
      this._readableState.sync = false;
      this[kCallback] = null;
      if (options) {
        if (typeof options.transform === "function") this._transform = options.transform;
        if (typeof options.flush === "function") this._flush = options.flush;
      }
      this.on("prefinish", prefinish);
    }
    function final(cb) {
      if (typeof this._flush === "function" && !this.destroyed) {
        this._flush((er, data) => {
          if (er) {
            if (cb) {
              cb(er);
            } else {
              this.destroy(er);
            }
            return;
          }
          if (data != null) {
            this.push(data);
          }
          this.push(null);
          if (cb) {
            cb();
          }
        });
      } else {
        this.push(null);
        if (cb) {
          cb();
        }
      }
    }
    function prefinish() {
      if (this._final !== final) {
        final.call(this);
      }
    }
    Transform.prototype._final = final;
    Transform.prototype._transform = function(chunk, encoding, callback) {
      throw new ERR_METHOD_NOT_IMPLEMENTED("_transform()");
    };
    Transform.prototype._write = function(chunk, encoding, callback) {
      const rState = this._readableState;
      const wState = this._writableState;
      const length = rState.length;
      this._transform(chunk, encoding, (err, val) => {
        if (err) {
          callback(err);
          return;
        }
        if (val != null) {
          this.push(val);
        }
        if (wState.ended || // Backwards compat.
        length === rState.length || // Backwards compat.
        rState.length < rState.highWaterMark) {
          callback();
        } else {
          this[kCallback] = callback;
        }
      });
    };
    Transform.prototype._read = function() {
      if (this[kCallback]) {
        const callback = this[kCallback];
        this[kCallback] = null;
        callback();
      }
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/passthrough.js
var require_passthrough = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/passthrough.js"(exports, module) {
    "use strict";
    var { ObjectSetPrototypeOf } = require_primordials();
    module.exports = PassThrough;
    var Transform = require_transform();
    ObjectSetPrototypeOf(PassThrough.prototype, Transform.prototype);
    ObjectSetPrototypeOf(PassThrough, Transform);
    function PassThrough(options) {
      if (!(this instanceof PassThrough)) return new PassThrough(options);
      Transform.call(this, options);
    }
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/pipeline.js
var require_pipeline = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/pipeline.js"(exports, module) {
    var process = require_browser2();
    var { ArrayIsArray, Promise: Promise2, SymbolAsyncIterator, SymbolDispose } = require_primordials();
    var eos = require_end_of_stream();
    var { once } = require_util();
    var destroyImpl = require_destroy();
    var Duplex = require_duplex();
    var {
      aggregateTwoErrors,
      codes: {
        ERR_INVALID_ARG_TYPE,
        ERR_INVALID_RETURN_VALUE,
        ERR_MISSING_ARGS,
        ERR_STREAM_DESTROYED,
        ERR_STREAM_PREMATURE_CLOSE
      },
      AbortError
    } = require_errors();
    var { validateFunction, validateAbortSignal } = require_validators();
    var {
      isIterable,
      isReadable: isReadable2,
      isReadableNodeStream,
      isNodeStream,
      isTransformStream,
      isWebStream,
      isReadableStream,
      isReadableFinished
    } = require_utils();
    var AbortController = globalThis.AbortController || require_browser().AbortController;
    var PassThrough;
    var Readable2;
    var addAbortListener;
    function destroyer(stream, reading, writing) {
      let finished = false;
      stream.on("close", () => {
        finished = true;
      });
      const cleanup = eos(
        stream,
        {
          readable: reading,
          writable: writing
        },
        (err) => {
          finished = !err;
        }
      );
      return {
        destroy: (err) => {
          if (finished) return;
          finished = true;
          destroyImpl.destroyer(stream, err || new ERR_STREAM_DESTROYED("pipe"));
        },
        cleanup
      };
    }
    function popCallback(streams) {
      validateFunction(streams[streams.length - 1], "streams[stream.length - 1]");
      return streams.pop();
    }
    function makeAsyncIterable(val) {
      if (isIterable(val)) {
        return val;
      } else if (isReadableNodeStream(val)) {
        return fromReadable(val);
      }
      throw new ERR_INVALID_ARG_TYPE("val", ["Readable", "Iterable", "AsyncIterable"], val);
    }
    async function* fromReadable(val) {
      if (!Readable2) {
        Readable2 = require_readable();
      }
      yield* Readable2.prototype[SymbolAsyncIterator].call(val);
    }
    async function pumpToNode(iterable, writable, finish, { end }) {
      let error;
      let onresolve = null;
      const resume = (err) => {
        if (err) {
          error = err;
        }
        if (onresolve) {
          const callback = onresolve;
          onresolve = null;
          callback();
        }
      };
      const wait = () => new Promise2((resolve2, reject) => {
        if (error) {
          reject(error);
        } else {
          onresolve = () => {
            if (error) {
              reject(error);
            } else {
              resolve2();
            }
          };
        }
      });
      writable.on("drain", resume);
      const cleanup = eos(
        writable,
        {
          readable: false
        },
        resume
      );
      try {
        if (writable.writableNeedDrain) {
          await wait();
        }
        for await (const chunk of iterable) {
          if (!writable.write(chunk)) {
            await wait();
          }
        }
        if (end) {
          writable.end();
          await wait();
        }
        finish();
      } catch (err) {
        finish(error !== err ? aggregateTwoErrors(error, err) : err);
      } finally {
        cleanup();
        writable.off("drain", resume);
      }
    }
    async function pumpToWeb(readable, writable, finish, { end }) {
      if (isTransformStream(writable)) {
        writable = writable.writable;
      }
      const writer = writable.getWriter();
      try {
        for await (const chunk of readable) {
          await writer.ready;
          writer.write(chunk).catch(() => {
          });
        }
        await writer.ready;
        if (end) {
          await writer.close();
        }
        finish();
      } catch (err) {
        try {
          await writer.abort(err);
          finish(err);
        } catch (err2) {
          finish(err2);
        }
      }
    }
    function pipeline(...streams) {
      return pipelineImpl(streams, once(popCallback(streams)));
    }
    function pipelineImpl(streams, callback, opts) {
      if (streams.length === 1 && ArrayIsArray(streams[0])) {
        streams = streams[0];
      }
      if (streams.length < 2) {
        throw new ERR_MISSING_ARGS("streams");
      }
      const ac = new AbortController();
      const signal = ac.signal;
      const outerSignal = opts === null || opts === void 0 ? void 0 : opts.signal;
      const lastStreamCleanup = [];
      validateAbortSignal(outerSignal, "options.signal");
      function abort() {
        finishImpl(new AbortError());
      }
      addAbortListener = addAbortListener || require_util().addAbortListener;
      let disposable;
      if (outerSignal) {
        disposable = addAbortListener(outerSignal, abort);
      }
      let error;
      let value;
      const destroys = [];
      let finishCount = 0;
      function finish(err) {
        finishImpl(err, --finishCount === 0);
      }
      function finishImpl(err, final) {
        var _disposable;
        if (err && (!error || error.code === "ERR_STREAM_PREMATURE_CLOSE")) {
          error = err;
        }
        if (!error && !final) {
          return;
        }
        while (destroys.length) {
          destroys.shift()(error);
        }
        ;
        (_disposable = disposable) === null || _disposable === void 0 ? void 0 : _disposable[SymbolDispose]();
        ac.abort();
        if (final) {
          if (!error) {
            lastStreamCleanup.forEach((fn) => fn());
          }
          process.nextTick(callback, error, value);
        }
      }
      let ret;
      for (let i = 0; i < streams.length; i++) {
        const stream = streams[i];
        const reading = i < streams.length - 1;
        const writing = i > 0;
        const end = reading || (opts === null || opts === void 0 ? void 0 : opts.end) !== false;
        const isLastStream = i === streams.length - 1;
        if (isNodeStream(stream)) {
          let onError2 = function(err) {
            if (err && err.name !== "AbortError" && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
              finish(err);
            }
          };
          var onError = onError2;
          if (end) {
            const { destroy, cleanup } = destroyer(stream, reading, writing);
            destroys.push(destroy);
            if (isReadable2(stream) && isLastStream) {
              lastStreamCleanup.push(cleanup);
            }
          }
          stream.on("error", onError2);
          if (isReadable2(stream) && isLastStream) {
            lastStreamCleanup.push(() => {
              stream.removeListener("error", onError2);
            });
          }
        }
        if (i === 0) {
          if (typeof stream === "function") {
            ret = stream({
              signal
            });
            if (!isIterable(ret)) {
              throw new ERR_INVALID_RETURN_VALUE("Iterable, AsyncIterable or Stream", "source", ret);
            }
          } else if (isIterable(stream) || isReadableNodeStream(stream) || isTransformStream(stream)) {
            ret = stream;
          } else {
            ret = Duplex.from(stream);
          }
        } else if (typeof stream === "function") {
          if (isTransformStream(ret)) {
            var _ret;
            ret = makeAsyncIterable((_ret = ret) === null || _ret === void 0 ? void 0 : _ret.readable);
          } else {
            ret = makeAsyncIterable(ret);
          }
          ret = stream(ret, {
            signal
          });
          if (reading) {
            if (!isIterable(ret, true)) {
              throw new ERR_INVALID_RETURN_VALUE("AsyncIterable", `transform[${i - 1}]`, ret);
            }
          } else {
            var _ret2;
            if (!PassThrough) {
              PassThrough = require_passthrough();
            }
            const pt = new PassThrough({
              objectMode: true
            });
            const then = (_ret2 = ret) === null || _ret2 === void 0 ? void 0 : _ret2.then;
            if (typeof then === "function") {
              finishCount++;
              then.call(
                ret,
                (val) => {
                  value = val;
                  if (val != null) {
                    pt.write(val);
                  }
                  if (end) {
                    pt.end();
                  }
                  process.nextTick(finish);
                },
                (err) => {
                  pt.destroy(err);
                  process.nextTick(finish, err);
                }
              );
            } else if (isIterable(ret, true)) {
              finishCount++;
              pumpToNode(ret, pt, finish, {
                end
              });
            } else if (isReadableStream(ret) || isTransformStream(ret)) {
              const toRead = ret.readable || ret;
              finishCount++;
              pumpToNode(toRead, pt, finish, {
                end
              });
            } else {
              throw new ERR_INVALID_RETURN_VALUE("AsyncIterable or Promise", "destination", ret);
            }
            ret = pt;
            const { destroy, cleanup } = destroyer(ret, false, true);
            destroys.push(destroy);
            if (isLastStream) {
              lastStreamCleanup.push(cleanup);
            }
          }
        } else if (isNodeStream(stream)) {
          if (isReadableNodeStream(ret)) {
            finishCount += 2;
            const cleanup = pipe(ret, stream, finish, {
              end
            });
            if (isReadable2(stream) && isLastStream) {
              lastStreamCleanup.push(cleanup);
            }
          } else if (isTransformStream(ret) || isReadableStream(ret)) {
            const toRead = ret.readable || ret;
            finishCount++;
            pumpToNode(toRead, stream, finish, {
              end
            });
          } else if (isIterable(ret)) {
            finishCount++;
            pumpToNode(ret, stream, finish, {
              end
            });
          } else {
            throw new ERR_INVALID_ARG_TYPE(
              "val",
              ["Readable", "Iterable", "AsyncIterable", "ReadableStream", "TransformStream"],
              ret
            );
          }
          ret = stream;
        } else if (isWebStream(stream)) {
          if (isReadableNodeStream(ret)) {
            finishCount++;
            pumpToWeb(makeAsyncIterable(ret), stream, finish, {
              end
            });
          } else if (isReadableStream(ret) || isIterable(ret)) {
            finishCount++;
            pumpToWeb(ret, stream, finish, {
              end
            });
          } else if (isTransformStream(ret)) {
            finishCount++;
            pumpToWeb(ret.readable, stream, finish, {
              end
            });
          } else {
            throw new ERR_INVALID_ARG_TYPE(
              "val",
              ["Readable", "Iterable", "AsyncIterable", "ReadableStream", "TransformStream"],
              ret
            );
          }
          ret = stream;
        } else {
          ret = Duplex.from(stream);
        }
      }
      if (signal !== null && signal !== void 0 && signal.aborted || outerSignal !== null && outerSignal !== void 0 && outerSignal.aborted) {
        process.nextTick(abort);
      }
      return ret;
    }
    function pipe(src, dst, finish, { end }) {
      let ended = false;
      dst.on("close", () => {
        if (!ended) {
          finish(new ERR_STREAM_PREMATURE_CLOSE());
        }
      });
      src.pipe(dst, {
        end: false
      });
      if (end) {
        let endFn2 = function() {
          ended = true;
          dst.end();
        };
        var endFn = endFn2;
        if (isReadableFinished(src)) {
          process.nextTick(endFn2);
        } else {
          src.once("end", endFn2);
        }
      } else {
        finish();
      }
      eos(
        src,
        {
          readable: true,
          writable: false
        },
        (err) => {
          const rState = src._readableState;
          if (err && err.code === "ERR_STREAM_PREMATURE_CLOSE" && rState && rState.ended && !rState.errored && !rState.errorEmitted) {
            src.once("end", finish).once("error", finish);
          } else {
            finish(err);
          }
        }
      );
      return eos(
        dst,
        {
          readable: false,
          writable: true
        },
        finish
      );
    }
    module.exports = {
      pipelineImpl,
      pipeline
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/compose.js
var require_compose = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/compose.js"(exports, module) {
    "use strict";
    var { pipeline } = require_pipeline();
    var Duplex = require_duplex();
    var { destroyer } = require_destroy();
    var {
      isNodeStream,
      isReadable: isReadable2,
      isWritable,
      isWebStream,
      isTransformStream,
      isWritableStream,
      isReadableStream
    } = require_utils();
    var {
      AbortError,
      codes: { ERR_INVALID_ARG_VALUE, ERR_MISSING_ARGS }
    } = require_errors();
    var eos = require_end_of_stream();
    module.exports = function compose(...streams) {
      if (streams.length === 0) {
        throw new ERR_MISSING_ARGS("streams");
      }
      if (streams.length === 1) {
        return Duplex.from(streams[0]);
      }
      const orgStreams = [...streams];
      if (typeof streams[0] === "function") {
        streams[0] = Duplex.from(streams[0]);
      }
      if (typeof streams[streams.length - 1] === "function") {
        const idx = streams.length - 1;
        streams[idx] = Duplex.from(streams[idx]);
      }
      for (let n = 0; n < streams.length; ++n) {
        if (!isNodeStream(streams[n]) && !isWebStream(streams[n])) {
          continue;
        }
        if (n < streams.length - 1 && !(isReadable2(streams[n]) || isReadableStream(streams[n]) || isTransformStream(streams[n]))) {
          throw new ERR_INVALID_ARG_VALUE(`streams[${n}]`, orgStreams[n], "must be readable");
        }
        if (n > 0 && !(isWritable(streams[n]) || isWritableStream(streams[n]) || isTransformStream(streams[n]))) {
          throw new ERR_INVALID_ARG_VALUE(`streams[${n}]`, orgStreams[n], "must be writable");
        }
      }
      let ondrain;
      let onfinish;
      let onreadable;
      let onclose;
      let d;
      function onfinished(err) {
        const cb = onclose;
        onclose = null;
        if (cb) {
          cb(err);
        } else if (err) {
          d.destroy(err);
        } else if (!readable && !writable) {
          d.destroy();
        }
      }
      const head = streams[0];
      const tail = pipeline(streams, onfinished);
      const writable = !!(isWritable(head) || isWritableStream(head) || isTransformStream(head));
      const readable = !!(isReadable2(tail) || isReadableStream(tail) || isTransformStream(tail));
      d = new Duplex({
        // TODO (ronag): highWaterMark?
        writableObjectMode: !!(head !== null && head !== void 0 && head.writableObjectMode),
        readableObjectMode: !!(tail !== null && tail !== void 0 && tail.readableObjectMode),
        writable,
        readable
      });
      if (writable) {
        if (isNodeStream(head)) {
          d._write = function(chunk, encoding, callback) {
            if (head.write(chunk, encoding)) {
              callback();
            } else {
              ondrain = callback;
            }
          };
          d._final = function(callback) {
            head.end();
            onfinish = callback;
          };
          head.on("drain", function() {
            if (ondrain) {
              const cb = ondrain;
              ondrain = null;
              cb();
            }
          });
        } else if (isWebStream(head)) {
          const writable2 = isTransformStream(head) ? head.writable : head;
          const writer = writable2.getWriter();
          d._write = async function(chunk, encoding, callback) {
            try {
              await writer.ready;
              writer.write(chunk).catch(() => {
              });
              callback();
            } catch (err) {
              callback(err);
            }
          };
          d._final = async function(callback) {
            try {
              await writer.ready;
              writer.close().catch(() => {
              });
              onfinish = callback;
            } catch (err) {
              callback(err);
            }
          };
        }
        const toRead = isTransformStream(tail) ? tail.readable : tail;
        eos(toRead, () => {
          if (onfinish) {
            const cb = onfinish;
            onfinish = null;
            cb();
          }
        });
      }
      if (readable) {
        if (isNodeStream(tail)) {
          tail.on("readable", function() {
            if (onreadable) {
              const cb = onreadable;
              onreadable = null;
              cb();
            }
          });
          tail.on("end", function() {
            d.push(null);
          });
          d._read = function() {
            while (true) {
              const buf = tail.read();
              if (buf === null) {
                onreadable = d._read;
                return;
              }
              if (!d.push(buf)) {
                return;
              }
            }
          };
        } else if (isWebStream(tail)) {
          const readable2 = isTransformStream(tail) ? tail.readable : tail;
          const reader = readable2.getReader();
          d._read = async function() {
            while (true) {
              try {
                const { value, done } = await reader.read();
                if (!d.push(value)) {
                  return;
                }
                if (done) {
                  d.push(null);
                  return;
                }
              } catch {
                return;
              }
            }
          };
        }
      }
      d._destroy = function(err, callback) {
        if (!err && onclose !== null) {
          err = new AbortError();
        }
        onreadable = null;
        ondrain = null;
        onfinish = null;
        if (onclose === null) {
          callback(err);
        } else {
          onclose = callback;
          if (isNodeStream(tail)) {
            destroyer(tail, err);
          }
        }
      };
      return d;
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/operators.js
var require_operators = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/operators.js"(exports, module) {
    "use strict";
    var AbortController = globalThis.AbortController || require_browser().AbortController;
    var {
      codes: { ERR_INVALID_ARG_VALUE, ERR_INVALID_ARG_TYPE, ERR_MISSING_ARGS, ERR_OUT_OF_RANGE },
      AbortError
    } = require_errors();
    var { validateAbortSignal, validateInteger, validateObject } = require_validators();
    var kWeakHandler = require_primordials().Symbol("kWeak");
    var kResistStopPropagation = require_primordials().Symbol("kResistStopPropagation");
    var { finished } = require_end_of_stream();
    var staticCompose = require_compose();
    var { addAbortSignalNoValidate } = require_add_abort_signal();
    var { isWritable, isNodeStream } = require_utils();
    var { deprecate } = require_util();
    var {
      ArrayPrototypePush,
      Boolean: Boolean2,
      MathFloor,
      Number: Number2,
      NumberIsNaN,
      Promise: Promise2,
      PromiseReject,
      PromiseResolve,
      PromisePrototypeThen,
      Symbol: Symbol2
    } = require_primordials();
    var kEmpty = Symbol2("kEmpty");
    var kEof = Symbol2("kEof");
    function compose(stream, options) {
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      if (isNodeStream(stream) && !isWritable(stream)) {
        throw new ERR_INVALID_ARG_VALUE("stream", stream, "must be writable");
      }
      const composedStream = staticCompose(this, stream);
      if (options !== null && options !== void 0 && options.signal) {
        addAbortSignalNoValidate(options.signal, composedStream);
      }
      return composedStream;
    }
    function map(fn, options) {
      if (typeof fn !== "function") {
        throw new ERR_INVALID_ARG_TYPE("fn", ["Function", "AsyncFunction"], fn);
      }
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      let concurrency = 1;
      if ((options === null || options === void 0 ? void 0 : options.concurrency) != null) {
        concurrency = MathFloor(options.concurrency);
      }
      let highWaterMark = concurrency - 1;
      if ((options === null || options === void 0 ? void 0 : options.highWaterMark) != null) {
        highWaterMark = MathFloor(options.highWaterMark);
      }
      validateInteger(concurrency, "options.concurrency", 1);
      validateInteger(highWaterMark, "options.highWaterMark", 0);
      highWaterMark += concurrency;
      return (async function* map2() {
        const signal = require_util().AbortSignalAny(
          [options === null || options === void 0 ? void 0 : options.signal].filter(Boolean2)
        );
        const stream = this;
        const queue = [];
        const signalOpt = {
          signal
        };
        let next;
        let resume;
        let done = false;
        let cnt = 0;
        function onCatch() {
          done = true;
          afterItemProcessed();
        }
        function afterItemProcessed() {
          cnt -= 1;
          maybeResume();
        }
        function maybeResume() {
          if (resume && !done && cnt < concurrency && queue.length < highWaterMark) {
            resume();
            resume = null;
          }
        }
        async function pump() {
          try {
            for await (let val of stream) {
              if (done) {
                return;
              }
              if (signal.aborted) {
                throw new AbortError();
              }
              try {
                val = fn(val, signalOpt);
                if (val === kEmpty) {
                  continue;
                }
                val = PromiseResolve(val);
              } catch (err) {
                val = PromiseReject(err);
              }
              cnt += 1;
              PromisePrototypeThen(val, afterItemProcessed, onCatch);
              queue.push(val);
              if (next) {
                next();
                next = null;
              }
              if (!done && (queue.length >= highWaterMark || cnt >= concurrency)) {
                await new Promise2((resolve2) => {
                  resume = resolve2;
                });
              }
            }
            queue.push(kEof);
          } catch (err) {
            const val = PromiseReject(err);
            PromisePrototypeThen(val, afterItemProcessed, onCatch);
            queue.push(val);
          } finally {
            done = true;
            if (next) {
              next();
              next = null;
            }
          }
        }
        pump();
        try {
          while (true) {
            while (queue.length > 0) {
              const val = await queue[0];
              if (val === kEof) {
                return;
              }
              if (signal.aborted) {
                throw new AbortError();
              }
              if (val !== kEmpty) {
                yield val;
              }
              queue.shift();
              maybeResume();
            }
            await new Promise2((resolve2) => {
              next = resolve2;
            });
          }
        } finally {
          done = true;
          if (resume) {
            resume();
            resume = null;
          }
        }
      }).call(this);
    }
    function asIndexedPairs(options = void 0) {
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      return (async function* asIndexedPairs2() {
        let index = 0;
        for await (const val of this) {
          var _options$signal;
          if (options !== null && options !== void 0 && (_options$signal = options.signal) !== null && _options$signal !== void 0 && _options$signal.aborted) {
            throw new AbortError({
              cause: options.signal.reason
            });
          }
          yield [index++, val];
        }
      }).call(this);
    }
    async function some(fn, options = void 0) {
      for await (const unused of filter.call(this, fn, options)) {
        return true;
      }
      return false;
    }
    async function every(fn, options = void 0) {
      if (typeof fn !== "function") {
        throw new ERR_INVALID_ARG_TYPE("fn", ["Function", "AsyncFunction"], fn);
      }
      return !await some.call(
        this,
        async (...args) => {
          return !await fn(...args);
        },
        options
      );
    }
    async function find(fn, options) {
      for await (const result of filter.call(this, fn, options)) {
        return result;
      }
      return void 0;
    }
    async function forEach(fn, options) {
      if (typeof fn !== "function") {
        throw new ERR_INVALID_ARG_TYPE("fn", ["Function", "AsyncFunction"], fn);
      }
      async function forEachFn(value, options2) {
        await fn(value, options2);
        return kEmpty;
      }
      for await (const unused of map.call(this, forEachFn, options)) ;
    }
    function filter(fn, options) {
      if (typeof fn !== "function") {
        throw new ERR_INVALID_ARG_TYPE("fn", ["Function", "AsyncFunction"], fn);
      }
      async function filterFn(value, options2) {
        if (await fn(value, options2)) {
          return value;
        }
        return kEmpty;
      }
      return map.call(this, filterFn, options);
    }
    var ReduceAwareErrMissingArgs = class extends ERR_MISSING_ARGS {
      constructor() {
        super("reduce");
        this.message = "Reduce of an empty stream requires an initial value";
      }
    };
    async function reduce(reducer, initialValue, options) {
      var _options$signal2;
      if (typeof reducer !== "function") {
        throw new ERR_INVALID_ARG_TYPE("reducer", ["Function", "AsyncFunction"], reducer);
      }
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      let hasInitialValue = arguments.length > 1;
      if (options !== null && options !== void 0 && (_options$signal2 = options.signal) !== null && _options$signal2 !== void 0 && _options$signal2.aborted) {
        const err = new AbortError(void 0, {
          cause: options.signal.reason
        });
        this.once("error", () => {
        });
        await finished(this.destroy(err));
        throw err;
      }
      const ac = new AbortController();
      const signal = ac.signal;
      if (options !== null && options !== void 0 && options.signal) {
        const opts = {
          once: true,
          [kWeakHandler]: this,
          [kResistStopPropagation]: true
        };
        options.signal.addEventListener("abort", () => ac.abort(), opts);
      }
      let gotAnyItemFromStream = false;
      try {
        for await (const value of this) {
          var _options$signal3;
          gotAnyItemFromStream = true;
          if (options !== null && options !== void 0 && (_options$signal3 = options.signal) !== null && _options$signal3 !== void 0 && _options$signal3.aborted) {
            throw new AbortError();
          }
          if (!hasInitialValue) {
            initialValue = value;
            hasInitialValue = true;
          } else {
            initialValue = await reducer(initialValue, value, {
              signal
            });
          }
        }
        if (!gotAnyItemFromStream && !hasInitialValue) {
          throw new ReduceAwareErrMissingArgs();
        }
      } finally {
        ac.abort();
      }
      return initialValue;
    }
    async function toArray(options) {
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      const result = [];
      for await (const val of this) {
        var _options$signal4;
        if (options !== null && options !== void 0 && (_options$signal4 = options.signal) !== null && _options$signal4 !== void 0 && _options$signal4.aborted) {
          throw new AbortError(void 0, {
            cause: options.signal.reason
          });
        }
        ArrayPrototypePush(result, val);
      }
      return result;
    }
    function flatMap(fn, options) {
      const values = map.call(this, fn, options);
      return (async function* flatMap2() {
        for await (const val of values) {
          yield* val;
        }
      }).call(this);
    }
    function toIntegerOrInfinity(number) {
      number = Number2(number);
      if (NumberIsNaN(number)) {
        return 0;
      }
      if (number < 0) {
        throw new ERR_OUT_OF_RANGE("number", ">= 0", number);
      }
      return number;
    }
    function drop(number, options = void 0) {
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      number = toIntegerOrInfinity(number);
      return (async function* drop2() {
        var _options$signal5;
        if (options !== null && options !== void 0 && (_options$signal5 = options.signal) !== null && _options$signal5 !== void 0 && _options$signal5.aborted) {
          throw new AbortError();
        }
        for await (const val of this) {
          var _options$signal6;
          if (options !== null && options !== void 0 && (_options$signal6 = options.signal) !== null && _options$signal6 !== void 0 && _options$signal6.aborted) {
            throw new AbortError();
          }
          if (number-- <= 0) {
            yield val;
          }
        }
      }).call(this);
    }
    function take(number, options = void 0) {
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      number = toIntegerOrInfinity(number);
      return (async function* take2() {
        var _options$signal7;
        if (options !== null && options !== void 0 && (_options$signal7 = options.signal) !== null && _options$signal7 !== void 0 && _options$signal7.aborted) {
          throw new AbortError();
        }
        for await (const val of this) {
          var _options$signal8;
          if (options !== null && options !== void 0 && (_options$signal8 = options.signal) !== null && _options$signal8 !== void 0 && _options$signal8.aborted) {
            throw new AbortError();
          }
          if (number-- > 0) {
            yield val;
          }
          if (number <= 0) {
            return;
          }
        }
      }).call(this);
    }
    module.exports.streamReturningOperators = {
      asIndexedPairs: deprecate(asIndexedPairs, "readable.asIndexedPairs will be removed in a future version."),
      drop,
      filter,
      flatMap,
      map,
      take,
      compose
    };
    module.exports.promiseReturningOperators = {
      every,
      forEach,
      reduce,
      toArray,
      some,
      find
    };
  }
});

// node_modules/readable-stream/lib/stream/promises.js
var require_promises = __commonJS({
  "node_modules/readable-stream/lib/stream/promises.js"(exports, module) {
    "use strict";
    var { ArrayPrototypePop, Promise: Promise2 } = require_primordials();
    var { isIterable, isNodeStream, isWebStream } = require_utils();
    var { pipelineImpl: pl } = require_pipeline();
    var { finished } = require_end_of_stream();
    require_stream();
    function pipeline(...streams) {
      return new Promise2((resolve2, reject) => {
        let signal;
        let end;
        const lastArg = streams[streams.length - 1];
        if (lastArg && typeof lastArg === "object" && !isNodeStream(lastArg) && !isIterable(lastArg) && !isWebStream(lastArg)) {
          const options = ArrayPrototypePop(streams);
          signal = options.signal;
          end = options.end;
        }
        pl(
          streams,
          (err, value) => {
            if (err) {
              reject(err);
            } else {
              resolve2(value);
            }
          },
          {
            signal,
            end
          }
        );
      });
    }
    module.exports = {
      finished,
      pipeline
    };
  }
});

// node_modules/readable-stream/lib/stream.js
var require_stream = __commonJS({
  "node_modules/readable-stream/lib/stream.js"(exports, module) {
    "use strict";
    var { Buffer: Buffer4 } = require_buffer();
    var { ObjectDefineProperty, ObjectKeys, ReflectApply } = require_primordials();
    var {
      promisify: { custom: customPromisify }
    } = require_util();
    var { streamReturningOperators, promiseReturningOperators } = require_operators();
    var {
      codes: { ERR_ILLEGAL_CONSTRUCTOR }
    } = require_errors();
    var compose = require_compose();
    var { setDefaultHighWaterMark, getDefaultHighWaterMark } = require_state();
    var { pipeline } = require_pipeline();
    var { destroyer } = require_destroy();
    var eos = require_end_of_stream();
    var promises = require_promises();
    var utils = require_utils();
    var Stream = module.exports = require_legacy().Stream;
    Stream.isDestroyed = utils.isDestroyed;
    Stream.isDisturbed = utils.isDisturbed;
    Stream.isErrored = utils.isErrored;
    Stream.isReadable = utils.isReadable;
    Stream.isWritable = utils.isWritable;
    Stream.Readable = require_readable();
    for (const key of ObjectKeys(streamReturningOperators)) {
      let fn = function(...args) {
        if (new.target) {
          throw ERR_ILLEGAL_CONSTRUCTOR();
        }
        return Stream.Readable.from(ReflectApply(op, this, args));
      };
      const op = streamReturningOperators[key];
      ObjectDefineProperty(fn, "name", {
        __proto__: null,
        value: op.name
      });
      ObjectDefineProperty(fn, "length", {
        __proto__: null,
        value: op.length
      });
      ObjectDefineProperty(Stream.Readable.prototype, key, {
        __proto__: null,
        value: fn,
        enumerable: false,
        configurable: true,
        writable: true
      });
    }
    for (const key of ObjectKeys(promiseReturningOperators)) {
      let fn = function(...args) {
        if (new.target) {
          throw ERR_ILLEGAL_CONSTRUCTOR();
        }
        return ReflectApply(op, this, args);
      };
      const op = promiseReturningOperators[key];
      ObjectDefineProperty(fn, "name", {
        __proto__: null,
        value: op.name
      });
      ObjectDefineProperty(fn, "length", {
        __proto__: null,
        value: op.length
      });
      ObjectDefineProperty(Stream.Readable.prototype, key, {
        __proto__: null,
        value: fn,
        enumerable: false,
        configurable: true,
        writable: true
      });
    }
    Stream.Writable = require_writable();
    Stream.Duplex = require_duplex();
    Stream.Transform = require_transform();
    Stream.PassThrough = require_passthrough();
    Stream.pipeline = pipeline;
    var { addAbortSignal } = require_add_abort_signal();
    Stream.addAbortSignal = addAbortSignal;
    Stream.finished = eos;
    Stream.destroy = destroyer;
    Stream.compose = compose;
    Stream.setDefaultHighWaterMark = setDefaultHighWaterMark;
    Stream.getDefaultHighWaterMark = getDefaultHighWaterMark;
    ObjectDefineProperty(Stream, "promises", {
      __proto__: null,
      configurable: true,
      enumerable: true,
      get() {
        return promises;
      }
    });
    ObjectDefineProperty(pipeline, customPromisify, {
      __proto__: null,
      enumerable: true,
      get() {
        return promises.pipeline;
      }
    });
    ObjectDefineProperty(eos, customPromisify, {
      __proto__: null,
      enumerable: true,
      get() {
        return promises.finished;
      }
    });
    Stream.Stream = Stream;
    Stream._isUint8Array = function isUint8Array(value) {
      return value instanceof Uint8Array;
    };
    Stream._uint8ArrayToBuffer = function _uint8ArrayToBuffer(chunk) {
      return Buffer4.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
    };
  }
});

// node_modules/readable-stream/lib/ours/browser.js
var require_browser3 = __commonJS({
  "node_modules/readable-stream/lib/ours/browser.js"(exports, module) {
    "use strict";
    var CustomStream = require_stream();
    var promises = require_promises();
    var originalDestroy = CustomStream.Readable.destroy;
    module.exports = CustomStream.Readable;
    module.exports._uint8ArrayToBuffer = CustomStream._uint8ArrayToBuffer;
    module.exports._isUint8Array = CustomStream._isUint8Array;
    module.exports.isDisturbed = CustomStream.isDisturbed;
    module.exports.isErrored = CustomStream.isErrored;
    module.exports.isReadable = CustomStream.isReadable;
    module.exports.Readable = CustomStream.Readable;
    module.exports.Writable = CustomStream.Writable;
    module.exports.Duplex = CustomStream.Duplex;
    module.exports.Transform = CustomStream.Transform;
    module.exports.PassThrough = CustomStream.PassThrough;
    module.exports.addAbortSignal = CustomStream.addAbortSignal;
    module.exports.finished = CustomStream.finished;
    module.exports.destroy = CustomStream.destroy;
    module.exports.destroy = originalDestroy;
    module.exports.pipeline = CustomStream.pipeline;
    module.exports.compose = CustomStream.compose;
    Object.defineProperty(CustomStream, "promises", {
      configurable: true,
      enumerable: true,
      get() {
        return promises;
      }
    });
    module.exports.Stream = CustomStream.Stream;
    module.exports.default = module.exports;
  }
});

// node_modules/@zenfs/core/dist/error.js
var Errno;
(function(Errno2) {
  Errno2[Errno2["EPERM"] = 1] = "EPERM";
  Errno2[Errno2["ENOENT"] = 2] = "ENOENT";
  Errno2[Errno2["EINTR"] = 4] = "EINTR";
  Errno2[Errno2["EIO"] = 5] = "EIO";
  Errno2[Errno2["ENXIO"] = 6] = "ENXIO";
  Errno2[Errno2["EBADF"] = 9] = "EBADF";
  Errno2[Errno2["EAGAIN"] = 11] = "EAGAIN";
  Errno2[Errno2["ENOMEM"] = 12] = "ENOMEM";
  Errno2[Errno2["EACCES"] = 13] = "EACCES";
  Errno2[Errno2["EFAULT"] = 14] = "EFAULT";
  Errno2[Errno2["ENOTBLK"] = 15] = "ENOTBLK";
  Errno2[Errno2["EBUSY"] = 16] = "EBUSY";
  Errno2[Errno2["EEXIST"] = 17] = "EEXIST";
  Errno2[Errno2["EXDEV"] = 18] = "EXDEV";
  Errno2[Errno2["ENODEV"] = 19] = "ENODEV";
  Errno2[Errno2["ENOTDIR"] = 20] = "ENOTDIR";
  Errno2[Errno2["EISDIR"] = 21] = "EISDIR";
  Errno2[Errno2["EINVAL"] = 22] = "EINVAL";
  Errno2[Errno2["ENFILE"] = 23] = "ENFILE";
  Errno2[Errno2["EMFILE"] = 24] = "EMFILE";
  Errno2[Errno2["ETXTBSY"] = 26] = "ETXTBSY";
  Errno2[Errno2["EFBIG"] = 27] = "EFBIG";
  Errno2[Errno2["ENOSPC"] = 28] = "ENOSPC";
  Errno2[Errno2["ESPIPE"] = 29] = "ESPIPE";
  Errno2[Errno2["EROFS"] = 30] = "EROFS";
  Errno2[Errno2["EMLINK"] = 31] = "EMLINK";
  Errno2[Errno2["EPIPE"] = 32] = "EPIPE";
  Errno2[Errno2["EDOM"] = 33] = "EDOM";
  Errno2[Errno2["ERANGE"] = 34] = "ERANGE";
  Errno2[Errno2["EDEADLK"] = 35] = "EDEADLK";
  Errno2[Errno2["ENAMETOOLONG"] = 36] = "ENAMETOOLONG";
  Errno2[Errno2["ENOLCK"] = 37] = "ENOLCK";
  Errno2[Errno2["ENOSYS"] = 38] = "ENOSYS";
  Errno2[Errno2["ENOTEMPTY"] = 39] = "ENOTEMPTY";
  Errno2[Errno2["ELOOP"] = 40] = "ELOOP";
  Errno2[Errno2["ENOMSG"] = 42] = "ENOMSG";
  Errno2[Errno2["EBADE"] = 52] = "EBADE";
  Errno2[Errno2["EBADR"] = 53] = "EBADR";
  Errno2[Errno2["EXFULL"] = 54] = "EXFULL";
  Errno2[Errno2["ENOANO"] = 55] = "ENOANO";
  Errno2[Errno2["EBADRQC"] = 56] = "EBADRQC";
  Errno2[Errno2["ENOSTR"] = 60] = "ENOSTR";
  Errno2[Errno2["ENODATA"] = 61] = "ENODATA";
  Errno2[Errno2["ETIME"] = 62] = "ETIME";
  Errno2[Errno2["ENOSR"] = 63] = "ENOSR";
  Errno2[Errno2["ENONET"] = 64] = "ENONET";
  Errno2[Errno2["EREMOTE"] = 66] = "EREMOTE";
  Errno2[Errno2["ENOLINK"] = 67] = "ENOLINK";
  Errno2[Errno2["ECOMM"] = 70] = "ECOMM";
  Errno2[Errno2["EPROTO"] = 71] = "EPROTO";
  Errno2[Errno2["EBADMSG"] = 74] = "EBADMSG";
  Errno2[Errno2["EOVERFLOW"] = 75] = "EOVERFLOW";
  Errno2[Errno2["EBADFD"] = 77] = "EBADFD";
  Errno2[Errno2["ESTRPIPE"] = 86] = "ESTRPIPE";
  Errno2[Errno2["ENOTSOCK"] = 88] = "ENOTSOCK";
  Errno2[Errno2["EDESTADDRREQ"] = 89] = "EDESTADDRREQ";
  Errno2[Errno2["EMSGSIZE"] = 90] = "EMSGSIZE";
  Errno2[Errno2["EPROTOTYPE"] = 91] = "EPROTOTYPE";
  Errno2[Errno2["ENOPROTOOPT"] = 92] = "ENOPROTOOPT";
  Errno2[Errno2["EPROTONOSUPPORT"] = 93] = "EPROTONOSUPPORT";
  Errno2[Errno2["ESOCKTNOSUPPORT"] = 94] = "ESOCKTNOSUPPORT";
  Errno2[Errno2["ENOTSUP"] = 95] = "ENOTSUP";
  Errno2[Errno2["ENETDOWN"] = 100] = "ENETDOWN";
  Errno2[Errno2["ENETUNREACH"] = 101] = "ENETUNREACH";
  Errno2[Errno2["ENETRESET"] = 102] = "ENETRESET";
  Errno2[Errno2["ETIMEDOUT"] = 110] = "ETIMEDOUT";
  Errno2[Errno2["ECONNREFUSED"] = 111] = "ECONNREFUSED";
  Errno2[Errno2["EHOSTDOWN"] = 112] = "EHOSTDOWN";
  Errno2[Errno2["EHOSTUNREACH"] = 113] = "EHOSTUNREACH";
  Errno2[Errno2["EALREADY"] = 114] = "EALREADY";
  Errno2[Errno2["EINPROGRESS"] = 115] = "EINPROGRESS";
  Errno2[Errno2["ESTALE"] = 116] = "ESTALE";
  Errno2[Errno2["EREMOTEIO"] = 121] = "EREMOTEIO";
  Errno2[Errno2["EDQUOT"] = 122] = "EDQUOT";
})(Errno || (Errno = {}));
var errorMessages = {
  [Errno.EPERM]: "Operation not permitted",
  [Errno.ENOENT]: "No such file or directory",
  [Errno.EINTR]: "Interrupted system call",
  [Errno.EIO]: "Input/output error",
  [Errno.ENXIO]: "No such device or address",
  [Errno.EBADF]: "Bad file descriptor",
  [Errno.EAGAIN]: "Resource temporarily unavailable",
  [Errno.ENOMEM]: "Cannot allocate memory",
  [Errno.EACCES]: "Permission denied",
  [Errno.EFAULT]: "Bad address",
  [Errno.ENOTBLK]: "Block device required",
  [Errno.EBUSY]: "Resource busy or locked",
  [Errno.EEXIST]: "File exists",
  [Errno.EXDEV]: "Invalid cross-device link",
  [Errno.ENODEV]: "No such device",
  [Errno.ENOTDIR]: "File is not a directory",
  [Errno.EISDIR]: "File is a directory",
  [Errno.EINVAL]: "Invalid argument",
  [Errno.ENFILE]: "Too many open files in system",
  [Errno.EMFILE]: "Too many open files",
  [Errno.ETXTBSY]: "Text file busy",
  [Errno.EFBIG]: "File is too big",
  [Errno.ENOSPC]: "No space left on disk",
  [Errno.ESPIPE]: "Illegal seek",
  [Errno.EROFS]: "Cannot modify a read-only file system",
  [Errno.EMLINK]: "Too many links",
  [Errno.EPIPE]: "Broken pipe",
  [Errno.EDOM]: "Numerical argument out of domain",
  [Errno.ERANGE]: "Numerical result out of range",
  [Errno.EDEADLK]: "Resource deadlock would occur",
  [Errno.ENAMETOOLONG]: "File name too long",
  [Errno.ENOLCK]: "No locks available",
  [Errno.ENOSYS]: "Function not implemented",
  [Errno.ENOTEMPTY]: "Directory is not empty",
  [Errno.ELOOP]: "Too many levels of symbolic links",
  [Errno.ENOMSG]: "No message of desired type",
  [Errno.EBADE]: "Invalid exchange",
  [Errno.EBADR]: "Invalid request descriptor",
  [Errno.EXFULL]: "Exchange full",
  [Errno.ENOANO]: "No anode",
  [Errno.EBADRQC]: "Invalid request code",
  [Errno.ENOSTR]: "Device not a stream",
  [Errno.ENODATA]: "No data available",
  [Errno.ETIME]: "Timer expired",
  [Errno.ENOSR]: "Out of streams resources",
  [Errno.ENONET]: "Machine is not on the network",
  [Errno.EREMOTE]: "Object is remote",
  [Errno.ENOLINK]: "Link has been severed",
  [Errno.ECOMM]: "Communication error on send",
  [Errno.EPROTO]: "Protocol error",
  [Errno.EBADMSG]: "Bad message",
  [Errno.EOVERFLOW]: "Value too large for defined data type",
  [Errno.EBADFD]: "File descriptor in bad state",
  [Errno.ESTRPIPE]: "Streams pipe error",
  [Errno.ENOTSOCK]: "Socket operation on non-socket",
  [Errno.EDESTADDRREQ]: "Destination address required",
  [Errno.EMSGSIZE]: "Message too long",
  [Errno.EPROTOTYPE]: "Protocol wrong type for socket",
  [Errno.ENOPROTOOPT]: "Protocol not available",
  [Errno.EPROTONOSUPPORT]: "Protocol not supported",
  [Errno.ESOCKTNOSUPPORT]: "Socket type not supported",
  [Errno.ENOTSUP]: "Operation is not supported",
  [Errno.ENETDOWN]: "Network is down",
  [Errno.ENETUNREACH]: "Network is unreachable",
  [Errno.ENETRESET]: "Network dropped connection on reset",
  [Errno.ETIMEDOUT]: "Connection timed out",
  [Errno.ECONNREFUSED]: "Connection refused",
  [Errno.EHOSTDOWN]: "Host is down",
  [Errno.EHOSTUNREACH]: "No route to host",
  [Errno.EALREADY]: "Operation already in progress",
  [Errno.EINPROGRESS]: "Operation now in progress",
  [Errno.ESTALE]: "Stale file handle",
  [Errno.EREMOTEIO]: "Remote I/O error",
  [Errno.EDQUOT]: "Disk quota exceeded"
};
var ErrnoError = class _ErrnoError extends Error {
  static fromJSON(json) {
    const err = new _ErrnoError(json.errno, json.message, json.path, json.syscall);
    err.code = json.code;
    err.stack = json.stack;
    return err;
  }
  static With(code, path, syscall) {
    return new _ErrnoError(Errno[code], errorMessages[Errno[code]], path, syscall);
  }
  constructor(errno, message = errorMessages[errno], path, syscall = "") {
    super(message);
    this.errno = errno;
    this.message = message;
    this.path = path;
    this.syscall = syscall;
    this.code = Errno[errno];
  }
  /**
   * @returns A friendly error message.
   */
  toString() {
    return this.code + ": " + this.message + (this.path ? `, '${this.path}'` : "");
  }
  toJSON() {
    return {
      errno: this.errno,
      code: this.code,
      path: this.path,
      stack: this.stack,
      message: this.message,
      syscall: this.syscall
    };
  }
  /**
   * The size of the API error in buffer-form in bytes.
   */
  bufferSize() {
    return 4 + JSON.stringify(this.toJSON()).length;
  }
};

// node_modules/@zenfs/core/dist/backends/backend.js
function isBackend(arg) {
  return arg != null && typeof arg == "object" && "create" in arg && typeof arg.create == "function";
}
async function checkOptions(backend, options) {
  if (typeof options != "object" || options === null) {
    throw new ErrnoError(Errno.EINVAL, "Invalid options");
  }
  for (const [optName, opt] of Object.entries(backend.options)) {
    const value = options === null || options === void 0 ? void 0 : options[optName];
    if (value === void 0 || value === null) {
      if (!opt.required) {
        continue;
      }
      throw new ErrnoError(Errno.EINVAL, "Missing required option: " + optName);
    }
    const isType2 = (value2) => typeof opt.type == "function" ? value2 instanceof opt.type : typeof value2 === opt.type;
    if (Array.isArray(opt.type) ? !opt.type.some(isType2) : !isType2(value)) {
      const type = typeof value == "object" && "constructor" in value ? value.constructor.name : typeof value;
      const name = (type2) => typeof type2 == "function" ? type2.name : type2;
      const expected = Array.isArray(opt.type) ? `one of ${opt.type.map(name).join(", ")}` : name(opt.type);
      throw new ErrnoError(Errno.EINVAL, `Incorrect type for "${optName}": ${type} (expected ${expected})`);
    }
    if (opt.validator) {
      await opt.validator(value);
    }
  }
}
function isBackendConfig(arg) {
  return arg != null && typeof arg == "object" && "backend" in arg && isBackend(arg.backend);
}

// node_modules/eventemitter3/index.mjs
var import_index = __toESM(require_eventemitter3(), 1);

// node_modules/utilium/dist/list.js
var _a;
var List = class extends import_index.default {
  constructor(values) {
    super();
    __publicField(this, _a, "List");
    __publicField(this, "data", /* @__PURE__ */ new Set());
    if (values) {
      this.push(...values);
    }
  }
  toSet() {
    return new Set(this.data);
  }
  toArray() {
    return Array.from(this.data);
  }
  toJSON() {
    return JSON.stringify(Array.from(this.data));
  }
  toString() {
    return this.join(",");
  }
  _set(index, value, _delete = false) {
    if (Math.abs(index) > this.data.size) {
      throw new ReferenceError("Can not set an element outside the bounds of the list");
    }
    const data = Array.from(this.data);
    data.splice(index, +_delete, value);
    this.data = new Set(data);
    this.emit("update");
  }
  set(index, value) {
    this._set(index, value, true);
  }
  deleteAt(index) {
    if (Math.abs(index) > this.data.size) {
      throw new ReferenceError("Can not delete an element outside the bounds of the list");
    }
    this.delete(Array.from(this.data).at(index));
  }
  insert(value, index = this.data.size) {
    this._set(index, value, false);
  }
  // Array methods
  at(index) {
    if (Math.abs(index) > this.data.size) {
      throw new ReferenceError("Can not access an element outside the bounds of the list");
    }
    return Array.from(this.data).at(index);
  }
  pop() {
    const item = Array.from(this.data).pop();
    if (item !== void 0) {
      this.delete(item);
    }
    return item;
  }
  push(...items) {
    for (const item of items) {
      this.add(item);
    }
    return this.data.size;
  }
  join(separator) {
    return Array.from(this.data).join(separator);
  }
  splice(start, deleteCount, ...items) {
    if (Math.abs(start) > this.data.size) {
      throw new ReferenceError("Can not splice elements outside the bounds of the list");
    }
    const data = Array.from(this.data);
    const deleted = data.splice(start, deleteCount, ...items);
    this.data = new Set(data);
    this.emit("update");
    return deleted;
  }
  // Set methods
  add(value) {
    this.data.add(value);
    this.emit("update");
    this.emit("add", value);
    return this;
  }
  clear() {
    this.data.clear();
    this.emit("update");
  }
  delete(value) {
    const success = this.data.delete(value);
    this.emit("update");
    return success;
  }
  has(value) {
    return this.data.has(value);
  }
  get size() {
    return this.data.size;
  }
  // Iteration
  entries() {
    return this.toArray().entries();
  }
  keys() {
    return this.toArray().keys();
  }
  values() {
    return this.data.values();
  }
  [(_a = Symbol.toStringTag, Symbol.iterator)]() {
    return this.data[Symbol.iterator]();
  }
};

// node_modules/utilium/dist/numbers.js
var __formatter = Intl.NumberFormat("en", { notation: "compact" });
var formatCompact = __formatter.format.bind(__formatter);

// node_modules/utilium/dist/objects.js
function isJSON(str) {
  try {
    JSON.parse(str);
    return true;
  } catch (e) {
    return false;
  }
}

// node_modules/utilium/dist/random.js
function randomHex(length = 1) {
  let s = "";
  for (let i = 0; i < length; i++) {
    s += Math.floor(Math.random() * 16).toString(16);
  }
  return s;
}

// node_modules/utilium/dist/string.js
function capitalize(value) {
  return value.at(0).toUpperCase() + value.slice(1);
}

// node_modules/utilium/dist/internal/primitives.js
var types = ["int8", "uint8", "int16", "uint16", "int32", "uint32", "int64", "uint64", "float32", "float64"];
var valids = [...types, ...types.map((t) => capitalize(t)), "char"];
var regex = /^(u?int|float)(8|16|32|64)$/i;
function normalize(type) {
  return type == "char" ? "uint8" : type.toLowerCase();
}
function isType(type) {
  return regex.test(type.toString());
}
function isValid(type) {
  return type == "char" || regex.test(type.toString().toLowerCase());
}
function checkValid(type) {
  if (!isValid(type)) {
    throw new TypeError("Not a valid primitive type: " + type);
  }
}

// node_modules/utilium/dist/internal/struct.js
var struct_exports = {};
__export(struct_exports, {
  _polyfill_contextMetadata: () => _polyfill_contextMetadata,
  checkInstance: () => checkInstance,
  checkStruct: () => checkStruct,
  init: () => init,
  isInstance: () => isInstance,
  isStatic: () => isStatic,
  isStruct: () => isStruct,
  isValidMetadata: () => isValidMetadata,
  metadata: () => metadata,
  symbol_metadata: () => symbol_metadata
});
Symbol.struct_init || (Symbol.struct_init = Symbol("struct_init"));
Symbol.struct_metadata || (Symbol.struct_metadata = Symbol("struct_metadata"));
var init = Symbol.struct_init;
var metadata = Symbol.struct_metadata;
function isValidMetadata(arg) {
  return arg != null && typeof arg == "object" && Symbol.struct_metadata in arg;
}
Symbol.metadata ?? (Symbol.metadata = Symbol.for("Symbol.metadata"));
function _polyfill_contextMetadata(target) {
  if (!(Symbol == null ? void 0 : Symbol.metadata)) {
    return;
  }
  if (Symbol.metadata in target) {
    return;
  }
  Object.defineProperty(target, Symbol.metadata, {
    enumerable: true,
    configurable: true,
    writable: true,
    value: /* @__PURE__ */ Object.create(null)
  });
}
function symbol_metadata(arg) {
  const symbol_metadata2 = Symbol.metadata || Object.getOwnPropertySymbols(arg).find((s) => s.description == "Symbol.metadata");
  _polyfill_contextMetadata(arg);
  if (!symbol_metadata2) {
    throw new ReferenceError("Could not get a reference to Symbol.metadata");
  }
  return symbol_metadata2;
}
function isStatic(arg) {
  return typeof arg == "function" && symbol_metadata(arg) in arg && isValidMetadata(arg[symbol_metadata(arg)]);
}
function isInstance(arg) {
  return arg != null && typeof arg == "object" && isStatic(arg.constructor);
}
function checkInstance(arg) {
  if (!isInstance(arg)) {
    throw new TypeError((typeof arg == "function" ? arg.name : typeof arg == "object" && arg ? arg.constructor.name : arg) + " is not a struct instance");
  }
}
function isStruct(arg) {
  return isInstance(arg) || isStatic(arg);
}
function checkStruct(arg) {
  if (!isStruct(arg)) {
    throw new TypeError((typeof arg == "function" ? arg.name : typeof arg == "object" && arg ? arg.constructor.name : arg) + " is not a struct");
  }
}

// node_modules/utilium/dist/struct.js
function sizeof(type) {
  if (typeof type == "string") {
    checkValid(type);
    return +normalize(type).match(regex)[2] / 8;
  }
  checkStruct(type);
  const struct2 = isStatic(type) ? type : type.constructor;
  return struct2[symbol_metadata(struct2)][Symbol.struct_metadata].size;
}
function align(value, alignment) {
  return Math.ceil(value / alignment) * alignment;
}
function struct(options = {}) {
  return function _decorateStruct(target, context) {
    var _a3, _b2;
    context.metadata ?? (context.metadata = {});
    (_a3 = context.metadata)[_b2 = Symbol.struct_init] || (_a3[_b2] = []);
    let size = 0;
    const members = /* @__PURE__ */ new Map();
    for (const _ of context.metadata[Symbol.struct_init]) {
      const { name, type, length } = _;
      if (!isValid(type) && !isStatic(type)) {
        throw new TypeError("Not a valid type: " + type);
      }
      members.set(name, {
        offset: size,
        type: isValid(type) ? normalize(type) : type,
        length
      });
      size += sizeof(type) * (length || 1);
      size = align(size, options.align || 1);
    }
    context.metadata[Symbol.struct_metadata] = { options, members, size };
    return target;
  };
}
function member(type, length) {
  return function(value, context) {
    var _a3, _b2;
    let name = context.name;
    if (typeof name == "symbol") {
      console.warn("Symbol used for struct member name will be coerced to string: " + name.toString());
      name = name.toString();
    }
    if (!name) {
      throw new ReferenceError("Invalid name for struct member");
    }
    context.metadata ?? (context.metadata = {});
    (_a3 = context.metadata)[_b2 = Symbol.struct_init] || (_a3[_b2] = []);
    context.metadata[Symbol.struct_init].push({ name, type, length });
    return value;
  };
}
function serialize(instance) {
  checkInstance(instance);
  const { options, members } = instance.constructor[symbol_metadata(instance.constructor)][Symbol.struct_metadata];
  const buffer = new Uint8Array(sizeof(instance));
  const view = new DataView(buffer.buffer);
  for (const [name, { type, length, offset }] of members) {
    for (let i = 0; i < (length || 1); i++) {
      const iOff = offset + sizeof(type) * i;
      let value = length > 0 ? instance[name][i] : instance[name];
      if (typeof value == "string") {
        value = value.charCodeAt(0);
      }
      if (!isType(type)) {
        buffer.set(value ? serialize(value) : new Uint8Array(sizeof(type)), iOff);
        continue;
      }
      const Type = capitalize(type);
      const fn = "set" + Type;
      if (fn == "setInt64") {
        view.setBigInt64(iOff, BigInt(value), !options.bigEndian);
        continue;
      }
      if (fn == "setUint64") {
        view.setBigUint64(iOff, BigInt(value), !options.bigEndian);
        continue;
      }
      view[fn](iOff, Number(value), !options.bigEndian);
    }
  }
  return buffer;
}
function deserialize(instance, _buffer) {
  checkInstance(instance);
  const { options, members } = instance.constructor[symbol_metadata(instance.constructor)][Symbol.struct_metadata];
  const buffer = _buffer instanceof Uint8Array ? _buffer : new Uint8Array("buffer" in _buffer ? _buffer.buffer : _buffer);
  const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);
  for (const [name, { type, offset, length }] of members) {
    for (let i = 0; i < (length || 1); i++) {
      let object = length > 0 ? instance[name] : instance;
      const key = length > 0 ? i : name, iOff = offset + sizeof(type) * i;
      if (typeof instance[name] == "string") {
        instance[name] = instance[name].slice(0, i) + String.fromCharCode(view.getUint8(iOff)) + instance[name].slice(i + 1);
        continue;
      }
      if (!isType(type)) {
        if (object[key] === null || object[key] === void 0) {
          continue;
        }
        deserialize(object[key], new Uint8Array(buffer.slice(iOff, iOff + sizeof(type))));
        continue;
      }
      if (length > 0) {
        object || (object = []);
      }
      const Type = capitalize(type);
      const fn = "get" + Type;
      if (fn == "getInt64") {
        object[key] = view.getBigInt64(iOff, !options.bigEndian);
        continue;
      }
      if (fn == "getUint64") {
        object[key] = view.getBigUint64(iOff, !options.bigEndian);
        continue;
      }
      object[key] = view[fn](iOff, !options.bigEndian);
    }
  }
}
function _member(type) {
  function _structMemberDecorator(valueOrLength, context) {
    if (typeof valueOrLength == "number") {
      return member(type, valueOrLength);
    }
    return member(type)(valueOrLength, context);
  }
  return _structMemberDecorator;
}
var types2 = Object.fromEntries(valids.map((t) => [t, _member(t)]));

// node_modules/utilium/dist/version.js
var version_exports = {};
__export(version_exports, {
  parse: () => parse,
  regex: () => regex2
});
var regex2 = /^(?<core>\d+\.\d+\.\d+)(?:[-_](?<type>[^-_.]+)[-_.](?<pre>\d*(?:\.\d+)*))?/;
function parse(full, stripCore) {
  const { type, pre, core } = regex2.exec(full).groups;
  const display = type ? `${stripCore && core == "1.0.0" ? "" : core + " "}${capitalize(type)}${pre ? ` ${pre}` : ""}` : core;
  return { full, core, pre, type, display };
}

// node_modules/@zenfs/core/dist/polyfills.js
var _a2;
var _b;
var _c;
(_a2 = Promise.withResolvers) !== null && _a2 !== void 0 ? _a2 : Promise.withResolvers = function() {
  let _resolve, _reject;
  const promise = new Promise((resolve2, reject) => {
    _resolve = resolve2;
    _reject = reject;
  });
  return { promise, resolve: _resolve, reject: _reject };
};
(_b = Symbol["dispose"]) !== null && _b !== void 0 ? _b : Symbol["dispose"] = Symbol("Symbol.dispose");
(_c = Symbol["asyncDispose"]) !== null && _c !== void 0 ? _c : Symbol["asyncDispose"] = Symbol("Symbol.asyncDispose");

// node_modules/@zenfs/core/dist/credentials.js
var credentials = {
  uid: 0,
  gid: 0,
  suid: 0,
  sgid: 0,
  euid: 0,
  egid: 0,
  groups: []
};
function createCredentials(source) {
  return {
    suid: source.uid,
    sgid: source.gid,
    euid: source.uid,
    egid: source.gid,
    groups: [],
    ...source
  };
}
function useCredentials(source) {
  Object.assign(credentials, createCredentials(source));
}

// node_modules/@zenfs/core/dist/vfs/constants.js
var constants_exports = {};
__export(constants_exports, {
  COPYFILE_EXCL: () => COPYFILE_EXCL,
  COPYFILE_FICLONE: () => COPYFILE_FICLONE,
  COPYFILE_FICLONE_FORCE: () => COPYFILE_FICLONE_FORCE,
  F_OK: () => F_OK,
  O_APPEND: () => O_APPEND,
  O_CREAT: () => O_CREAT,
  O_DIRECT: () => O_DIRECT,
  O_DIRECTORY: () => O_DIRECTORY,
  O_DSYNC: () => O_DSYNC,
  O_EXCL: () => O_EXCL,
  O_NOATIME: () => O_NOATIME,
  O_NOCTTY: () => O_NOCTTY,
  O_NOFOLLOW: () => O_NOFOLLOW,
  O_NONBLOCK: () => O_NONBLOCK,
  O_RDONLY: () => O_RDONLY,
  O_RDWR: () => O_RDWR,
  O_SYMLINK: () => O_SYMLINK,
  O_SYNC: () => O_SYNC,
  O_TRUNC: () => O_TRUNC,
  O_WRONLY: () => O_WRONLY,
  R_OK: () => R_OK,
  S_IFBLK: () => S_IFBLK,
  S_IFCHR: () => S_IFCHR,
  S_IFDIR: () => S_IFDIR,
  S_IFIFO: () => S_IFIFO,
  S_IFLNK: () => S_IFLNK,
  S_IFMT: () => S_IFMT,
  S_IFREG: () => S_IFREG,
  S_IFSOCK: () => S_IFSOCK,
  S_IRGRP: () => S_IRGRP,
  S_IROTH: () => S_IROTH,
  S_IRUSR: () => S_IRUSR,
  S_IRWXG: () => S_IRWXG,
  S_IRWXO: () => S_IRWXO,
  S_IRWXU: () => S_IRWXU,
  S_ISGID: () => S_ISGID,
  S_ISUID: () => S_ISUID,
  S_ISVTX: () => S_ISVTX,
  S_IWGRP: () => S_IWGRP,
  S_IWOTH: () => S_IWOTH,
  S_IWUSR: () => S_IWUSR,
  S_IXGRP: () => S_IXGRP,
  S_IXOTH: () => S_IXOTH,
  S_IXUSR: () => S_IXUSR,
  UV_FS_O_FILEMAP: () => UV_FS_O_FILEMAP,
  W_OK: () => W_OK,
  X_OK: () => X_OK,
  size_max: () => size_max
});
var F_OK = 0;
var R_OK = 4;
var W_OK = 2;
var X_OK = 1;
var COPYFILE_EXCL = 1;
var COPYFILE_FICLONE = 2;
var COPYFILE_FICLONE_FORCE = 4;
var O_RDONLY = 0;
var O_WRONLY = 1;
var O_RDWR = 2;
var O_CREAT = 64;
var O_EXCL = 128;
var O_NOCTTY = 256;
var O_TRUNC = 512;
var O_APPEND = 1024;
var O_DIRECTORY = 65536;
var O_NOATIME = 262144;
var O_NOFOLLOW = 131072;
var O_SYNC = 1052672;
var O_DSYNC = 4096;
var O_SYMLINK = 32768;
var O_DIRECT = 16384;
var O_NONBLOCK = 2048;
var S_IFMT = 61440;
var S_IFSOCK = 49152;
var S_IFLNK = 40960;
var S_IFREG = 32768;
var S_IFBLK = 24576;
var S_IFDIR = 16384;
var S_IFCHR = 8192;
var S_IFIFO = 4096;
var S_ISUID = 2048;
var S_ISGID = 1024;
var S_ISVTX = 512;
var S_IRWXU = 448;
var S_IRUSR = 256;
var S_IWUSR = 128;
var S_IXUSR = 64;
var S_IRWXG = 56;
var S_IRGRP = 32;
var S_IWGRP = 16;
var S_IXGRP = 8;
var S_IRWXO = 7;
var S_IROTH = 4;
var S_IWOTH = 2;
var S_IXOTH = 1;
var UV_FS_O_FILEMAP = 0;
var size_max = 2 ** 32 - 1;

// node_modules/@zenfs/core/dist/stats.js
var n1000 = BigInt(1e3);
var StatsCommon = class {
  _convert(arg) {
    return this._isBigint ? BigInt(arg) : Number(arg);
  }
  get blocks() {
    return this._convert(Math.ceil(Number(this.size) / 512));
  }
  get atime() {
    return new Date(Number(this.atimeMs));
  }
  set atime(value) {
    this.atimeMs = this._convert(value.getTime());
  }
  get mtime() {
    return new Date(Number(this.mtimeMs));
  }
  set mtime(value) {
    this.mtimeMs = this._convert(value.getTime());
  }
  get ctime() {
    return new Date(Number(this.ctimeMs));
  }
  set ctime(value) {
    this.ctimeMs = this._convert(value.getTime());
  }
  get birthtime() {
    return new Date(Number(this.birthtimeMs));
  }
  set birthtime(value) {
    this.birthtimeMs = this._convert(value.getTime());
  }
  /**
   * Creates a new stats instance from a stats-like object. Can be used to copy stats (note)
   */
  constructor({ atimeMs, mtimeMs, ctimeMs, birthtimeMs, uid, gid, size, mode, ino } = {}) {
    this.dev = this._convert(0);
    this.ino = this._convert(0);
    this.rdev = this._convert(0);
    this.nlink = this._convert(1);
    this.blksize = this._convert(4096);
    this.uid = this._convert(0);
    this.gid = this._convert(0);
    const now = Date.now();
    this.atimeMs = this._convert(atimeMs !== null && atimeMs !== void 0 ? atimeMs : now);
    this.mtimeMs = this._convert(mtimeMs !== null && mtimeMs !== void 0 ? mtimeMs : now);
    this.ctimeMs = this._convert(ctimeMs !== null && ctimeMs !== void 0 ? ctimeMs : now);
    this.birthtimeMs = this._convert(birthtimeMs !== null && birthtimeMs !== void 0 ? birthtimeMs : now);
    this.uid = this._convert(uid !== null && uid !== void 0 ? uid : 0);
    this.gid = this._convert(gid !== null && gid !== void 0 ? gid : 0);
    this.size = this._convert(size !== null && size !== void 0 ? size : 0);
    this.ino = this._convert(ino !== null && ino !== void 0 ? ino : 0);
    this.mode = this._convert(mode !== null && mode !== void 0 ? mode : 420 & S_IFREG);
    if ((this.mode & S_IFMT) == 0) {
      this.mode = this.mode | this._convert(S_IFREG);
    }
  }
  isFile() {
    return (this.mode & S_IFMT) === S_IFREG;
  }
  isDirectory() {
    return (this.mode & S_IFMT) === S_IFDIR;
  }
  isSymbolicLink() {
    return (this.mode & S_IFMT) === S_IFLNK;
  }
  isSocket() {
    return (this.mode & S_IFMT) === S_IFSOCK;
  }
  isBlockDevice() {
    return (this.mode & S_IFMT) === S_IFBLK;
  }
  isCharacterDevice() {
    return (this.mode & S_IFMT) === S_IFCHR;
  }
  isFIFO() {
    return (this.mode & S_IFMT) === S_IFIFO;
  }
  /**
   * Checks if a given user/group has access to this item
   * @param mode The requested access, combination of W_OK, R_OK, and X_OK
   * @returns True if the request has access, false if the request does not
   * @internal
   */
  hasAccess(mode, context) {
    const creds = (context === null || context === void 0 ? void 0 : context.credentials) || credentials;
    if (this.isSymbolicLink() || creds.euid === 0 || creds.egid === 0)
      return true;
    let perm = 0;
    if (creds.uid === this.uid) {
      if (this.mode & S_IRUSR)
        perm |= R_OK;
      if (this.mode & S_IWUSR)
        perm |= W_OK;
      if (this.mode & S_IXUSR)
        perm |= X_OK;
    }
    if (creds.gid === this.gid || creds.groups.includes(Number(this.gid))) {
      if (this.mode & S_IRGRP)
        perm |= R_OK;
      if (this.mode & S_IWGRP)
        perm |= W_OK;
      if (this.mode & S_IXGRP)
        perm |= X_OK;
    }
    if (this.mode & S_IROTH)
      perm |= R_OK;
    if (this.mode & S_IWOTH)
      perm |= W_OK;
    if (this.mode & S_IXOTH)
      perm |= X_OK;
    return (perm & mode) === mode;
  }
  /**
   * Change the mode of the file.
   * We use this helper function to prevent messing up the type of the file.
   * @internal
   * @deprecated This will be removed in the next minor release since it is internal
   */
  chmod(mode) {
    this.mode = this._convert(this.mode & S_IFMT | mode);
  }
  /**
   * Change the owner user/group of the file.
   * This function makes sure it is a valid UID/GID (that is, a 32 unsigned int)
   * @internal
   * @deprecated This will be removed in the next minor release since it is internal
   */
  chown(uid, gid) {
    uid = Number(uid);
    gid = Number(gid);
    if (!isNaN(uid) && 0 <= uid && uid < 2 ** 32) {
      this.uid = this._convert(uid);
    }
    if (!isNaN(gid) && 0 <= gid && gid < 2 ** 32) {
      this.gid = this._convert(gid);
    }
  }
  get atimeNs() {
    return BigInt(this.atimeMs) * n1000;
  }
  get mtimeNs() {
    return BigInt(this.mtimeMs) * n1000;
  }
  get ctimeNs() {
    return BigInt(this.ctimeMs) * n1000;
  }
  get birthtimeNs() {
    return BigInt(this.birthtimeMs) * n1000;
  }
};
function _chown(stats2, uid, gid) {
  if (!isNaN(uid) && 0 <= uid && uid < 2 ** 32) {
    stats2.uid = uid;
  }
  if (!isNaN(gid) && 0 <= gid && gid < 2 ** 32) {
    stats2.gid = gid;
  }
}
var Stats = class extends StatsCommon {
  constructor() {
    super(...arguments);
    this._isBigint = false;
  }
};
var BigIntStats = class extends StatsCommon {
  constructor() {
    super(...arguments);
    this._isBigint = true;
  }
};
function isStatsEqual(left, right) {
  return left.size == right.size && +left.atime == +right.atime && +left.mtime == +right.mtime && +left.ctime == +right.ctime && left.mode == right.mode;
}
var ZenFsType = 525687744115;
var StatsFs = class {
  constructor() {
    this.type = 525687744115;
    this.bsize = 4096;
    this.blocks = 0;
    this.bfree = 0;
    this.bavail = 0;
    this.files = size_max;
    this.ffree = size_max;
  }
};
var BigIntStatsFs = class {
  constructor() {
    this.type = BigInt("0x7a656e6673");
    this.bsize = BigInt(4096);
    this.blocks = BigInt(0);
    this.bfree = BigInt(0);
    this.bavail = BigInt(0);
    this.files = BigInt(size_max);
    this.ffree = BigInt(size_max);
  }
};

// node_modules/@zenfs/core/dist/vfs/config.js
var config = {
  /**
   * Whether to perform access checks
   */
  checkAccess: true,
  /**
   * Whether to mark a file as dirty after updating its `atime` when read from
   */
  updateOnRead: true,
  /**
   * Whether to immediately sync when files are changed
   */
  syncImmediately: true,
  /**
   * If a file's buffer is not large enough to store content when writing and the buffer can't be resized, reuse the buffer passed to write()
   */
  unsafeBufferReplace: false
};

// node_modules/@zenfs/core/dist/file.js
var validFlags = ["r", "r+", "rs", "rs+", "w", "wx", "w+", "wx+", "a", "ax", "a+", "ax+"];
function parseFlag(flag) {
  if (typeof flag === "number") {
    return flagToString(flag);
  }
  if (!validFlags.includes(flag)) {
    throw new Error("Invalid flag string: " + flag);
  }
  return flag;
}
function flagToString(flag) {
  switch (flag) {
    case O_RDONLY:
      return "r";
    case O_RDONLY | O_SYNC:
      return "rs";
    case O_RDWR:
      return "r+";
    case O_RDWR | O_SYNC:
      return "rs+";
    case O_TRUNC | O_CREAT | O_WRONLY:
      return "w";
    case O_TRUNC | O_CREAT | O_WRONLY | O_EXCL:
      return "wx";
    case O_TRUNC | O_CREAT | O_RDWR:
      return "w+";
    case O_TRUNC | O_CREAT | O_RDWR | O_EXCL:
      return "wx+";
    case O_APPEND | O_CREAT | O_WRONLY:
      return "a";
    case O_APPEND | O_CREAT | O_WRONLY | O_EXCL:
      return "ax";
    case O_APPEND | O_CREAT | O_RDWR:
      return "a+";
    case O_APPEND | O_CREAT | O_RDWR | O_EXCL:
      return "ax+";
    default:
      throw new Error("Invalid flag number: " + flag);
  }
}
function flagToNumber(flag) {
  switch (flag) {
    case "r":
      return O_RDONLY;
    case "rs":
      return O_RDONLY | O_SYNC;
    case "r+":
      return O_RDWR;
    case "rs+":
      return O_RDWR | O_SYNC;
    case "w":
      return O_TRUNC | O_CREAT | O_WRONLY;
    case "wx":
      return O_TRUNC | O_CREAT | O_WRONLY | O_EXCL;
    case "w+":
      return O_TRUNC | O_CREAT | O_RDWR;
    case "wx+":
      return O_TRUNC | O_CREAT | O_RDWR | O_EXCL;
    case "a":
      return O_APPEND | O_CREAT | O_WRONLY;
    case "ax":
      return O_APPEND | O_CREAT | O_WRONLY | O_EXCL;
    case "a+":
      return O_APPEND | O_CREAT | O_RDWR;
    case "ax+":
      return O_APPEND | O_CREAT | O_RDWR | O_EXCL;
    default:
      throw new Error("Invalid flag string: " + flag);
  }
}
function flagToMode(flag) {
  let mode = 0;
  mode <<= 1;
  mode += +isReadable(flag);
  mode <<= 1;
  mode += +isWriteable(flag);
  mode <<= 1;
  return mode;
}
function isReadable(flag) {
  return flag.indexOf("r") !== -1 || flag.indexOf("+") !== -1;
}
function isWriteable(flag) {
  return flag.indexOf("w") !== -1 || flag.indexOf("a") !== -1 || flag.indexOf("+") !== -1;
}
function isTruncating(flag) {
  return flag.indexOf("w") !== -1;
}
function isAppendable(flag) {
  return flag.indexOf("a") !== -1;
}
function isSynchronous(flag) {
  return flag.indexOf("s") !== -1;
}
function isExclusive(flag) {
  return flag.indexOf("x") !== -1;
}
var File = class {
  constructor(fs, path) {
    this.fs = fs;
    this.path = path;
  }
  async [Symbol.asyncDispose]() {
    await this.close();
  }
  [Symbol.dispose]() {
    this.closeSync();
  }
  /**
   * Default implementation maps to `sync`.
   */
  datasync() {
    return this.sync();
  }
  /**
   * Default implementation maps to `syncSync`.
   */
  datasyncSync() {
    return this.syncSync();
  }
};
var PreloadFile = class extends File {
  /**
   * Creates a file with `path` and, optionally, the given contents.
   * Note that, if contents is specified, it will be mutated by the file.
   */
  constructor(fs, path, flag, stats2, _buffer = new Uint8Array(new ArrayBuffer(0, fs.metadata().noResizableBuffers ? {} : { maxByteLength: size_max }))) {
    super(fs, path);
    this.flag = flag;
    this.stats = stats2;
    this._buffer = _buffer;
    this._position = 0;
    this.dirty = false;
    this.closed = false;
    if (this.stats.size == _buffer.byteLength) {
      return;
    }
    if (isReadable(this.flag)) {
      throw new Error(`Size mismatch: buffer length ${_buffer.byteLength}, stats size ${this.stats.size}`);
    }
    this.dirty = true;
  }
  /**
   * Get the underlying buffer for this file. Mutating not recommended and will mess up dirty tracking.
   */
  get buffer() {
    return this._buffer;
  }
  /**
   * Get the current file position.
   *
   * We emulate the following bug mentioned in the Node documentation:
   *
   * On Linux, positional writes don't work when the file is opened in append mode.
   * The kernel ignores the position argument and always appends the data to the end of the file.
   * @returns The current file position.
   */
  get position() {
    if (isAppendable(this.flag)) {
      return this.stats.size;
    }
    return this._position;
  }
  set position(value) {
    this._position = value;
  }
  async sync() {
    if (this.closed) {
      throw ErrnoError.With("EBADF", this.path, "File.sync");
    }
    if (!this.dirty) {
      return;
    }
    await this.fs.sync(this.path, this._buffer, this.stats);
    this.dirty = false;
  }
  syncSync() {
    if (this.closed) {
      throw ErrnoError.With("EBADF", this.path, "File.sync");
    }
    if (!this.dirty) {
      return;
    }
    this.fs.syncSync(this.path, this._buffer, this.stats);
    this.dirty = false;
  }
  async close() {
    if (this.closed) {
      throw ErrnoError.With("EBADF", this.path, "File.close");
    }
    await this.sync();
    this.dispose();
  }
  closeSync() {
    if (this.closed) {
      throw ErrnoError.With("EBADF", this.path, "File.close");
    }
    this.syncSync();
    this.dispose();
  }
  /**
   * Cleans up. This will *not* sync the file data to the FS
   */
  dispose(force) {
    if (this.closed) {
      throw ErrnoError.With("EBADF", this.path, "File.dispose");
    }
    if (this.dirty && !force) {
      throw ErrnoError.With("EBUSY", this.path, "File.dispose");
    }
    delete this._buffer;
    delete this.stats;
    this.closed = true;
  }
  stat() {
    if (this.closed) {
      throw ErrnoError.With("EBADF", this.path, "File.stat");
    }
    return Promise.resolve(new Stats(this.stats));
  }
  statSync() {
    if (this.closed) {
      throw ErrnoError.With("EBADF", this.path, "File.stat");
    }
    return new Stats(this.stats);
  }
  _truncate(length) {
    if (this.closed) {
      throw ErrnoError.With("EBADF", this.path, "File.truncate");
    }
    this.dirty = true;
    if (!isWriteable(this.flag)) {
      throw new ErrnoError(Errno.EPERM, "File not opened with a writeable mode.");
    }
    this.stats.mtimeMs = Date.now();
    if (length > this._buffer.length) {
      const data = new Uint8Array(length - this._buffer.length);
      this._write(data, 0, data.length, this._buffer.length);
      return;
    }
    this.stats.size = length;
    this._buffer = length ? this._buffer.slice(0, length) : new Uint8Array();
  }
  async truncate(length) {
    this._truncate(length);
    if (config.syncImmediately)
      await this.sync();
  }
  truncateSync(length) {
    this._truncate(length);
    if (config.syncImmediately)
      this.syncSync();
  }
  _write(buffer, offset = 0, length = this.stats.size, position = this.position) {
    if (this.closed) {
      throw ErrnoError.With("EBADF", this.path, "File.write");
    }
    if (!isWriteable(this.flag)) {
      throw new ErrnoError(Errno.EPERM, "File not opened with a writeable mode.");
    }
    this.dirty = true;
    const end = position + length;
    const slice = buffer.slice(offset, offset + length);
    if (end > this.stats.size) {
      this.stats.size = end;
      if (end > this._buffer.byteLength) {
        const { buffer: buffer2 } = this._buffer;
        if ("resizable" in buffer2 && buffer2.resizable && buffer2.maxByteLength <= end) {
          buffer2.resize(end);
        } else if ("growable" in buffer2 && buffer2.growable && buffer2.maxByteLength <= end) {
          buffer2.grow(end);
        } else if (config.unsafeBufferReplace) {
          this._buffer = slice;
        } else {
          const newBuffer = new Uint8Array(new ArrayBuffer(end, this.fs.metadata().noResizableBuffers ? {} : { maxByteLength: size_max }));
          newBuffer.set(this._buffer);
          this._buffer = newBuffer;
        }
      }
    }
    this._buffer.set(slice, position);
    this.stats.mtimeMs = Date.now();
    this.position = position + slice.byteLength;
    return slice.byteLength;
  }
  /**
   * Write buffer to the file.
   * @param buffer Uint8Array containing the data to write to the file.
   * @param offset Offset in the buffer to start reading data from.
   * @param length The amount of bytes to write to the file.
   * @param position Offset from the beginning of the file where this data should be written.
   * If position is null, the data will be written at  the current position.
   */
  async write(buffer, offset, length, position) {
    const bytesWritten = this._write(buffer, offset, length, position);
    if (config.syncImmediately)
      await this.sync();
    return bytesWritten;
  }
  /**
   * Write buffer to the file.
   * @param buffer Uint8Array containing the data to write to the file.
   * @param offset Offset in the buffer to start reading data from.
   * @param length The amount of bytes to write to the file.
   * @param position Offset from the beginning of the file where this data should be written.
   * If position is null, the data will be written at  the current position.
   * @returns bytes written
   */
  writeSync(buffer, offset = 0, length = this.stats.size, position = this.position) {
    const bytesWritten = this._write(buffer, offset, length, position);
    if (config.syncImmediately)
      this.syncSync();
    return bytesWritten;
  }
  _read(buffer, offset = 0, length = this.stats.size, position) {
    if (this.closed) {
      throw ErrnoError.With("EBADF", this.path, "File.read");
    }
    if (!isReadable(this.flag)) {
      throw new ErrnoError(Errno.EPERM, "File not opened with a readable mode.");
    }
    if (config.updateOnRead) {
      this.dirty = true;
    }
    this.stats.atimeMs = Date.now();
    position !== null && position !== void 0 ? position : position = this.position;
    let end = position + length;
    if (end > this.stats.size) {
      end = position + Math.max(this.stats.size - position, 0);
    }
    this._position = end;
    const bytesRead = end - position;
    if (bytesRead == 0) {
      return bytesRead;
    }
    new Uint8Array(buffer.buffer, offset, length).set(this._buffer.slice(position, end));
    return bytesRead;
  }
  /**
   * Read data from the file.
   * @param buffer The buffer that the data will be written to.
   * @param offset The offset within the buffer where writing will start.
   * @param length An integer specifying the number of bytes to read.
   * @param position An integer specifying where to begin reading from in the file.
   * If position is null, data will be read from the current file position.
   */
  async read(buffer, offset, length, position) {
    const bytesRead = this._read(buffer, offset, length, position);
    if (config.syncImmediately)
      await this.sync();
    return { bytesRead, buffer };
  }
  /**
   * Read data from the file.
   * @param buffer The buffer that the data will be written to.
   * @param offset The offset within the buffer where writing will start.
   * @param length An integer specifying the number of bytes to read.
   * @param position An integer specifying where to begin reading from in the file.
   * If position is null, data will be read from the current file position.
   * @returns number of bytes written
   */
  readSync(buffer, offset, length, position) {
    const bytesRead = this._read(buffer, offset, length, position);
    if (config.syncImmediately)
      this.syncSync();
    return bytesRead;
  }
  async chmod(mode) {
    if (this.closed) {
      throw ErrnoError.With("EBADF", this.path, "File.chmod");
    }
    this.dirty = true;
    this.stats.mode = this.stats.mode & (mode > S_IFMT ? ~S_IFMT : S_IFMT) | mode;
    if (config.syncImmediately || mode > S_IFMT)
      await this.sync();
  }
  chmodSync(mode) {
    if (this.closed) {
      throw ErrnoError.With("EBADF", this.path, "File.chmod");
    }
    this.dirty = true;
    this.stats.mode = this.stats.mode & (mode > S_IFMT ? ~S_IFMT : S_IFMT) | mode;
    if (config.syncImmediately || mode > S_IFMT)
      this.syncSync();
  }
  async chown(uid, gid) {
    if (this.closed) {
      throw ErrnoError.With("EBADF", this.path, "File.chown");
    }
    this.dirty = true;
    _chown(this.stats, uid, gid);
    if (config.syncImmediately)
      await this.sync();
  }
  chownSync(uid, gid) {
    if (this.closed) {
      throw ErrnoError.With("EBADF", this.path, "File.chown");
    }
    this.dirty = true;
    _chown(this.stats, uid, gid);
    if (config.syncImmediately)
      this.syncSync();
  }
  async utimes(atime, mtime) {
    if (this.closed) {
      throw ErrnoError.With("EBADF", this.path, "File.utimes");
    }
    this.dirty = true;
    this.stats.atime = atime;
    this.stats.mtime = mtime;
    if (config.syncImmediately)
      await this.sync();
  }
  utimesSync(atime, mtime) {
    if (this.closed) {
      throw ErrnoError.With("EBADF", this.path, "File.utimes");
    }
    this.dirty = true;
    this.stats.atime = atime;
    this.stats.mtime = mtime;
    if (config.syncImmediately)
      this.syncSync();
  }
};
var NoSyncFile = class extends PreloadFile {
  sync() {
    return Promise.resolve();
  }
  syncSync() {
  }
  close() {
    return Promise.resolve();
  }
  closeSync() {
  }
};

// node_modules/@zenfs/core/dist/filesystem.js
var FileSystem = class {
  /**
   * Get metadata about the current file system
   */
  metadata() {
    var _a3;
    return {
      name: this.constructor.name.toLowerCase(),
      readonly: false,
      totalSpace: 0,
      freeSpace: 0,
      noResizableBuffers: false,
      noAsyncCache: (_a3 = this._disableSync) !== null && _a3 !== void 0 ? _a3 : false,
      features: [],
      type: ZenFsType
    };
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unused-vars
  constructor(...args) {
  }
  async ready() {
  }
  /**
   * Test whether or not `path` exists.
   */
  async exists(path) {
    try {
      await this.stat(path);
      return true;
    } catch (e) {
      return e.code != "ENOENT";
    }
  }
  /**
   * Test whether or not `path` exists.
   */
  existsSync(path) {
    try {
      this.statSync(path);
      return true;
    } catch (e) {
      return e.code != "ENOENT";
    }
  }
};

// node_modules/@zenfs/core/dist/mixins/readonly.js
function Readonly(FS) {
  class ReadonlyFS extends FS {
    metadata() {
      return { ...super.metadata(), readonly: true };
    }
    async rename() {
      throw new ErrnoError(Errno.EROFS);
    }
    renameSync() {
      throw new ErrnoError(Errno.EROFS);
    }
    async createFile() {
      throw new ErrnoError(Errno.EROFS);
    }
    createFileSync() {
      throw new ErrnoError(Errno.EROFS);
    }
    async unlink() {
      throw new ErrnoError(Errno.EROFS);
    }
    unlinkSync() {
      throw new ErrnoError(Errno.EROFS);
    }
    async rmdir() {
      throw new ErrnoError(Errno.EROFS);
    }
    rmdirSync() {
      throw new ErrnoError(Errno.EROFS);
    }
    async mkdir() {
      throw new ErrnoError(Errno.EROFS);
    }
    mkdirSync() {
      throw new ErrnoError(Errno.EROFS);
    }
    async link() {
      throw new ErrnoError(Errno.EROFS);
    }
    linkSync() {
      throw new ErrnoError(Errno.EROFS);
    }
    async sync() {
      throw new ErrnoError(Errno.EROFS);
    }
    syncSync() {
      throw new ErrnoError(Errno.EROFS);
    }
  }
  return ReadonlyFS;
}

// node_modules/@zenfs/core/dist/vfs/path.js
var cwd = "/";
function normalizeString(path, allowAboveRoot) {
  let res = "";
  let lastSegmentLength = 0;
  let lastSlash = -1;
  let dots = 0;
  let char = "\0";
  for (let i = 0; i <= path.length; ++i) {
    if (i < path.length) {
      char = path[i];
    } else if (char == "/") {
      break;
    } else {
      char = "/";
    }
    if (char == "/") {
      if (lastSlash === i - 1 || dots === 1) {
      } else if (dots === 2) {
        if (res.length < 2 || lastSegmentLength !== 2 || res.at(-1) !== "." || res.at(-2) !== ".") {
          if (res.length > 2) {
            const lastSlashIndex = res.lastIndexOf("/");
            if (lastSlashIndex === -1) {
              res = "";
              lastSegmentLength = 0;
            } else {
              res = res.slice(0, lastSlashIndex);
              lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
            }
            lastSlash = i;
            dots = 0;
            continue;
          } else if (res.length !== 0) {
            res = "";
            lastSegmentLength = 0;
            lastSlash = i;
            dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          res += res.length > 0 ? "/.." : "..";
          lastSegmentLength = 2;
        }
      } else {
        if (res.length > 0)
          res += "/" + path.slice(lastSlash + 1, i);
        else
          res = path.slice(lastSlash + 1, i);
        lastSegmentLength = i - lastSlash - 1;
      }
      lastSlash = i;
      dots = 0;
    } else if (char === "." && dots !== -1) {
      ++dots;
    } else {
      dots = -1;
    }
  }
  return res;
}
function resolve(...parts) {
  let resolved = "";
  for (const part of [...parts.reverse(), cwd]) {
    if (!part.length) {
      continue;
    }
    resolved = `${part}/${resolved}`;
    if (part.startsWith("/")) {
      break;
    }
  }
  const absolute = resolved.startsWith("/");
  resolved = normalizeString(resolved, !absolute);
  if (absolute) {
    return `/${resolved}`;
  }
  return resolved.length ? resolved : "/";
}
function normalize2(path) {
  if (!path.length)
    return ".";
  const isAbsolute = path.startsWith("/");
  const trailingSeparator = path.endsWith("/");
  path = normalizeString(path, !isAbsolute);
  if (!path.length) {
    if (isAbsolute)
      return "/";
    return trailingSeparator ? "./" : ".";
  }
  if (trailingSeparator)
    path += "/";
  return isAbsolute ? `/${path}` : path;
}
function join(...parts) {
  if (!parts.length)
    return ".";
  const joined = parts.join("/");
  if (!(joined === null || joined === void 0 ? void 0 : joined.length))
    return ".";
  return normalize2(joined);
}
function dirname(path) {
  if (path.length === 0)
    return ".";
  const hasRoot = path[0] === "/";
  let end = -1;
  let matchedSlash = true;
  for (let i = path.length - 1; i >= 1; --i) {
    if (path[i] === "/") {
      if (!matchedSlash) {
        end = i;
        break;
      }
    } else {
      matchedSlash = false;
    }
  }
  if (end === -1)
    return hasRoot ? "/" : ".";
  if (hasRoot && end === 1)
    return "//";
  return path.slice(0, end);
}
function basename(path, suffix) {
  let start = 0;
  let end = -1;
  let matchedSlash = true;
  if (suffix !== void 0 && suffix.length > 0 && suffix.length <= path.length) {
    if (suffix === path)
      return "";
    let extIdx = suffix.length - 1;
    let firstNonSlashEnd = -1;
    for (let i = path.length - 1; i >= 0; --i) {
      if (path[i] === "/") {
        if (!matchedSlash) {
          start = i + 1;
          break;
        }
      } else {
        if (firstNonSlashEnd === -1) {
          matchedSlash = false;
          firstNonSlashEnd = i + 1;
        }
        if (extIdx >= 0) {
          if (path[i] === suffix[extIdx]) {
            if (--extIdx === -1) {
              end = i;
            }
          } else {
            extIdx = -1;
            end = firstNonSlashEnd;
          }
        }
      }
    }
    if (start === end)
      end = firstNonSlashEnd;
    else if (end === -1)
      end = path.length;
    return path.slice(start, end);
  }
  for (let i = path.length - 1; i >= 0; --i) {
    if (path[i] === "/") {
      if (!matchedSlash) {
        start = i + 1;
        break;
      }
    } else if (end === -1) {
      matchedSlash = false;
      end = i + 1;
    }
  }
  if (end === -1)
    return "";
  return path.slice(start, end);
}
function parse2(path) {
  const isAbsolute = path.startsWith("/");
  const ret = { root: isAbsolute ? "/" : "", dir: "", base: "", ext: "", name: "" };
  if (path.length === 0)
    return ret;
  const start = isAbsolute ? 1 : 0;
  let startDot = -1;
  let startPart = 0;
  let end = -1;
  let matchedSlash = true;
  let i = path.length - 1;
  let preDotState = 0;
  for (; i >= start; --i) {
    if (path[i] === "/") {
      if (!matchedSlash) {
        startPart = i + 1;
        break;
      }
      continue;
    }
    if (end === -1) {
      matchedSlash = false;
      end = i + 1;
    }
    if (path[i] === ".") {
      if (startDot === -1)
        startDot = i;
      else if (preDotState !== 1)
        preDotState = 1;
    } else if (startDot !== -1) {
      preDotState = -1;
    }
  }
  if (end !== -1) {
    const start2 = startPart === 0 && isAbsolute ? 1 : startPart;
    if (startDot === -1 || // We saw a non-dot character immediately before the dot
    preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
      ret.base = ret.name = path.slice(start2, end);
    } else {
      ret.name = path.slice(start2, startDot);
      ret.base = path.slice(start2, end);
      ret.ext = path.slice(startDot, end);
    }
  }
  if (startPart > 0)
    ret.dir = path.slice(0, startPart - 1);
  else if (isAbsolute)
    ret.dir = "/";
  return ret;
}

// node_modules/@zenfs/core/dist/utils.js
function encodeRaw(input) {
  if (typeof input != "string") {
    throw new ErrnoError(Errno.EINVAL, "Can not encode a non-string");
  }
  return new Uint8Array(Array.from(input).map((char) => char.charCodeAt(0)));
}
function decodeRaw(input) {
  if (!(input instanceof Uint8Array)) {
    throw new ErrnoError(Errno.EINVAL, "Can not decode a non-Uint8Array");
  }
  return Array.from(input).map((char) => String.fromCharCode(char)).join("");
}
var encoder = new TextEncoder();
function encodeUTF8(input) {
  if (typeof input != "string") {
    throw new ErrnoError(Errno.EINVAL, "Can not encode a non-string");
  }
  return encoder.encode(input);
}
var decoder = new TextDecoder();
function decodeUTF8(input) {
  if (!(input instanceof Uint8Array)) {
    throw new ErrnoError(Errno.EINVAL, "Can not decode a non-Uint8Array");
  }
  return decoder.decode(input);
}
function decodeDirListing(data) {
  return JSON.parse(decodeUTF8(data), (k, v) => k == "" ? v : BigInt(v));
}
function encodeDirListing(data) {
  return encodeUTF8(JSON.stringify(data, (k, v) => k == "" ? v : v.toString()));
}
function normalizeMode(mode, def) {
  if (typeof mode == "number") {
    return mode;
  }
  if (typeof mode == "string") {
    const parsed = parseInt(mode, 8);
    if (!isNaN(parsed)) {
      return parsed;
    }
  }
  if (typeof def == "number") {
    return def;
  }
  throw new ErrnoError(Errno.EINVAL, "Invalid mode: " + (mode === null || mode === void 0 ? void 0 : mode.toString()));
}
function normalizeTime(time) {
  if (time instanceof Date) {
    return time;
  }
  try {
    return new Date(time);
  } catch {
    throw new ErrnoError(Errno.EINVAL, "Invalid time.");
  }
}
function normalizePath(p) {
  p = p.toString();
  if (p.includes("\0")) {
    throw new ErrnoError(Errno.EINVAL, "Path can not contain null character");
  }
  if (p.length == 0) {
    throw new ErrnoError(Errno.EINVAL, "Path can not be empty");
  }
  return resolve(p.replaceAll(/[/\\]+/g, "/"));
}
function normalizeOptions(options, encoding = "utf8", flag, mode = 0) {
  if (typeof options != "object" || options === null) {
    return {
      encoding: typeof options == "string" ? options : encoding !== null && encoding !== void 0 ? encoding : null,
      flag,
      mode
    };
  }
  return {
    encoding: typeof (options === null || options === void 0 ? void 0 : options.encoding) == "string" ? options.encoding : encoding !== null && encoding !== void 0 ? encoding : null,
    flag: typeof (options === null || options === void 0 ? void 0 : options.flag) == "string" ? options.flag : flag,
    mode: normalizeMode("mode" in options ? options === null || options === void 0 ? void 0 : options.mode : null, mode)
  };
}
function randomBigInt() {
  return BigInt("0x" + randomHex(8));
}

// node_modules/@zenfs/core/dist/backends/file_index.js
var version = 1;
var Index = class _Index extends Map {
  /**
   * Convenience method
   */
  files() {
    const files = /* @__PURE__ */ new Map();
    for (const [path, stats2] of this) {
      if (stats2.isFile()) {
        files.set(path, stats2);
      }
    }
    return files;
  }
  /**
   * Converts the index to JSON
   */
  toJSON() {
    return {
      version,
      entries: Object.fromEntries(this)
    };
  }
  /**
   * Converts the index to a string
   */
  toString() {
    return JSON.stringify(this.toJSON());
  }
  /**
   * Returns the files in the directory `dir`.
   * This is expensive so it is only called once per directory.
   */
  dirEntries(dir) {
    const entries = [];
    for (const entry of this.keys()) {
      if (dirname(entry) == dir) {
        entries.push(basename(entry));
      }
    }
    return entries;
  }
  /**
   * Loads the index from JSON data
   */
  fromJSON(json) {
    if (json.version != version) {
      throw new ErrnoError(Errno.EINVAL, "Index version mismatch");
    }
    this.clear();
    for (const [path, data] of Object.entries(json.entries)) {
      const stats2 = new Stats(data);
      if (stats2.isDirectory()) {
        stats2.fileData = encodeUTF8(JSON.stringify(this.dirEntries(path)));
      }
      this.set(path, stats2);
    }
  }
  /**
   * Parses an index from a string
   */
  static parse(data) {
    if (!isJSON(data)) {
      throw new ErrnoError(Errno.EINVAL, "Invalid JSON");
    }
    const json = JSON.parse(data);
    const index = new _Index();
    index.fromJSON(json);
    return index;
  }
};
var IndexFS = class extends Readonly(FileSystem) {
  async ready() {
    await super.ready();
    if (this._isInitialized) {
      return;
    }
    this.index.fromJSON(await this.indexData);
    this._isInitialized = true;
  }
  constructor(indexData) {
    super();
    this.indexData = indexData;
    this.index = new Index();
    this._isInitialized = false;
  }
  async reloadFiles() {
    for (const [path, stats2] of this.index.files()) {
      delete stats2.fileData;
      stats2.fileData = await this.getData(path, stats2);
    }
  }
  reloadFilesSync() {
    for (const [path, stats2] of this.index.files()) {
      delete stats2.fileData;
      stats2.fileData = this.getDataSync(path, stats2);
    }
  }
  stat(path) {
    return Promise.resolve(this.statSync(path));
  }
  statSync(path) {
    if (!this.index.has(path)) {
      throw ErrnoError.With("ENOENT", path, "stat");
    }
    return this.index.get(path);
  }
  async openFile(path, flag) {
    if (isWriteable(flag)) {
      throw new ErrnoError(Errno.EPERM, path);
    }
    const stats2 = this.index.get(path);
    if (!stats2) {
      throw ErrnoError.With("ENOENT", path, "openFile");
    }
    return new NoSyncFile(this, path, flag, stats2, stats2.isDirectory() ? stats2.fileData : await this.getData(path, stats2));
  }
  openFileSync(path, flag) {
    if (isWriteable(flag)) {
      throw new ErrnoError(Errno.EPERM, path);
    }
    const stats2 = this.index.get(path);
    if (!stats2) {
      throw ErrnoError.With("ENOENT", path, "openFile");
    }
    return new NoSyncFile(this, path, flag, stats2, stats2.isDirectory() ? stats2.fileData : this.getDataSync(path, stats2));
  }
  readdir(path) {
    return Promise.resolve(this.readdirSync(path));
  }
  readdirSync(path) {
    const stats2 = this.index.get(path);
    if (!stats2) {
      throw ErrnoError.With("ENOENT", path, "readdir");
    }
    const content = JSON.parse(decodeUTF8(stats2.fileData));
    if (!Array.isArray(content)) {
      throw ErrnoError.With("ENODATA", path, "readdir");
    }
    if (!content.every((item) => typeof item == "string")) {
      throw ErrnoError.With("ENODATA", path, "readdir");
    }
    return content;
  }
};

// node_modules/@zenfs/core/dist/backends/fetch.js
async function fetchFile(path, type, init2) {
  const response = await fetch(path, init2).catch((e) => {
    throw new ErrnoError(Errno.EIO, e.message, path);
  });
  if (!response.ok) {
    throw new ErrnoError(Errno.EIO, "fetch failed: response returned code " + response.status, path);
  }
  switch (type) {
    case "buffer": {
      const arrayBuffer = await response.arrayBuffer().catch((e) => {
        throw new ErrnoError(Errno.EIO, e.message, path);
      });
      return new Uint8Array(arrayBuffer);
    }
    case "json":
      return response.json().catch((e) => {
        throw new ErrnoError(Errno.EIO, e.message, path);
      });
    default:
      throw new ErrnoError(Errno.EINVAL, "Invalid download type: " + type);
  }
}
var FetchFS = class _FetchFS extends IndexFS {
  async ready() {
    if (this._isInitialized) {
      return;
    }
    await super.ready();
    if (this._disableSync) {
      return;
    }
    for (const [path, stats2] of this.index.files()) {
      await this.getData(path, stats2);
    }
  }
  constructor({ index = "index.json", baseUrl = "", requestInit }) {
    if (baseUrl.at(-1) != "/") {
      baseUrl += "/";
    }
    super(typeof index != "string" ? index : fetchFile(index, "json", requestInit));
    this.baseUrl = baseUrl;
    this.requestInit = requestInit;
  }
  metadata() {
    return {
      ...super.metadata(),
      name: _FetchFS.name,
      readonly: true
    };
  }
  /**
   * Preload the `path` into the index.
   */
  preload(path, buffer) {
    const stats2 = this.index.get(path);
    if (!stats2) {
      throw ErrnoError.With("ENOENT", path, "preload");
    }
    if (!stats2.isFile()) {
      throw ErrnoError.With("EISDIR", path, "preload");
    }
    stats2.size = buffer.length;
    stats2.fileData = buffer;
  }
  /**
   * @todo Be lazier about actually requesting the data?
   */
  async getData(path, stats2) {
    if (stats2.fileData) {
      return stats2.fileData;
    }
    const data = await fetchFile(this.baseUrl + (path.startsWith("/") ? path.slice(1) : path), "buffer", this.requestInit);
    stats2.fileData = data;
    return data;
  }
  getDataSync(path, stats2) {
    if (stats2.fileData) {
      return stats2.fileData;
    }
    throw new ErrnoError(Errno.ENODATA, "", path, "getData");
  }
};
var _Fetch = {
  name: "Fetch",
  options: {
    index: { type: ["string", "object"], required: false },
    baseUrl: { type: "string", required: false },
    requestInit: { type: "object", required: false }
  },
  isAvailable() {
    return typeof globalThis.fetch == "function";
  },
  create(options) {
    return new FetchFS(options);
  }
};
var Fetch = _Fetch;

// node_modules/@zenfs/core/dist/backends/store/inode.js
var __esDecorate = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f) {
    if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
    return f;
  }
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _, done = false;
  for (var i = decorators.length - 1; i >= 0; i--) {
    var context = {};
    for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
    for (var p in contextIn.access) context.access[p] = contextIn.access[p];
    context.addInitializer = function(f) {
      if (done) throw new TypeError("Cannot add initializers after decoration has completed");
      extraInitializers.push(accept(f || null));
    };
    var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
    if (kind === "accessor") {
      if (result === void 0) continue;
      if (result === null || typeof result !== "object") throw new TypeError("Object expected");
      if (_ = accept(result.get)) descriptor.get = _;
      if (_ = accept(result.set)) descriptor.set = _;
      if (_ = accept(result.init)) initializers.unshift(_);
    } else if (_ = accept(result)) {
      if (kind === "field") initializers.unshift(_);
      else descriptor[key] = _;
    }
  }
  if (target) Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
};
var __runInitializers = function(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i = 0; i < initializers.length; i++) {
    value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
  }
  return useValue ? value : void 0;
};
var __setFunctionName = function(f, name, prefix) {
  if (typeof name === "symbol") name = name.description ? "[".concat(name.description, "]") : "";
  return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
};
var rootIno = BigInt(0);
var Inode = (() => {
  var _a3, _b2, _c2, _d, _e, _f, _g, _h, _j, _k, _l;
  let _classDecorators = [struct()];
  let _classDescriptor;
  let _classExtraInitializers = [];
  let _classThis;
  let _data_decorators;
  let _data_initializers = [];
  let _data_extraInitializers = [];
  let _size_decorators;
  let _size_initializers = [];
  let _size_extraInitializers = [];
  let _mode_decorators;
  let _mode_initializers = [];
  let _mode_extraInitializers = [];
  let _nlink_decorators;
  let _nlink_initializers = [];
  let _nlink_extraInitializers = [];
  let _uid_decorators;
  let _uid_initializers = [];
  let _uid_extraInitializers = [];
  let _gid_decorators;
  let _gid_initializers = [];
  let _gid_extraInitializers = [];
  let _atimeMs_decorators;
  let _atimeMs_initializers = [];
  let _atimeMs_extraInitializers = [];
  let _birthtimeMs_decorators;
  let _birthtimeMs_initializers = [];
  let _birthtimeMs_extraInitializers = [];
  let _mtimeMs_decorators;
  let _mtimeMs_initializers = [];
  let _mtimeMs_extraInitializers = [];
  let _ctimeMs_decorators;
  let _ctimeMs_initializers = [];
  let _ctimeMs_extraInitializers = [];
  let _ino_decorators;
  let _ino_initializers = [];
  let _ino_extraInitializers = [];
  var Inode2 = _classThis = class {
    constructor(buffer) {
      this.data = __runInitializers(this, _data_initializers, void 0);
      this.size = (__runInitializers(this, _data_extraInitializers), __runInitializers(this, _size_initializers, void 0));
      this.mode = (__runInitializers(this, _size_extraInitializers), __runInitializers(this, _mode_initializers, void 0));
      this.nlink = (__runInitializers(this, _mode_extraInitializers), __runInitializers(this, _nlink_initializers, void 0));
      this.uid = (__runInitializers(this, _nlink_extraInitializers), __runInitializers(this, _uid_initializers, void 0));
      this.gid = (__runInitializers(this, _uid_extraInitializers), __runInitializers(this, _gid_initializers, void 0));
      this.atimeMs = (__runInitializers(this, _gid_extraInitializers), __runInitializers(this, _atimeMs_initializers, void 0));
      this.birthtimeMs = (__runInitializers(this, _atimeMs_extraInitializers), __runInitializers(this, _birthtimeMs_initializers, void 0));
      this.mtimeMs = (__runInitializers(this, _birthtimeMs_extraInitializers), __runInitializers(this, _mtimeMs_initializers, void 0));
      this.ctimeMs = (__runInitializers(this, _mtimeMs_extraInitializers), __runInitializers(this, _ctimeMs_initializers, void 0));
      this.ino = (__runInitializers(this, _ctimeMs_extraInitializers), __runInitializers(this, _ino_initializers, void 0));
      __runInitializers(this, _ino_extraInitializers);
      if (buffer) {
        const sz_inode = sizeof(Inode2);
        const oldSize = sz_inode - sizeof("uint64");
        if (buffer.byteLength < oldSize) {
          throw new RangeError(`Can not create an inode from a buffer less than ${oldSize} bytes`);
        }
        if (buffer.byteLength < sz_inode) {
          const newBuffer = new Uint8Array(sz_inode);
          const buf = ArrayBuffer.isView(buffer) ? buffer.buffer : buffer;
          newBuffer.set(new Uint8Array(buf));
          new DataView(newBuffer.buffer).setBigUint64(sz_inode - 1, randomBigInt());
          buffer = newBuffer;
        }
        deserialize(this, buffer);
        return;
      }
      this.ino = randomBigInt();
      this.data = randomBigInt();
      this.nlink = 1;
      this.size = 4096;
      const now = Date.now();
      this.atimeMs = now;
      this.mtimeMs = now;
      this.ctimeMs = now;
      this.birthtimeMs = now;
    }
    /**
     * Handy function that converts the Inode to a Node Stats object.
     */
    toStats() {
      return new Stats(this);
    }
    /**
     * Updates the Inode using information from the stats object. Used by file
     * systems at sync time, e.g.:
     * - Program opens file and gets a File object.
     * - Program mutates file. File object is responsible for maintaining
     *   metadata changes locally -- typically in a Stats object.
     * - Program closes file. File object's metadata changes are synced with the
     *   file system.
     * @return True if any changes have occurred.
     */
    update(stats2) {
      let hasChanged = false;
      if (this.size !== stats2.size) {
        this.size = stats2.size;
        hasChanged = true;
      }
      if (this.mode !== stats2.mode) {
        this.mode = stats2.mode;
        hasChanged = true;
      }
      if (this.nlink !== stats2.nlink) {
        this.nlink = stats2.nlink;
        hasChanged = true;
      }
      if (this.uid !== stats2.uid) {
        this.uid = stats2.uid;
        hasChanged = true;
      }
      if (this.gid !== stats2.gid) {
        this.gid = stats2.gid;
        hasChanged = true;
      }
      if (this.atimeMs !== stats2.atimeMs) {
        this.atimeMs = stats2.atimeMs;
        hasChanged = true;
      }
      if (this.mtimeMs !== stats2.mtimeMs) {
        this.mtimeMs = stats2.mtimeMs;
        hasChanged = true;
      }
      if (this.ctimeMs !== stats2.ctimeMs) {
        this.ctimeMs = stats2.ctimeMs;
        hasChanged = true;
      }
      return hasChanged;
    }
  };
  __setFunctionName(_classThis, "Inode");
  (() => {
    const _metadata = typeof Symbol === "function" && Symbol.metadata ? /* @__PURE__ */ Object.create(null) : void 0;
    _data_decorators = [(_a3 = types2).uint64.bind(_a3)];
    _size_decorators = [(_b2 = types2).uint32.bind(_b2)];
    _mode_decorators = [(_c2 = types2).uint16.bind(_c2)];
    _nlink_decorators = [(_d = types2).uint32.bind(_d)];
    _uid_decorators = [(_e = types2).uint32.bind(_e)];
    _gid_decorators = [(_f = types2).uint32.bind(_f)];
    _atimeMs_decorators = [(_g = types2).float64.bind(_g)];
    _birthtimeMs_decorators = [(_h = types2).float64.bind(_h)];
    _mtimeMs_decorators = [(_j = types2).float64.bind(_j)];
    _ctimeMs_decorators = [(_k = types2).float64.bind(_k)];
    _ino_decorators = [(_l = types2).uint64.bind(_l)];
    __esDecorate(null, null, _data_decorators, { kind: "field", name: "data", static: false, private: false, access: { has: (obj) => "data" in obj, get: (obj) => obj.data, set: (obj, value) => {
      obj.data = value;
    } }, metadata: _metadata }, _data_initializers, _data_extraInitializers);
    __esDecorate(null, null, _size_decorators, { kind: "field", name: "size", static: false, private: false, access: { has: (obj) => "size" in obj, get: (obj) => obj.size, set: (obj, value) => {
      obj.size = value;
    } }, metadata: _metadata }, _size_initializers, _size_extraInitializers);
    __esDecorate(null, null, _mode_decorators, { kind: "field", name: "mode", static: false, private: false, access: { has: (obj) => "mode" in obj, get: (obj) => obj.mode, set: (obj, value) => {
      obj.mode = value;
    } }, metadata: _metadata }, _mode_initializers, _mode_extraInitializers);
    __esDecorate(null, null, _nlink_decorators, { kind: "field", name: "nlink", static: false, private: false, access: { has: (obj) => "nlink" in obj, get: (obj) => obj.nlink, set: (obj, value) => {
      obj.nlink = value;
    } }, metadata: _metadata }, _nlink_initializers, _nlink_extraInitializers);
    __esDecorate(null, null, _uid_decorators, { kind: "field", name: "uid", static: false, private: false, access: { has: (obj) => "uid" in obj, get: (obj) => obj.uid, set: (obj, value) => {
      obj.uid = value;
    } }, metadata: _metadata }, _uid_initializers, _uid_extraInitializers);
    __esDecorate(null, null, _gid_decorators, { kind: "field", name: "gid", static: false, private: false, access: { has: (obj) => "gid" in obj, get: (obj) => obj.gid, set: (obj, value) => {
      obj.gid = value;
    } }, metadata: _metadata }, _gid_initializers, _gid_extraInitializers);
    __esDecorate(null, null, _atimeMs_decorators, { kind: "field", name: "atimeMs", static: false, private: false, access: { has: (obj) => "atimeMs" in obj, get: (obj) => obj.atimeMs, set: (obj, value) => {
      obj.atimeMs = value;
    } }, metadata: _metadata }, _atimeMs_initializers, _atimeMs_extraInitializers);
    __esDecorate(null, null, _birthtimeMs_decorators, { kind: "field", name: "birthtimeMs", static: false, private: false, access: { has: (obj) => "birthtimeMs" in obj, get: (obj) => obj.birthtimeMs, set: (obj, value) => {
      obj.birthtimeMs = value;
    } }, metadata: _metadata }, _birthtimeMs_initializers, _birthtimeMs_extraInitializers);
    __esDecorate(null, null, _mtimeMs_decorators, { kind: "field", name: "mtimeMs", static: false, private: false, access: { has: (obj) => "mtimeMs" in obj, get: (obj) => obj.mtimeMs, set: (obj, value) => {
      obj.mtimeMs = value;
    } }, metadata: _metadata }, _mtimeMs_initializers, _mtimeMs_extraInitializers);
    __esDecorate(null, null, _ctimeMs_decorators, { kind: "field", name: "ctimeMs", static: false, private: false, access: { has: (obj) => "ctimeMs" in obj, get: (obj) => obj.ctimeMs, set: (obj, value) => {
      obj.ctimeMs = value;
    } }, metadata: _metadata }, _ctimeMs_initializers, _ctimeMs_extraInitializers);
    __esDecorate(null, null, _ino_decorators, { kind: "field", name: "ino", static: false, private: false, access: { has: (obj) => "ino" in obj, get: (obj) => obj.ino, set: (obj, value) => {
      obj.ino = value;
    } }, metadata: _metadata }, _ino_initializers, _ino_extraInitializers);
    __esDecorate(null, _classDescriptor = { value: _classThis }, _classDecorators, { kind: "class", name: _classThis.name, metadata: _metadata }, null, _classExtraInitializers);
    Inode2 = _classThis = _classDescriptor.value;
    if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
    __runInitializers(_classThis, _classExtraInitializers);
  })();
  return Inode2 = _classThis;
})();

// node_modules/@zenfs/core/dist/backends/store/fs.js
var __addDisposableResource = function(env, value, async) {
  if (value !== null && value !== void 0) {
    if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
    var dispose, inner;
    if (async) {
      if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
      dispose = value[Symbol.asyncDispose];
    }
    if (dispose === void 0) {
      if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
      dispose = value[Symbol.dispose];
      if (async) inner = dispose;
    }
    if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
    if (inner) dispose = function() {
      try {
        inner.call(this);
      } catch (e) {
        return Promise.reject(e);
      }
    };
    env.stack.push({ value, dispose, async });
  } else if (async) {
    env.stack.push({ async: true });
  }
  return value;
};
var __disposeResources = /* @__PURE__ */ function(SuppressedError2) {
  return function(env) {
    function fail(e) {
      env.error = env.hasError ? new SuppressedError2(e, env.error, "An error was suppressed during disposal.") : e;
      env.hasError = true;
    }
    var r, s = 0;
    function next() {
      while (r = env.stack.pop()) {
        try {
          if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);
          if (r.dispose) {
            var result = r.dispose.call(r.value);
            if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) {
              fail(e);
              return next();
            });
          } else s |= 1;
        } catch (e) {
          fail(e);
        }
      }
      if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
      if (env.hasError) throw env.error;
    }
    return next();
  };
}(typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
});
var maxInodeAllocTries = 5;
var StoreFS = class extends FileSystem {
  async ready() {
    if (this._initialized) {
      return;
    }
    await this.checkRoot();
    this._initialized = true;
  }
  constructor(store) {
    super();
    this.store = store;
    this._initialized = false;
  }
  metadata() {
    return {
      ...super.metadata(),
      name: this.store.name,
      features: ["setid"]
    };
  }
  /**
   * Delete all contents stored in the file system.
   * @deprecated
   */
  async empty() {
    await this.store.clear();
    await this.checkRoot();
  }
  /**
   * Delete all contents stored in the file system.
   * @deprecated
   */
  emptySync() {
    this.store.clearSync();
    this.checkRootSync();
  }
  /**
   * @todo Make rename compatible with the cache.
   */
  async rename(oldPath, newPath) {
    const env_1 = { stack: [], error: void 0, hasError: false };
    try {
      const tx = __addDisposableResource(env_1, this.store.transaction(), true);
      const _old = parse2(oldPath), _new = parse2(newPath), oldDirNode = await this.findInode(tx, _old.dir, "rename"), oldDirList = decodeDirListing(await this.get(tx, oldDirNode.data, _old.dir, "rename"));
      if (!oldDirList[_old.base]) {
        throw ErrnoError.With("ENOENT", oldPath, "rename");
      }
      const ino = oldDirList[_old.base];
      delete oldDirList[_old.base];
      if ((_new.dir + "/").indexOf(oldPath + "/") === 0) {
        throw new ErrnoError(Errno.EBUSY, _old.dir);
      }
      const sameParent = _new.dir == _old.dir;
      const newDirNode = sameParent ? oldDirNode : await this.findInode(tx, _new.dir, "rename");
      const newDirList = sameParent ? oldDirList : decodeDirListing(await this.get(tx, newDirNode.data, _new.dir, "rename"));
      if (newDirList[_new.base]) {
        const existing = new Inode(await this.get(tx, newDirList[_new.base], newPath, "rename"));
        if (!existing.toStats().isFile()) {
          throw ErrnoError.With("EPERM", newPath, "rename");
        }
        await tx.remove(existing.data);
        await tx.remove(newDirList[_new.base]);
      }
      newDirList[_new.base] = ino;
      await tx.set(oldDirNode.data, encodeDirListing(oldDirList));
      await tx.set(newDirNode.data, encodeDirListing(newDirList));
      await tx.commit();
    } catch (e_1) {
      env_1.error = e_1;
      env_1.hasError = true;
    } finally {
      const result_1 = __disposeResources(env_1);
      if (result_1)
        await result_1;
    }
  }
  renameSync(oldPath, newPath) {
    const env_2 = { stack: [], error: void 0, hasError: false };
    try {
      const tx = __addDisposableResource(env_2, this.store.transaction(), false);
      const _old = parse2(oldPath), _new = parse2(newPath), oldDirNode = this.findInodeSync(tx, _old.dir, "rename"), oldDirList = decodeDirListing(this.getSync(tx, oldDirNode.data, _old.dir, "rename"));
      if (!oldDirList[_old.base]) {
        throw ErrnoError.With("ENOENT", oldPath, "rename");
      }
      const ino = oldDirList[_old.base];
      delete oldDirList[_old.base];
      if ((_new.dir + "/").indexOf(oldPath + "/") == 0) {
        throw new ErrnoError(Errno.EBUSY, _old.dir);
      }
      const sameParent = _new.dir === _old.dir;
      const newDirNode = sameParent ? oldDirNode : this.findInodeSync(tx, _new.dir, "rename");
      const newDirList = sameParent ? oldDirList : decodeDirListing(this.getSync(tx, newDirNode.data, _new.dir, "rename"));
      if (newDirList[_new.base]) {
        const existing = new Inode(this.getSync(tx, newDirList[_new.base], newPath, "rename"));
        if (!existing.toStats().isFile()) {
          throw ErrnoError.With("EPERM", newPath, "rename");
        }
        tx.removeSync(existing.data);
        tx.removeSync(newDirList[_new.base]);
      }
      newDirList[_new.base] = ino;
      tx.setSync(oldDirNode.data, encodeDirListing(oldDirList));
      tx.setSync(newDirNode.data, encodeDirListing(newDirList));
      tx.commitSync();
    } catch (e_2) {
      env_2.error = e_2;
      env_2.hasError = true;
    } finally {
      __disposeResources(env_2);
    }
  }
  async stat(path) {
    const env_3 = { stack: [], error: void 0, hasError: false };
    try {
      const tx = __addDisposableResource(env_3, this.store.transaction(), true);
      return (await this.findInode(tx, path, "stat")).toStats();
    } catch (e_3) {
      env_3.error = e_3;
      env_3.hasError = true;
    } finally {
      const result_2 = __disposeResources(env_3);
      if (result_2)
        await result_2;
    }
  }
  statSync(path) {
    const env_4 = { stack: [], error: void 0, hasError: false };
    try {
      const tx = __addDisposableResource(env_4, this.store.transaction(), false);
      return this.findInodeSync(tx, path, "stat").toStats();
    } catch (e_4) {
      env_4.error = e_4;
      env_4.hasError = true;
    } finally {
      __disposeResources(env_4);
    }
  }
  async createFile(path, flag, mode) {
    const node = await this.commitNew(path, S_IFREG, mode, new Uint8Array(), "createFile");
    return new PreloadFile(this, path, flag, node.toStats(), new Uint8Array());
  }
  createFileSync(path, flag, mode) {
    const node = this.commitNewSync(path, S_IFREG, mode, new Uint8Array(), "createFile");
    return new PreloadFile(this, path, flag, node.toStats(), new Uint8Array());
  }
  async openFile(path, flag) {
    const env_5 = { stack: [], error: void 0, hasError: false };
    try {
      const tx = __addDisposableResource(env_5, this.store.transaction(), true);
      const node = await this.findInode(tx, path, "openFile");
      const data = await this.get(tx, node.data, path, "openFile");
      return new PreloadFile(this, path, flag, node.toStats(), data);
    } catch (e_5) {
      env_5.error = e_5;
      env_5.hasError = true;
    } finally {
      const result_3 = __disposeResources(env_5);
      if (result_3)
        await result_3;
    }
  }
  openFileSync(path, flag) {
    const env_6 = { stack: [], error: void 0, hasError: false };
    try {
      const tx = __addDisposableResource(env_6, this.store.transaction(), false);
      const node = this.findInodeSync(tx, path, "openFile");
      const data = this.getSync(tx, node.data, path, "openFile");
      return new PreloadFile(this, path, flag, node.toStats(), data);
    } catch (e_6) {
      env_6.error = e_6;
      env_6.hasError = true;
    } finally {
      __disposeResources(env_6);
    }
  }
  async unlink(path) {
    return this.remove(path, false, "unlink");
  }
  unlinkSync(path) {
    this.removeSync(path, false, "unlink");
  }
  async rmdir(path) {
    if ((await this.readdir(path)).length) {
      throw ErrnoError.With("ENOTEMPTY", path, "rmdir");
    }
    await this.remove(path, true, "rmdir");
  }
  rmdirSync(path) {
    if (this.readdirSync(path).length) {
      throw ErrnoError.With("ENOTEMPTY", path, "rmdir");
    }
    this.removeSync(path, true, "rmdir");
  }
  async mkdir(path, mode) {
    await this.commitNew(path, S_IFDIR, mode, encodeUTF8("{}"), "mkdir");
  }
  mkdirSync(path, mode) {
    this.commitNewSync(path, S_IFDIR, mode, encodeUTF8("{}"), "mkdir");
  }
  async readdir(path) {
    const env_7 = { stack: [], error: void 0, hasError: false };
    try {
      const tx = __addDisposableResource(env_7, this.store.transaction(), true);
      const node = await this.findInode(tx, path, "readdir");
      return Object.keys(decodeDirListing(await this.get(tx, node.data, path, "readdir")));
    } catch (e_7) {
      env_7.error = e_7;
      env_7.hasError = true;
    } finally {
      const result_4 = __disposeResources(env_7);
      if (result_4)
        await result_4;
    }
  }
  readdirSync(path) {
    const env_8 = { stack: [], error: void 0, hasError: false };
    try {
      const tx = __addDisposableResource(env_8, this.store.transaction(), false);
      const node = this.findInodeSync(tx, path, "readdir");
      return Object.keys(decodeDirListing(this.getSync(tx, node.data, path, "readdir")));
    } catch (e_8) {
      env_8.error = e_8;
      env_8.hasError = true;
    } finally {
      __disposeResources(env_8);
    }
  }
  /**
   * Updated the inode and data node at `path`
   * @todo Ensure mtime updates properly, and use that to determine if a data update is required.
   */
  async sync(path, data, stats2) {
    const env_9 = { stack: [], error: void 0, hasError: false };
    try {
      const tx = __addDisposableResource(env_9, this.store.transaction(), true);
      const fileInodeId = await this._findInode(tx, path, "sync"), fileInode = new Inode(await this.get(tx, fileInodeId, path, "sync")), inodeChanged = fileInode.update(stats2);
      await tx.set(fileInode.data, data);
      if (inodeChanged) {
        await tx.set(fileInodeId, serialize(fileInode));
      }
      await tx.commit();
    } catch (e_9) {
      env_9.error = e_9;
      env_9.hasError = true;
    } finally {
      const result_5 = __disposeResources(env_9);
      if (result_5)
        await result_5;
    }
  }
  /**
   * Updated the inode and data node at `path`
   * @todo Ensure mtime updates properly, and use that to determine if a data update is required.
   */
  syncSync(path, data, stats2) {
    const env_10 = { stack: [], error: void 0, hasError: false };
    try {
      const tx = __addDisposableResource(env_10, this.store.transaction(), false);
      const fileInodeId = this._findInodeSync(tx, path, "sync"), fileInode = new Inode(this.getSync(tx, fileInodeId, path, "sync")), inodeChanged = fileInode.update(stats2);
      tx.setSync(fileInode.data, data);
      if (inodeChanged) {
        tx.setSync(fileInodeId, serialize(fileInode));
      }
      tx.commitSync();
    } catch (e_10) {
      env_10.error = e_10;
      env_10.hasError = true;
    } finally {
      __disposeResources(env_10);
    }
  }
  async link(target, link3) {
    const env_11 = { stack: [], error: void 0, hasError: false };
    try {
      const tx = __addDisposableResource(env_11, this.store.transaction(), true);
      const newDir = dirname(link3), newDirNode = await this.findInode(tx, newDir, "link"), listing = decodeDirListing(await this.get(tx, newDirNode.data, newDir, "link"));
      const ino = await this._findInode(tx, target, "link");
      const node = new Inode(await this.get(tx, ino, target, "link"));
      node.nlink++;
      listing[basename(link3)] = ino;
      tx.setSync(ino, serialize(node));
      tx.setSync(newDirNode.data, encodeDirListing(listing));
      tx.commitSync();
    } catch (e_11) {
      env_11.error = e_11;
      env_11.hasError = true;
    } finally {
      const result_6 = __disposeResources(env_11);
      if (result_6)
        await result_6;
    }
  }
  linkSync(target, link3) {
    const env_12 = { stack: [], error: void 0, hasError: false };
    try {
      const tx = __addDisposableResource(env_12, this.store.transaction(), false);
      const newDir = dirname(link3), newDirNode = this.findInodeSync(tx, newDir, "link"), listing = decodeDirListing(this.getSync(tx, newDirNode.data, newDir, "link"));
      const ino = this._findInodeSync(tx, target, "link");
      const node = new Inode(this.getSync(tx, ino, target, "link"));
      node.nlink++;
      listing[basename(link3)] = ino;
      tx.setSync(ino, serialize(node));
      tx.setSync(newDirNode.data, encodeDirListing(listing));
      tx.commitSync();
    } catch (e_12) {
      env_12.error = e_12;
      env_12.hasError = true;
    } finally {
      __disposeResources(env_12);
    }
  }
  /**
   * Checks if the root directory exists. Creates it if it doesn't.
   */
  async checkRoot() {
    const env_13 = { stack: [], error: void 0, hasError: false };
    try {
      const tx = __addDisposableResource(env_13, this.store.transaction(), true);
      if (await tx.get(rootIno)) {
        return;
      }
      const inode = new Inode();
      inode.ino = rootIno;
      inode.mode = 511 | S_IFDIR;
      await tx.set(inode.data, encodeUTF8("{}"));
      await tx.set(rootIno, serialize(inode));
      await tx.commit();
    } catch (e_13) {
      env_13.error = e_13;
      env_13.hasError = true;
    } finally {
      const result_7 = __disposeResources(env_13);
      if (result_7)
        await result_7;
    }
  }
  /**
   * Checks if the root directory exists. Creates it if it doesn't.
   */
  checkRootSync() {
    const env_14 = { stack: [], error: void 0, hasError: false };
    try {
      const tx = __addDisposableResource(env_14, this.store.transaction(), false);
      if (tx.getSync(rootIno)) {
        return;
      }
      const inode = new Inode();
      inode.ino = rootIno;
      inode.mode = 511 | S_IFDIR;
      tx.setSync(inode.data, encodeUTF8("{}"));
      tx.setSync(rootIno, serialize(inode));
      tx.commitSync();
    } catch (e_14) {
      env_14.error = e_14;
      env_14.hasError = true;
    } finally {
      __disposeResources(env_14);
    }
  }
  /**
   * Helper function for findINode.
   * @param parent The parent directory of the file we are attempting to find.
   * @param filename The filename of the inode we are attempting to find, minus
   *   the parent.
   */
  async _findInode(tx, path, syscall, visited = /* @__PURE__ */ new Set()) {
    if (visited.has(path)) {
      throw new ErrnoError(Errno.EIO, "Infinite loop detected while finding inode", path);
    }
    visited.add(path);
    if (path == "/") {
      return rootIno;
    }
    const { dir: parent, base: filename } = parse2(path);
    const inode = parent == "/" ? new Inode(await this.get(tx, rootIno, parent, syscall)) : await this.findInode(tx, parent, syscall, visited);
    const dirList = decodeDirListing(await this.get(tx, inode.data, parent, syscall));
    if (!(filename in dirList)) {
      throw ErrnoError.With("ENOENT", resolve(parent, filename), syscall);
    }
    return dirList[filename];
  }
  /**
   * Helper function for findINode.
   * @param parent The parent directory of the file we are attempting to find.
   * @param filename The filename of the inode we are attempting to find, minus
   *   the parent.
   * @return string The ID of the file's inode in the file system.
   */
  _findInodeSync(tx, path, syscall, visited = /* @__PURE__ */ new Set()) {
    if (visited.has(path)) {
      throw new ErrnoError(Errno.EIO, "Infinite loop detected while finding inode", path);
    }
    visited.add(path);
    if (path == "/") {
      return rootIno;
    }
    const { dir: parent, base: filename } = parse2(path);
    const inode = parent == "/" ? new Inode(this.getSync(tx, rootIno, parent, syscall)) : this.findInodeSync(tx, parent, syscall, visited);
    const dir = decodeDirListing(this.getSync(tx, inode.data, parent, syscall));
    if (!(filename in dir)) {
      throw ErrnoError.With("ENOENT", resolve(parent, filename), syscall);
    }
    return dir[filename];
  }
  /**
   * Finds the Inode of `path`.
   * @param path The path to look up.
   * @todo memoize/cache
   */
  async findInode(tx, path, syscall, visited = /* @__PURE__ */ new Set()) {
    const ino = await this._findInode(tx, path, syscall, visited);
    return new Inode(await this.get(tx, ino, path, syscall));
  }
  /**
   * Finds the Inode of `path`.
   * @param path The path to look up.
   * @return The Inode of the path p.
   * @todo memoize/cache
   */
  findInodeSync(tx, path, syscall, visited = /* @__PURE__ */ new Set()) {
    const ino = this._findInodeSync(tx, path, syscall, visited);
    return new Inode(this.getSync(tx, ino, path, syscall));
  }
  /**
   * Given an ID, retrieves the corresponding data.
   * @param tx The transaction to use.
   * @param path The corresponding path to the file (used for error messages).
   * @param id The ID to look up.
   */
  async get(tx, id, path, syscall) {
    const data = await tx.get(id);
    if (!data) {
      throw ErrnoError.With("ENOENT", path, syscall);
    }
    return data;
  }
  /**
   * Given an ID, retrieves the corresponding data.
   * @param tx The transaction to use.
   * @param path The corresponding path to the file (used for error messages).
   * @param id The ID to look up.
   */
  getSync(tx, id, path, syscall) {
    const data = tx.getSync(id);
    if (!data) {
      throw ErrnoError.With("ENOENT", path, syscall);
    }
    return data;
  }
  /**
   * Adds a new node under a random ID. Retries before giving up in
   * the exceedingly unlikely chance that we try to reuse a random id.
   */
  async allocNew(tx, path, syscall) {
    for (let i = 0; i < maxInodeAllocTries; i++) {
      const ino = randomBigInt();
      if (await tx.get(ino)) {
        continue;
      }
      return ino;
    }
    throw new ErrnoError(Errno.ENOSPC, "No IDs available", path, syscall);
  }
  /**
   * Creates a new node under a random ID. Retries before giving up in
   * the exceedingly unlikely chance that we try to reuse a random id.
   * @return The ino that the data was stored under.
   */
  allocNewSync(tx, path, syscall) {
    for (let i = 0; i < maxInodeAllocTries; i++) {
      const ino = randomBigInt();
      if (tx.getSync(ino)) {
        continue;
      }
      return ino;
    }
    throw new ErrnoError(Errno.ENOSPC, "No IDs available", path, syscall);
  }
  /**
   * Commits a new file (well, a FILE or a DIRECTORY) to the file system with `mode`.
   * Note: This will commit the transaction.
   * @param path The path to the new file.
   * @param type The type of the new file.
   * @param mode The mode to create the new file with.
   * @param data The data to store at the file's data node.
   */
  async commitNew(path, type, mode, data, syscall) {
    const env_15 = { stack: [], error: void 0, hasError: false };
    try {
      if (path == "/") {
        throw ErrnoError.With("EEXIST", path, syscall);
      }
      const tx = __addDisposableResource(env_15, this.store.transaction(), true);
      const { dir: parentPath, base: fname } = parse2(path);
      const parent = await this.findInode(tx, parentPath, syscall);
      const listing = decodeDirListing(await this.get(tx, parent.data, parentPath, syscall));
      if (listing[fname]) {
        throw ErrnoError.With("EEXIST", path, syscall);
      }
      const inode = new Inode();
      inode.ino = await this.allocNew(tx, path, syscall);
      inode.data = await this.allocNew(tx, path, syscall);
      inode.mode = mode | type;
      inode.uid = parent.mode & S_ISUID ? parent.uid : credentials.uid;
      inode.gid = parent.mode & S_ISGID ? parent.gid : credentials.gid;
      inode.size = data.length;
      await tx.set(inode.ino, serialize(inode));
      await tx.set(inode.data, data);
      listing[fname] = inode.ino;
      await tx.set(parent.data, encodeDirListing(listing));
      await tx.commit();
      return inode;
    } catch (e_15) {
      env_15.error = e_15;
      env_15.hasError = true;
    } finally {
      const result_8 = __disposeResources(env_15);
      if (result_8)
        await result_8;
    }
  }
  /**
   * Commits a new file (well, a FILE or a DIRECTORY) to the file system with `mode`.
   * Note: This will commit the transaction.
   * @param path The path to the new file.
   * @param type The type of the new file.
   * @param mode The mode to create the new file with.
   * @param data The data to store at the file's data node.
   * @return The Inode for the new file.
   */
  commitNewSync(path, type, mode, data, syscall) {
    const env_16 = { stack: [], error: void 0, hasError: false };
    try {
      if (path == "/") {
        throw ErrnoError.With("EEXIST", path, syscall);
      }
      const tx = __addDisposableResource(env_16, this.store.transaction(), false);
      const { dir: parentPath, base: fname } = parse2(path);
      const parent = this.findInodeSync(tx, parentPath, syscall);
      const listing = decodeDirListing(this.getSync(tx, parent.data, parentPath, syscall));
      if (listing[fname]) {
        throw ErrnoError.With("EEXIST", path, syscall);
      }
      const inode = new Inode();
      inode.ino = this.allocNewSync(tx, path, syscall);
      inode.data = this.allocNewSync(tx, path, syscall);
      inode.size = data.length;
      inode.mode = mode | type;
      inode.uid = parent.mode & S_ISUID ? parent.uid : credentials.uid;
      inode.gid = parent.mode & S_ISGID ? parent.gid : credentials.gid;
      tx.setSync(inode.ino, serialize(inode));
      tx.setSync(inode.data, data);
      listing[fname] = inode.ino;
      tx.setSync(parent.data, encodeDirListing(listing));
      tx.commitSync();
      return inode;
    } catch (e_16) {
      env_16.error = e_16;
      env_16.hasError = true;
    } finally {
      __disposeResources(env_16);
    }
  }
  /**
   * Remove all traces of `path` from the file system.
   * @param path The path to remove from the file system.
   * @param isDir Does the path belong to a directory, or a file?
   * @todo Update mtime.
   */
  async remove(path, isDir, syscall) {
    const env_17 = { stack: [], error: void 0, hasError: false };
    try {
      const tx = __addDisposableResource(env_17, this.store.transaction(), true);
      const { dir: parent, base: fileName } = parse2(path), parentNode = await this.findInode(tx, parent, syscall), listing = decodeDirListing(await this.get(tx, parentNode.data, parent, syscall));
      if (!listing[fileName]) {
        throw ErrnoError.With("ENOENT", path, "remove");
      }
      const fileIno = listing[fileName];
      const fileNode = new Inode(await this.get(tx, fileIno, path, syscall));
      delete listing[fileName];
      if (!isDir && fileNode.toStats().isDirectory()) {
        throw ErrnoError.With("EISDIR", path, "remove");
      }
      await tx.set(parentNode.data, encodeDirListing(listing));
      if (--fileNode.nlink < 1) {
        await tx.remove(fileNode.data);
        await tx.remove(fileIno);
      }
      await tx.commit();
    } catch (e_17) {
      env_17.error = e_17;
      env_17.hasError = true;
    } finally {
      const result_9 = __disposeResources(env_17);
      if (result_9)
        await result_9;
    }
  }
  /**
   * Remove all traces of `path` from the file system.
   * @param path The path to remove from the file system.
   * @param isDir Does the path belong to a directory, or a file?
   * @todo Update mtime.
   */
  removeSync(path, isDir, syscall) {
    const env_18 = { stack: [], error: void 0, hasError: false };
    try {
      const tx = __addDisposableResource(env_18, this.store.transaction(), false);
      const { dir: parent, base: fileName } = parse2(path), parentNode = this.findInodeSync(tx, parent, syscall), listing = decodeDirListing(this.getSync(tx, parentNode.data, parent, syscall)), fileIno = listing[fileName];
      if (!fileIno) {
        throw ErrnoError.With("ENOENT", path, "remove");
      }
      const fileNode = new Inode(this.getSync(tx, fileIno, path, syscall));
      delete listing[fileName];
      if (!isDir && fileNode.toStats().isDirectory()) {
        throw ErrnoError.With("EISDIR", path, "remove");
      }
      tx.setSync(parentNode.data, encodeDirListing(listing));
      if (--fileNode.nlink < 1) {
        tx.removeSync(fileNode.data);
        tx.removeSync(fileIno);
      }
      tx.commitSync();
    } catch (e_18) {
      env_18.error = e_18;
      env_18.hasError = true;
    } finally {
      __disposeResources(env_18);
    }
  }
};

// node_modules/@zenfs/core/dist/backends/store/store.js
var Transaction = class {
  constructor(store) {
    this.store = store;
    this.done = false;
  }
  async [Symbol.asyncDispose]() {
    if (this.done) {
      return;
    }
    await this.abort();
  }
  [Symbol.dispose]() {
    if (this.done) {
      return;
    }
    this.abortSync();
  }
};
var SyncTransaction = class extends Transaction {
  /* eslint-disable @typescript-eslint/require-await */
  async keys() {
    return this.keysSync();
  }
  async get(id) {
    return this.getSync(id);
  }
  async set(id, data) {
    return this.setSync(id, data);
  }
  async remove(id) {
    return this.removeSync(id);
  }
  async commit() {
    return this.commitSync();
  }
  async abort() {
    return this.abortSync();
  }
};
var AsyncTransaction = class extends Transaction {
  keysSync() {
    throw ErrnoError.With("ENOSYS", void 0, "AsyncTransaction.keysSync");
  }
  getSync() {
    throw ErrnoError.With("ENOSYS", void 0, "AsyncTransaction.getSync");
  }
  setSync() {
    throw ErrnoError.With("ENOSYS", void 0, "AsyncTransaction.setSync");
  }
  removeSync() {
    throw ErrnoError.With("ENOSYS", void 0, "AsyncTransaction.removeSync");
  }
  commitSync() {
    throw ErrnoError.With("ENOSYS", void 0, "AsyncTransaction.commitSync");
  }
  abortSync() {
    throw ErrnoError.With("ENOSYS", void 0, "AsyncTransaction.abortSync");
  }
};

// node_modules/@zenfs/core/dist/backends/store/simple.js
var SimpleAsyncStore = class {
  constructor() {
    this.cache = /* @__PURE__ */ new Map();
    this.queue = /* @__PURE__ */ new Set();
  }
  keys() {
    return this.cache.keys();
  }
  get(id) {
    return this.cache.get(id);
  }
  set(id, data) {
    this.cache.set(id, data);
    this.queue.add(this._set(id, data));
  }
  delete(id) {
    this.cache.delete(id);
    this.queue.add(this._delete(id));
  }
  clearSync() {
    this.cache.clear();
    this.queue.add(this.clear());
  }
  async sync() {
    for (const [ino, data] of await this.entries()) {
      if (!this.cache.has(ino)) {
        this.cache.set(ino, data);
      }
    }
    for (const promise of this.queue) {
      await promise;
    }
  }
  transaction() {
    return new SimpleTransaction(this);
  }
};
var SimpleTransaction = class extends SyncTransaction {
  constructor() {
    super(...arguments);
    this.originalData = /* @__PURE__ */ new Map();
    this.modifiedKeys = /* @__PURE__ */ new Set();
  }
  keysSync() {
    return this.store.keys();
  }
  getSync(id) {
    const val = this.store.get(id);
    this.stashOldValue(id, val);
    return val;
  }
  setSync(id, data) {
    this.markModified(id);
    return this.store.set(id, data);
  }
  removeSync(id) {
    this.markModified(id);
    this.store.delete(id);
  }
  commitSync() {
    this.done = true;
  }
  abortSync() {
    if (!this.done) {
      return;
    }
    for (const key of this.modifiedKeys) {
      const value = this.originalData.get(key);
      if (!value) {
        this.store.delete(key);
      } else {
        this.store.set(key, value);
      }
    }
    this.done = true;
  }
  /**
   * Stashes given key value pair into `originalData` if it doesn't already
   * exist. Allows us to stash values the program is requesting anyway to
   * prevent needless `get` requests if the program modifies the data later
   * on during the transaction.
   */
  stashOldValue(id, value) {
    if (!this.originalData.has(id)) {
      this.originalData.set(id, value);
    }
  }
  /**
   * Marks `ino` as modified, and stashes its value if it has not been
   * stashed already.
   */
  markModified(id) {
    this.modifiedKeys.add(id);
    if (!this.originalData.has(id)) {
      this.originalData.set(id, this.store.get(id));
    }
  }
};

// node_modules/@zenfs/core/dist/backends/memory.js
var InMemoryStore = class extends Map {
  constructor(name = "tmp") {
    super();
    this.name = name;
  }
  async sync() {
  }
  clearSync() {
    this.clear();
  }
  transaction() {
    return new SimpleTransaction(this);
  }
};
var _InMemory = {
  name: "InMemory",
  options: {
    name: { type: "string", required: false }
  },
  create({ name }) {
    const fs = new StoreFS(new InMemoryStore(name));
    fs.checkRootSync();
    return fs;
  }
};
var InMemory = _InMemory;

// node_modules/@zenfs/core/dist/mixins/mutexed.js
var __addDisposableResource2 = function(env, value, async) {
  if (value !== null && value !== void 0) {
    if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
    var dispose, inner;
    if (async) {
      if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
      dispose = value[Symbol.asyncDispose];
    }
    if (dispose === void 0) {
      if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
      dispose = value[Symbol.dispose];
      if (async) inner = dispose;
    }
    if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
    if (inner) dispose = function() {
      try {
        inner.call(this);
      } catch (e) {
        return Promise.reject(e);
      }
    };
    env.stack.push({ value, dispose, async });
  } else if (async) {
    env.stack.push({ async: true });
  }
  return value;
};
var __disposeResources2 = /* @__PURE__ */ function(SuppressedError2) {
  return function(env) {
    function fail(e) {
      env.error = env.hasError ? new SuppressedError2(e, env.error, "An error was suppressed during disposal.") : e;
      env.hasError = true;
    }
    var r, s = 0;
    function next() {
      while (r = env.stack.pop()) {
        try {
          if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);
          if (r.dispose) {
            var result = r.dispose.call(r.value);
            if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) {
              fail(e);
              return next();
            });
          } else s |= 1;
        } catch (e) {
          fail(e);
        }
      }
      if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
      if (env.hasError) throw env.error;
    }
    return next();
  };
}(typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
});
var MutexLock = class {
  get isLocked() {
    return this._isLocked;
  }
  constructor(previous) {
    this.previous = previous;
    this.current = Promise.withResolvers();
    this._isLocked = true;
  }
  async done() {
    var _a3;
    await ((_a3 = this.previous) === null || _a3 === void 0 ? void 0 : _a3.done());
    await this.current.promise;
  }
  unlock() {
    this.current.resolve();
    this._isLocked = false;
  }
  [Symbol.dispose]() {
    this.unlock();
  }
};
var _MutexedFS = class {
  async ready() {
    return await this._fs.ready();
  }
  metadata() {
    return this._fs.metadata();
  }
  /**
   * Adds a lock for a path
   */
  addLock() {
    const lock = new MutexLock(this.currentLock);
    this.currentLock = lock;
    return lock;
  }
  /**
   * Locks `path` asynchronously.
   * If the path is currently locked, waits for it to be unlocked.
   * @internal
   */
  async lock(path, syscall) {
    const previous = this.currentLock;
    const lock = this.addLock();
    const stack = new Error().stack;
    setTimeout(() => {
      if (lock.isLocked) {
        const error = ErrnoError.With("EDEADLK", path, syscall);
        error.stack += stack === null || stack === void 0 ? void 0 : stack.slice("Error".length);
        throw error;
      }
    }, 5e3);
    await (previous === null || previous === void 0 ? void 0 : previous.done());
    return lock;
  }
  /**
   * Locks `path` asynchronously.
   * If the path is currently locked, an error will be thrown
   * @internal
   */
  lockSync(path, syscall) {
    var _a3;
    if ((_a3 = this.currentLock) === null || _a3 === void 0 ? void 0 : _a3.isLocked) {
      throw ErrnoError.With("EBUSY", path, syscall);
    }
    return this.addLock();
  }
  /**
   * Whether `path` is locked
   * @internal
   */
  get isLocked() {
    var _a3;
    return !!((_a3 = this.currentLock) === null || _a3 === void 0 ? void 0 : _a3.isLocked);
  }
  /* eslint-disable @typescript-eslint/no-unused-vars */
  async rename(oldPath, newPath) {
    const env_1 = { stack: [], error: void 0, hasError: false };
    try {
      const _ = __addDisposableResource2(env_1, await this.lock(oldPath, "rename"), false);
      await this._fs.rename(oldPath, newPath);
    } catch (e_1) {
      env_1.error = e_1;
      env_1.hasError = true;
    } finally {
      __disposeResources2(env_1);
    }
  }
  renameSync(oldPath, newPath) {
    const env_2 = { stack: [], error: void 0, hasError: false };
    try {
      const _ = __addDisposableResource2(env_2, this.lockSync(oldPath, "rename"), false);
      return this._fs.renameSync(oldPath, newPath);
    } catch (e_2) {
      env_2.error = e_2;
      env_2.hasError = true;
    } finally {
      __disposeResources2(env_2);
    }
  }
  async stat(path) {
    const env_3 = { stack: [], error: void 0, hasError: false };
    try {
      const _ = __addDisposableResource2(env_3, await this.lock(path, "stat"), false);
      return await this._fs.stat(path);
    } catch (e_3) {
      env_3.error = e_3;
      env_3.hasError = true;
    } finally {
      __disposeResources2(env_3);
    }
  }
  statSync(path) {
    const env_4 = { stack: [], error: void 0, hasError: false };
    try {
      const _ = __addDisposableResource2(env_4, this.lockSync(path, "stat"), false);
      return this._fs.statSync(path);
    } catch (e_4) {
      env_4.error = e_4;
      env_4.hasError = true;
    } finally {
      __disposeResources2(env_4);
    }
  }
  async openFile(path, flag) {
    const env_5 = { stack: [], error: void 0, hasError: false };
    try {
      const _ = __addDisposableResource2(env_5, await this.lock(path, "openFile"), false);
      const file = await this._fs.openFile(path, flag);
      file.fs = this;
      return file;
    } catch (e_5) {
      env_5.error = e_5;
      env_5.hasError = true;
    } finally {
      __disposeResources2(env_5);
    }
  }
  openFileSync(path, flag) {
    const env_6 = { stack: [], error: void 0, hasError: false };
    try {
      const _ = __addDisposableResource2(env_6, this.lockSync(path, "openFile"), false);
      const file = this._fs.openFileSync(path, flag);
      file.fs = this;
      return file;
    } catch (e_6) {
      env_6.error = e_6;
      env_6.hasError = true;
    } finally {
      __disposeResources2(env_6);
    }
  }
  async createFile(path, flag, mode, options) {
    const env_7 = { stack: [], error: void 0, hasError: false };
    try {
      const _ = __addDisposableResource2(env_7, await this.lock(path, "createFile"), false);
      const file = await this._fs.createFile(path, flag, mode, options);
      file.fs = this;
      return file;
    } catch (e_7) {
      env_7.error = e_7;
      env_7.hasError = true;
    } finally {
      __disposeResources2(env_7);
    }
  }
  createFileSync(path, flag, mode, options) {
    const env_8 = { stack: [], error: void 0, hasError: false };
    try {
      const _ = __addDisposableResource2(env_8, this.lockSync(path, "createFile"), false);
      const file = this._fs.createFileSync(path, flag, mode, options);
      file.fs = this;
      return file;
    } catch (e_8) {
      env_8.error = e_8;
      env_8.hasError = true;
    } finally {
      __disposeResources2(env_8);
    }
  }
  async unlink(path) {
    const env_9 = { stack: [], error: void 0, hasError: false };
    try {
      const _ = __addDisposableResource2(env_9, await this.lock(path, "unlink"), false);
      await this._fs.unlink(path);
    } catch (e_9) {
      env_9.error = e_9;
      env_9.hasError = true;
    } finally {
      __disposeResources2(env_9);
    }
  }
  unlinkSync(path) {
    const env_10 = { stack: [], error: void 0, hasError: false };
    try {
      const _ = __addDisposableResource2(env_10, this.lockSync(path, "unlink"), false);
      return this._fs.unlinkSync(path);
    } catch (e_10) {
      env_10.error = e_10;
      env_10.hasError = true;
    } finally {
      __disposeResources2(env_10);
    }
  }
  async rmdir(path) {
    const env_11 = { stack: [], error: void 0, hasError: false };
    try {
      const _ = __addDisposableResource2(env_11, await this.lock(path, "rmdir"), false);
      await this._fs.rmdir(path);
    } catch (e_11) {
      env_11.error = e_11;
      env_11.hasError = true;
    } finally {
      __disposeResources2(env_11);
    }
  }
  rmdirSync(path) {
    const env_12 = { stack: [], error: void 0, hasError: false };
    try {
      const _ = __addDisposableResource2(env_12, this.lockSync(path, "rmdir"), false);
      return this._fs.rmdirSync(path);
    } catch (e_12) {
      env_12.error = e_12;
      env_12.hasError = true;
    } finally {
      __disposeResources2(env_12);
    }
  }
  async mkdir(path, mode, options) {
    const env_13 = { stack: [], error: void 0, hasError: false };
    try {
      const _ = __addDisposableResource2(env_13, await this.lock(path, "mkdir"), false);
      await this._fs.mkdir(path, mode, options);
    } catch (e_13) {
      env_13.error = e_13;
      env_13.hasError = true;
    } finally {
      __disposeResources2(env_13);
    }
  }
  mkdirSync(path, mode, options) {
    const env_14 = { stack: [], error: void 0, hasError: false };
    try {
      const _ = __addDisposableResource2(env_14, this.lockSync(path, "mkdir"), false);
      return this._fs.mkdirSync(path, mode, options);
    } catch (e_14) {
      env_14.error = e_14;
      env_14.hasError = true;
    } finally {
      __disposeResources2(env_14);
    }
  }
  async readdir(path) {
    const env_15 = { stack: [], error: void 0, hasError: false };
    try {
      const _ = __addDisposableResource2(env_15, await this.lock(path, "readdir"), false);
      return await this._fs.readdir(path);
    } catch (e_15) {
      env_15.error = e_15;
      env_15.hasError = true;
    } finally {
      __disposeResources2(env_15);
    }
  }
  readdirSync(path) {
    const env_16 = { stack: [], error: void 0, hasError: false };
    try {
      const _ = __addDisposableResource2(env_16, this.lockSync(path, "readdir"), false);
      return this._fs.readdirSync(path);
    } catch (e_16) {
      env_16.error = e_16;
      env_16.hasError = true;
    } finally {
      __disposeResources2(env_16);
    }
  }
  async exists(path) {
    const env_17 = { stack: [], error: void 0, hasError: false };
    try {
      const _ = __addDisposableResource2(env_17, await this.lock(path, "exists"), false);
      return await this._fs.exists(path);
    } catch (e_17) {
      env_17.error = e_17;
      env_17.hasError = true;
    } finally {
      __disposeResources2(env_17);
    }
  }
  existsSync(path) {
    const env_18 = { stack: [], error: void 0, hasError: false };
    try {
      const _ = __addDisposableResource2(env_18, this.lockSync(path, "exists"), false);
      return this._fs.existsSync(path);
    } catch (e_18) {
      env_18.error = e_18;
      env_18.hasError = true;
    } finally {
      __disposeResources2(env_18);
    }
  }
  async link(srcpath, dstpath) {
    const env_19 = { stack: [], error: void 0, hasError: false };
    try {
      const _ = __addDisposableResource2(env_19, await this.lock(srcpath, "link"), false);
      await this._fs.link(srcpath, dstpath);
    } catch (e_19) {
      env_19.error = e_19;
      env_19.hasError = true;
    } finally {
      __disposeResources2(env_19);
    }
  }
  linkSync(srcpath, dstpath) {
    const env_20 = { stack: [], error: void 0, hasError: false };
    try {
      const _ = __addDisposableResource2(env_20, this.lockSync(srcpath, "link"), false);
      return this._fs.linkSync(srcpath, dstpath);
    } catch (e_20) {
      env_20.error = e_20;
      env_20.hasError = true;
    } finally {
      __disposeResources2(env_20);
    }
  }
  async sync(path, data, stats2) {
    const env_21 = { stack: [], error: void 0, hasError: false };
    try {
      const _ = __addDisposableResource2(env_21, await this.lock(path, "sync"), false);
      await this._fs.sync(path, data, stats2);
    } catch (e_21) {
      env_21.error = e_21;
      env_21.hasError = true;
    } finally {
      __disposeResources2(env_21);
    }
  }
  syncSync(path, data, stats2) {
    const env_22 = { stack: [], error: void 0, hasError: false };
    try {
      const _ = __addDisposableResource2(env_22, this.lockSync(path, "sync"), false);
      return this._fs.syncSync(path, data, stats2);
    } catch (e_22) {
      env_22.error = e_22;
      env_22.hasError = true;
    } finally {
      __disposeResources2(env_22);
    }
  }
};
function Mutexed(FS) {
  class MutexedFS extends _MutexedFS {
    constructor(...args) {
      super();
      this._fs = new FS(...args);
    }
  }
  return MutexedFS;
}

// node_modules/@zenfs/core/dist/backends/overlay.js
var __addDisposableResource3 = function(env, value, async) {
  if (value !== null && value !== void 0) {
    if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
    var dispose, inner;
    if (async) {
      if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
      dispose = value[Symbol.asyncDispose];
    }
    if (dispose === void 0) {
      if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
      dispose = value[Symbol.dispose];
      if (async) inner = dispose;
    }
    if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
    if (inner) dispose = function() {
      try {
        inner.call(this);
      } catch (e) {
        return Promise.reject(e);
      }
    };
    env.stack.push({ value, dispose, async });
  } else if (async) {
    env.stack.push({ async: true });
  }
  return value;
};
var __disposeResources3 = /* @__PURE__ */ function(SuppressedError2) {
  return function(env) {
    function fail(e) {
      env.error = env.hasError ? new SuppressedError2(e, env.error, "An error was suppressed during disposal.") : e;
      env.hasError = true;
    }
    var r, s = 0;
    function next() {
      while (r = env.stack.pop()) {
        try {
          if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);
          if (r.dispose) {
            var result = r.dispose.call(r.value);
            if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) {
              fail(e);
              return next();
            });
          } else s |= 1;
        } catch (e) {
          fail(e);
        }
      }
      if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
      if (env.hasError) throw env.error;
    }
    return next();
  };
}(typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
});
var deletionLogPath = "/.deleted";
var UnmutexedOverlayFS = class extends FileSystem {
  async ready() {
    await this.readable.ready();
    await this.writable.ready();
    await this._ready;
  }
  constructor({ writable, readable }) {
    super();
    this._isInitialized = false;
    this._deletedFiles = /* @__PURE__ */ new Set();
    this._deleteLog = "";
    this._deleteLogUpdatePending = false;
    this._deleteLogUpdateNeeded = false;
    this.writable = writable;
    this.readable = readable;
    if (this.writable.metadata().readonly) {
      throw new ErrnoError(Errno.EINVAL, "Writable file system must be writable.");
    }
    this._ready = this._initialize();
  }
  metadata() {
    return {
      ...super.metadata(),
      name: OverlayFS.name
    };
  }
  async sync(path, data, stats2) {
    await this.copyForWrite(path);
    if (!await this.writable.exists(path)) {
      await this.writable.createFile(path, "w", 420, stats2);
    }
    await this.writable.sync(path, data, stats2);
  }
  syncSync(path, data, stats2) {
    this.copyForWriteSync(path);
    this.writable.syncSync(path, data, stats2);
  }
  /**
   * Called once to load up metadata stored on the writable file system.
   * @internal
   */
  async _initialize() {
    if (this._isInitialized) {
      return;
    }
    try {
      const file = await this.writable.openFile(deletionLogPath, parseFlag("r"));
      const { size } = await file.stat();
      const { buffer } = await file.read(new Uint8Array(size));
      this._deleteLog = decodeUTF8(buffer);
    } catch (err) {
      if (err.errno !== Errno.ENOENT) {
        throw err;
      }
    }
    this._isInitialized = true;
    this._reparseDeletionLog();
  }
  getDeletionLog() {
    return this._deleteLog;
  }
  async restoreDeletionLog(log) {
    this._deleteLog = log;
    this._reparseDeletionLog();
    await this.updateLog("");
  }
  async rename(oldPath, newPath) {
    this.checkInitialized();
    this.checkPath(oldPath);
    this.checkPath(newPath);
    await this.copyForWrite(oldPath);
    try {
      await this.writable.rename(oldPath, newPath);
    } catch {
      if (this._deletedFiles.has(oldPath)) {
        throw ErrnoError.With("ENOENT", oldPath, "rename");
      }
    }
  }
  renameSync(oldPath, newPath) {
    this.checkInitialized();
    this.checkPath(oldPath);
    this.checkPath(newPath);
    this.copyForWriteSync(oldPath);
    try {
      this.writable.renameSync(oldPath, newPath);
    } catch {
      if (this._deletedFiles.has(oldPath)) {
        throw ErrnoError.With("ENOENT", oldPath, "rename");
      }
    }
  }
  async stat(path) {
    this.checkInitialized();
    try {
      return await this.writable.stat(path);
    } catch {
      if (this._deletedFiles.has(path)) {
        throw ErrnoError.With("ENOENT", path, "stat");
      }
      const oldStat = await this.readable.stat(path);
      oldStat.mode |= 146;
      return oldStat;
    }
  }
  statSync(path) {
    this.checkInitialized();
    try {
      return this.writable.statSync(path);
    } catch {
      if (this._deletedFiles.has(path)) {
        throw ErrnoError.With("ENOENT", path, "stat");
      }
      const oldStat = this.readable.statSync(path);
      oldStat.mode |= 146;
      return oldStat;
    }
  }
  async openFile(path, flag) {
    if (await this.writable.exists(path)) {
      return this.writable.openFile(path, flag);
    }
    const file = await this.readable.openFile(path, parseFlag("r"));
    const stats2 = await file.stat();
    const { buffer } = await file.read(new Uint8Array(stats2.size));
    return new PreloadFile(this, path, flag, stats2, buffer);
  }
  openFileSync(path, flag) {
    if (this.writable.existsSync(path)) {
      return this.writable.openFileSync(path, flag);
    }
    const file = this.readable.openFileSync(path, parseFlag("r"));
    const stats2 = file.statSync();
    const data = new Uint8Array(stats2.size);
    file.readSync(data);
    return new PreloadFile(this, path, flag, stats2, data);
  }
  async createFile(path, flag, mode, options) {
    this.checkInitialized();
    await this.writable.createFile(path, flag, mode, options);
    return this.openFile(path, flag);
  }
  createFileSync(path, flag, mode, options) {
    this.checkInitialized();
    this.writable.createFileSync(path, flag, mode, options);
    return this.openFileSync(path, flag);
  }
  async link(srcpath, dstpath) {
    this.checkInitialized();
    await this.copyForWrite(srcpath);
    await this.writable.link(srcpath, dstpath);
  }
  linkSync(srcpath, dstpath) {
    this.checkInitialized();
    this.copyForWriteSync(srcpath);
    this.writable.linkSync(srcpath, dstpath);
  }
  async unlink(path) {
    this.checkInitialized();
    this.checkPath(path);
    if (!await this.exists(path)) {
      throw ErrnoError.With("ENOENT", path, "unlink");
    }
    if (await this.writable.exists(path)) {
      await this.writable.unlink(path);
    }
    if (await this.exists(path)) {
      await this.deletePath(path);
    }
  }
  unlinkSync(path) {
    this.checkInitialized();
    this.checkPath(path);
    if (!this.existsSync(path)) {
      throw ErrnoError.With("ENOENT", path, "unlink");
    }
    if (this.writable.existsSync(path)) {
      this.writable.unlinkSync(path);
    }
    if (this.existsSync(path)) {
      void this.deletePath(path);
    }
  }
  async rmdir(path) {
    this.checkInitialized();
    if (!await this.exists(path)) {
      throw ErrnoError.With("ENOENT", path, "rmdir");
    }
    if (await this.writable.exists(path)) {
      await this.writable.rmdir(path);
    }
    if (!await this.exists(path)) {
      return;
    }
    if ((await this.readdir(path)).length) {
      throw ErrnoError.With("ENOTEMPTY", path, "rmdir");
    }
    await this.deletePath(path);
  }
  rmdirSync(path) {
    this.checkInitialized();
    if (!this.existsSync(path)) {
      throw ErrnoError.With("ENOENT", path, "rmdir");
    }
    if (this.writable.existsSync(path)) {
      this.writable.rmdirSync(path);
    }
    if (!this.existsSync(path)) {
      return;
    }
    if (this.readdirSync(path).length) {
      throw ErrnoError.With("ENOTEMPTY", path, "rmdir");
    }
    void this.deletePath(path);
  }
  async mkdir(path, mode, options) {
    this.checkInitialized();
    if (await this.exists(path)) {
      throw ErrnoError.With("EEXIST", path, "mkdir");
    }
    await this.createParentDirectories(path);
    await this.writable.mkdir(path, mode, options);
  }
  mkdirSync(path, mode, options) {
    this.checkInitialized();
    if (this.existsSync(path)) {
      throw ErrnoError.With("EEXIST", path, "mkdir");
    }
    this.createParentDirectoriesSync(path);
    this.writable.mkdirSync(path, mode, options);
  }
  async readdir(path) {
    this.checkInitialized();
    const contents = [];
    try {
      contents.push(...await this.writable.readdir(path));
    } catch {
    }
    try {
      contents.push(...(await this.readable.readdir(path)).filter((fPath) => !this._deletedFiles.has(`${path}/${fPath}`)));
    } catch {
    }
    const seenMap = {};
    return contents.filter((path2) => {
      const result = !seenMap[path2];
      seenMap[path2] = true;
      return result;
    });
  }
  readdirSync(path) {
    this.checkInitialized();
    let contents = [];
    try {
      contents = contents.concat(this.writable.readdirSync(path));
    } catch {
    }
    try {
      contents = contents.concat(this.readable.readdirSync(path).filter((fPath) => !this._deletedFiles.has(`${path}/${fPath}`)));
    } catch {
    }
    const seenMap = {};
    return contents.filter((path2) => {
      const result = !seenMap[path2];
      seenMap[path2] = true;
      return result;
    });
  }
  async deletePath(path) {
    this._deletedFiles.add(path);
    await this.updateLog(`d${path}
`);
  }
  async updateLog(addition) {
    this._deleteLog += addition;
    if (this._deleteLogUpdatePending) {
      this._deleteLogUpdateNeeded = true;
      return;
    }
    this._deleteLogUpdatePending = true;
    const log = await this.writable.openFile(deletionLogPath, parseFlag("w"));
    try {
      await log.write(encodeUTF8(this._deleteLog));
      if (this._deleteLogUpdateNeeded) {
        this._deleteLogUpdateNeeded = false;
        await this.updateLog("");
      }
    } catch (e) {
      this._deleteLogError = e;
    } finally {
      this._deleteLogUpdatePending = false;
    }
  }
  _reparseDeletionLog() {
    this._deletedFiles.clear();
    for (const entry of this._deleteLog.split("\n")) {
      if (!entry.startsWith("d")) {
        continue;
      }
      this._deletedFiles.add(entry.slice(1));
    }
  }
  checkInitialized() {
    if (!this._isInitialized) {
      throw new ErrnoError(Errno.EPERM, "OverlayFS is not initialized. Please initialize OverlayFS using its initialize() method before using it.");
    }
    if (!this._deleteLogError) {
      return;
    }
    const error = this._deleteLogError;
    delete this._deleteLogError;
    throw error;
  }
  checkPath(path) {
    if (path == deletionLogPath) {
      throw ErrnoError.With("EPERM", path, "checkPath");
    }
  }
  /**
   * Create the needed parent directories on the writable storage should they not exist.
   * Use modes from the read-only storage.
   */
  createParentDirectoriesSync(path) {
    let parent = dirname(path);
    const toCreate = [];
    while (!this.writable.existsSync(parent)) {
      toCreate.push(parent);
      parent = dirname(parent);
    }
    for (const path2 of toCreate.reverse()) {
      const { uid, gid, mode } = this.statSync(path2);
      this.writable.mkdirSync(path2, mode, { uid, gid });
    }
  }
  /**
   * Create the needed parent directories on the writable storage should they not exist.
   * Use modes from the read-only storage.
   */
  async createParentDirectories(path) {
    let parent = dirname(path);
    const toCreate = [];
    while (!await this.writable.exists(parent)) {
      toCreate.push(parent);
      parent = dirname(parent);
    }
    for (const path2 of toCreate.reverse()) {
      const { uid, gid, mode } = await this.stat(path2);
      await this.writable.mkdir(path2, mode, { uid, gid });
    }
  }
  /**
   * Helper function:
   * - Ensures p is on writable before proceeding. Throws an error if it doesn't exist.
   * - Calls f to perform operation on writable.
   */
  copyForWriteSync(path) {
    if (!this.existsSync(path)) {
      throw ErrnoError.With("ENOENT", path, "copyForWrite");
    }
    if (!this.writable.existsSync(dirname(path))) {
      this.createParentDirectoriesSync(path);
    }
    if (!this.writable.existsSync(path)) {
      this.copyToWritableSync(path);
    }
  }
  async copyForWrite(path) {
    if (!await this.exists(path)) {
      throw ErrnoError.With("ENOENT", path, "copyForWrite");
    }
    if (!await this.writable.exists(dirname(path))) {
      await this.createParentDirectories(path);
    }
    if (!await this.writable.exists(path)) {
      return this.copyToWritable(path);
    }
  }
  /**
   * Copy from readable to writable storage.
   * PRECONDITION: File does not exist on writable storage.
   */
  copyToWritableSync(path) {
    const env_1 = { stack: [], error: void 0, hasError: false };
    try {
      const stats2 = this.statSync(path);
      if (stats2.isDirectory()) {
        this.writable.mkdirSync(path, stats2.mode, stats2);
        return;
      }
      const data = new Uint8Array(stats2.size);
      const readable = __addDisposableResource3(env_1, this.readable.openFileSync(path, "r"), false);
      readable.readSync(data);
      const writable = __addDisposableResource3(env_1, this.writable.createFileSync(path, "w", stats2.mode | 146, stats2), false);
      writable.writeSync(data);
    } catch (e_1) {
      env_1.error = e_1;
      env_1.hasError = true;
    } finally {
      __disposeResources3(env_1);
    }
  }
  async copyToWritable(path) {
    const env_2 = { stack: [], error: void 0, hasError: false };
    try {
      const stats2 = await this.stat(path);
      if (stats2.isDirectory()) {
        await this.writable.mkdir(path, stats2.mode, stats2);
        return;
      }
      const data = new Uint8Array(stats2.size);
      const readable = __addDisposableResource3(env_2, await this.readable.openFile(path, "r"), true);
      await readable.read(data);
      const writable = __addDisposableResource3(env_2, await this.writable.createFile(path, "w", stats2.mode | 146, stats2), true);
      await writable.write(data);
    } catch (e_2) {
      env_2.error = e_2;
      env_2.hasError = true;
    } finally {
      const result_1 = __disposeResources3(env_2);
      if (result_1)
        await result_1;
    }
  }
};
var OverlayFS = class extends Mutexed(UnmutexedOverlayFS) {
};
var _Overlay = {
  name: "Overlay",
  options: {
    writable: { type: "object", required: true },
    readable: { type: "object", required: true }
  },
  create(options) {
    return new OverlayFS(options);
  }
};
var Overlay = _Overlay;

// node_modules/@zenfs/core/dist/backends/passthrough.js
var PassthroughFile = class extends File {
  constructor(fs, path, fd) {
    super(fs, path);
    this.fd = fd;
    this.node = fs.nodeFS;
    this.nodePath = fs.path(path);
  }
  error(err) {
    const error = err;
    return ErrnoError.With(error.code, this.path, error.syscall);
  }
  get position() {
    return 0;
  }
  async stat() {
    const { resolve: resolve2, reject, promise } = Promise.withResolvers();
    this.node.fstat(this.fd, (err, stats2) => err ? reject(this.error(err)) : resolve2(new Stats(stats2)));
    return promise;
  }
  statSync() {
    return new Stats(this.node.fstatSync(this.fd));
  }
  close() {
    const { resolve: resolve2, reject, promise } = Promise.withResolvers();
    this.node.close(this.fd, (err) => err ? reject(this.error(err)) : resolve2());
    return promise;
  }
  closeSync() {
    this.node.closeSync(this.fd);
  }
  async truncate(len) {
    await this.node.promises.truncate(this.nodePath, len);
  }
  truncateSync(len) {
    this.node.ftruncateSync(this.fd, len);
  }
  async sync() {
    const { resolve: resolve2, reject, promise } = Promise.withResolvers();
    this.node.fsync(this.fd, (err) => err ? reject(this.error(err)) : resolve2());
    return promise;
  }
  syncSync() {
    this.node.fsyncSync(this.fd);
  }
  async write(buffer, offset, length, position) {
    const { resolve: resolve2, reject, promise } = Promise.withResolvers();
    this.node.write(this.fd, buffer, offset, length, position, (err, written) => err ? reject(this.error(err)) : resolve2(written));
    return promise;
  }
  writeSync(buffer, offset, length, position) {
    return this.node.writeSync(this.fd, buffer, offset, length, position);
  }
  async read(buffer, offset = 0, length, position = null) {
    const { resolve: resolve2, reject, promise } = Promise.withResolvers();
    this.node.read(this.fd, buffer, offset, length || (await this.stat()).size, position, (err, bytesRead, buffer2) => err ? reject(this.error(err)) : resolve2({ bytesRead, buffer: buffer2 }));
    return promise;
  }
  readSync(buffer, offset = 0, length = this.statSync().size, position = null) {
    return this.node.readSync(this.fd, buffer, offset, length, position);
  }
  async chmod(mode) {
    await this.node.promises.chmod(this.nodePath, mode);
  }
  chmodSync(mode) {
    this.node.fchmodSync(this.fd, mode);
  }
  async chown(uid, gid) {
    await this.node.promises.chown(this.nodePath, uid, gid);
  }
  chownSync(uid, gid) {
    this.node.fchownSync(this.fd, uid, gid);
  }
  async utimes(atime, mtime) {
    await this.node.promises.utimes(this.nodePath, atime, mtime);
  }
  utimesSync(atime, mtime) {
    this.node.futimesSync(this.fd, atime, mtime);
  }
};
var PassthroughFS = class extends FileSystem {
  constructor(nodeFS, prefix) {
    super();
    this.nodeFS = nodeFS;
    this.prefix = prefix;
  }
  path(path) {
    return join(this.prefix, path.slice(1));
  }
  error(err, path) {
    const error = err;
    throw ErrnoError.With(error.code, path, error.syscall);
  }
  /**
   * Rename a file or directory.
   */
  async rename(oldPath, newPath) {
    try {
      await this.nodeFS.promises.rename(this.path(oldPath), this.path(newPath));
    } catch (err) {
      this.error(err, oldPath);
    }
  }
  /**
   * Rename a file or directory synchronously.
   */
  renameSync(oldPath, newPath) {
    try {
      this.nodeFS.renameSync(this.path(oldPath), this.path(newPath));
    } catch (err) {
      this.error(err, oldPath);
    }
  }
  /**
   * Get file statistics.
   */
  async stat(path) {
    try {
      return new Stats(await this.nodeFS.promises.stat(this.path(path)));
    } catch (err) {
      this.error(err, path);
    }
  }
  /**
   * Get file statistics synchronously.
   */
  statSync(path) {
    try {
      return new Stats(this.nodeFS.statSync(this.path(path)));
    } catch (err) {
      this.error(err, path);
    }
  }
  /**
   * Open a file.
   */
  async openFile(path, flag) {
    try {
      const { fd } = await this.nodeFS.promises.open(this.path(path), flag);
      return new PassthroughFile(this, path, fd);
    } catch (err) {
      this.error(err, path);
    }
  }
  /**
   * Open a file synchronously.
   */
  openFileSync(path, flag) {
    try {
      const fd = this.nodeFS.openSync(this.path(path), flag);
      return new PassthroughFile(this, path, fd);
    } catch (err) {
      this.error(err, path);
    }
  }
  /**
   * Unlink (delete) a file.
   */
  async unlink(path) {
    try {
      await this.nodeFS.promises.unlink(this.path(path));
    } catch (err) {
      this.error(err, path);
    }
  }
  /**
   * Unlink (delete) a file synchronously.
   */
  unlinkSync(path) {
    try {
      this.nodeFS.unlinkSync(this.path(path));
    } catch (err) {
      this.error(err, path);
    }
  }
  /**
   * Create a directory.
   */
  async mkdir(path, mode) {
    try {
      await this.nodeFS.promises.mkdir(this.path(path), { mode });
    } catch (err) {
      this.error(err, path);
    }
  }
  /**
   * Create a directory synchronously.
   */
  mkdirSync(path, mode) {
    try {
      this.nodeFS.mkdirSync(this.path(path), { mode });
    } catch (err) {
      this.error(err, path);
    }
  }
  /**
   * Read the contents of a directory.
   */
  async readdir(path) {
    try {
      return await this.nodeFS.promises.readdir(this.path(path));
    } catch (err) {
      this.error(err, path);
    }
  }
  /**
   * Read the contents of a directory synchronously.
   */
  readdirSync(path) {
    try {
      return this.nodeFS.readdirSync(this.path(path));
    } catch (err) {
      this.error(err, path);
    }
  }
  /**
   * Create a file.
   */
  async createFile(path, flag, mode) {
    try {
      const { fd } = await this.nodeFS.promises.open(this.path(path), flag, mode);
      return new PassthroughFile(this, path, fd);
    } catch (err) {
      this.error(err, path);
    }
  }
  /**
   * Create a file synchronously.
   */
  createFileSync(path, flag, mode) {
    try {
      const fd = this.nodeFS.openSync(this.path(path), flag, mode);
      return new PassthroughFile(this, path, fd);
    } catch (err) {
      this.error(err, path);
    }
  }
  /**
   * Remove a directory.
   */
  async rmdir(path) {
    try {
      await this.nodeFS.promises.rmdir(this.path(path));
    } catch (err) {
      this.error(err, path);
    }
  }
  /**
   * Remove a directory synchronously.
   */
  rmdirSync(path) {
    try {
      this.nodeFS.rmdirSync(this.path(path));
    } catch (err) {
      this.error(err, path);
    }
  }
  /**
   * Synchronize data to the file system.
   */
  async sync(path, data, stats2) {
    try {
      await this.nodeFS.promises.writeFile(this.path(path), data);
    } catch (err) {
      this.error(err, path);
    }
  }
  /**
   * Synchronize data to the file system synchronously.
   */
  syncSync(path, data, stats2) {
    try {
      this.nodeFS.writeFileSync(this.path(path), data);
    } catch (err) {
      this.error(err, path);
    }
  }
  /**
   * Create a hard link.
   */
  async link(target, link3) {
    try {
      await this.nodeFS.promises.link(this.path(target), this.path(link3));
    } catch (err) {
      this.error(err, target);
    }
  }
  /**
   * Create a hard link synchronously.
   */
  linkSync(target, link3) {
    try {
      this.nodeFS.linkSync(this.path(target), this.path(link3));
    } catch (err) {
      this.error(err, target);
    }
  }
};
var _Passthrough = {
  name: "Passthrough",
  options: {
    fs: { type: "object", required: true },
    prefix: { type: "string", required: false }
  },
  create({ fs, prefix = "/" }) {
    return new PassthroughFS(fs, resolve(prefix));
  }
};
var Passthrough = _Passthrough;

// node_modules/@zenfs/core/dist/devices.js
var __addDisposableResource4 = function(env, value, async) {
  if (value !== null && value !== void 0) {
    if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
    var dispose, inner;
    if (async) {
      if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
      dispose = value[Symbol.asyncDispose];
    }
    if (dispose === void 0) {
      if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
      dispose = value[Symbol.dispose];
      if (async) inner = dispose;
    }
    if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
    if (inner) dispose = function() {
      try {
        inner.call(this);
      } catch (e) {
        return Promise.reject(e);
      }
    };
    env.stack.push({ value, dispose, async });
  } else if (async) {
    env.stack.push({ async: true });
  }
  return value;
};
var __disposeResources4 = /* @__PURE__ */ function(SuppressedError2) {
  return function(env) {
    function fail(e) {
      env.error = env.hasError ? new SuppressedError2(e, env.error, "An error was suppressed during disposal.") : e;
      env.hasError = true;
    }
    var r, s = 0;
    function next() {
      while (r = env.stack.pop()) {
        try {
          if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);
          if (r.dispose) {
            var result = r.dispose.call(r.value);
            if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) {
              fail(e);
              return next();
            });
          } else s |= 1;
        } catch (e) {
          fail(e);
        }
      }
      if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
      if (env.hasError) throw env.error;
    }
    return next();
  };
}(typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
});
var DeviceFile = class extends File {
  constructor(fs, path, device) {
    super(fs, path);
    this.fs = fs;
    this.device = device;
    this.position = 0;
  }
  get driver() {
    return this.device.driver;
  }
  get stats() {
    return { mode: (this.driver.isBuffered ? S_IFBLK : S_IFCHR) | 438 };
  }
  async stat() {
    return Promise.resolve(new Stats(this.stats));
  }
  statSync() {
    return new Stats(this.stats);
  }
  readSync(buffer, offset, length, position) {
    return this.driver.read(this, buffer, offset, length, position);
  }
  // eslint-disable-next-line @typescript-eslint/require-await
  async read(buffer, offset, length) {
    return { bytesRead: this.readSync(buffer, offset, length), buffer };
  }
  writeSync(buffer, offset = 0, length = buffer.length, position) {
    return this.driver.write(this, buffer, offset, length, position);
  }
  // eslint-disable-next-line @typescript-eslint/require-await
  async write(buffer, offset, length, position) {
    return this.writeSync(buffer, offset, length, position);
  }
  async truncate(length) {
    const { size } = await this.stat();
    const buffer = new Uint8Array(length > size ? length - size : 0);
    await this.write(buffer, 0, buffer.length, length > size ? size : length);
  }
  truncateSync(length) {
    const { size } = this.statSync();
    const buffer = new Uint8Array(length > size ? length - size : 0);
    this.writeSync(buffer, 0, buffer.length, length > size ? size : length);
  }
  closeSync() {
    var _a3, _b2;
    (_b2 = (_a3 = this.driver).close) === null || _b2 === void 0 ? void 0 : _b2.call(_a3, this);
  }
  close() {
    this.closeSync();
    return Promise.resolve();
  }
  syncSync() {
    var _a3, _b2;
    (_b2 = (_a3 = this.driver).sync) === null || _b2 === void 0 ? void 0 : _b2.call(_a3, this);
  }
  sync() {
    this.syncSync();
    return Promise.resolve();
  }
  chown() {
    throw ErrnoError.With("ENOTSUP", this.path, "chown");
  }
  chownSync() {
    throw ErrnoError.With("ENOTSUP", this.path, "chown");
  }
  chmod() {
    throw ErrnoError.With("ENOTSUP", this.path, "chmod");
  }
  chmodSync() {
    throw ErrnoError.With("ENOTSUP", this.path, "chmod");
  }
  utimes() {
    throw ErrnoError.With("ENOTSUP", this.path, "utimes");
  }
  utimesSync() {
    throw ErrnoError.With("ENOTSUP", this.path, "utimes");
  }
  _setType() {
    throw ErrnoError.With("ENOTSUP", this.path, "_setType");
  }
  _setTypeSync() {
    throw ErrnoError.With("ENOTSUP", this.path, "_setType");
  }
};
var DeviceFS = class extends StoreFS {
  /**
   * Creates a new device at `path` relative to the `DeviceFS` root.
   * @deprecated
   */
  createDevice(path, driver, options = {}) {
    var _a3;
    if (this.existsSync(path)) {
      throw ErrnoError.With("EEXIST", path, "mknod");
    }
    let ino = BigInt(1);
    while (this.store.has(ino))
      ino++;
    const dev = {
      driver,
      ino,
      data: {},
      minor: 0,
      major: 0,
      ...(_a3 = driver.init) === null || _a3 === void 0 ? void 0 : _a3.call(driver, ino, options)
    };
    this.devices.set(path, dev);
    return dev;
  }
  devicesWithDriver(driver, forceIdentity) {
    if (forceIdentity && typeof driver == "string") {
      throw new ErrnoError(Errno.EINVAL, "Can not fetch devices using only a driver name");
    }
    const devs = [];
    for (const device of this.devices.values()) {
      if (forceIdentity && device.driver != driver)
        continue;
      const name = typeof driver == "string" ? driver : driver.name;
      if (name == device.driver.name)
        devs.push(device);
    }
    return devs;
  }
  /**
   * @internal
   */
  _createDevice(driver, options = {}) {
    var _a3;
    let ino = BigInt(1);
    while (this.store.has(ino))
      ino++;
    const dev = {
      driver,
      ino,
      data: {},
      minor: 0,
      major: 0,
      ...(_a3 = driver.init) === null || _a3 === void 0 ? void 0 : _a3.call(driver, ino, options)
    };
    const path = "/" + (dev.name || driver.name) + (driver.singleton ? "" : this.devicesWithDriver(driver).length);
    if (this.existsSync(path)) {
      throw ErrnoError.With("EEXIST", path, "mknod");
    }
    this.devices.set(path, dev);
    return dev;
  }
  /**
   * Adds default devices
   */
  addDefaults() {
    this._createDevice(nullDevice);
    this._createDevice(zeroDevice);
    this._createDevice(fullDevice);
    this._createDevice(randomDevice);
    this._createDevice(consoleDevice);
  }
  constructor() {
    super(new InMemoryStore("devfs"));
    this.devices = /* @__PURE__ */ new Map();
  }
  async rename(oldPath, newPath) {
    if (this.devices.has(oldPath)) {
      throw ErrnoError.With("EPERM", oldPath, "rename");
    }
    if (this.devices.has(newPath)) {
      throw ErrnoError.With("EEXIST", newPath, "rename");
    }
    return super.rename(oldPath, newPath);
  }
  renameSync(oldPath, newPath) {
    if (this.devices.has(oldPath)) {
      throw ErrnoError.With("EPERM", oldPath, "rename");
    }
    if (this.devices.has(newPath)) {
      throw ErrnoError.With("EEXIST", newPath, "rename");
    }
    return super.renameSync(oldPath, newPath);
  }
  async stat(path) {
    if (this.devices.has(path)) {
      const env_1 = { stack: [], error: void 0, hasError: false };
      try {
        const file = __addDisposableResource4(env_1, await this.openFile(path, "r"), true);
        return file.stat();
      } catch (e_1) {
        env_1.error = e_1;
        env_1.hasError = true;
      } finally {
        const result_1 = __disposeResources4(env_1);
        if (result_1)
          await result_1;
      }
    }
    return super.stat(path);
  }
  statSync(path) {
    if (this.devices.has(path)) {
      const env_2 = { stack: [], error: void 0, hasError: false };
      try {
        const file = __addDisposableResource4(env_2, this.openFileSync(path, "r"), false);
        return file.statSync();
      } catch (e_2) {
        env_2.error = e_2;
        env_2.hasError = true;
      } finally {
        __disposeResources4(env_2);
      }
    }
    return super.statSync(path);
  }
  async openFile(path, flag) {
    if (this.devices.has(path)) {
      return new DeviceFile(this, path, this.devices.get(path));
    }
    return await super.openFile(path, flag);
  }
  openFileSync(path, flag) {
    if (this.devices.has(path)) {
      return new DeviceFile(this, path, this.devices.get(path));
    }
    return super.openFileSync(path, flag);
  }
  async createFile(path, flag, mode) {
    if (this.devices.has(path)) {
      throw ErrnoError.With("EEXIST", path, "createFile");
    }
    return super.createFile(path, flag, mode);
  }
  createFileSync(path, flag, mode) {
    if (this.devices.has(path)) {
      throw ErrnoError.With("EEXIST", path, "createFile");
    }
    return super.createFileSync(path, flag, mode);
  }
  async unlink(path) {
    if (this.devices.has(path)) {
      throw ErrnoError.With("EPERM", path, "unlink");
    }
    return super.unlink(path);
  }
  unlinkSync(path) {
    if (this.devices.has(path)) {
      throw ErrnoError.With("EPERM", path, "unlink");
    }
    return super.unlinkSync(path);
  }
  async rmdir(path) {
    return super.rmdir(path);
  }
  rmdirSync(path) {
    return super.rmdirSync(path);
  }
  async mkdir(path, mode) {
    if (this.devices.has(path)) {
      throw ErrnoError.With("EEXIST", path, "mkdir");
    }
    return super.mkdir(path, mode);
  }
  mkdirSync(path, mode) {
    if (this.devices.has(path)) {
      throw ErrnoError.With("EEXIST", path, "mkdir");
    }
    return super.mkdirSync(path, mode);
  }
  async readdir(path) {
    const entries = await super.readdir(path);
    for (const dev of this.devices.keys()) {
      if (dirname(dev) == path) {
        entries.push(basename(dev));
      }
    }
    return entries;
  }
  readdirSync(path) {
    const entries = super.readdirSync(path);
    for (const dev of this.devices.keys()) {
      if (dirname(dev) == path) {
        entries.push(basename(dev));
      }
    }
    return entries;
  }
  async link(target, link3) {
    if (this.devices.has(target)) {
      throw ErrnoError.With("EPERM", target, "rmdir");
    }
    if (this.devices.has(link3)) {
      throw ErrnoError.With("EEXIST", link3, "link");
    }
    return super.link(target, link3);
  }
  linkSync(target, link3) {
    if (this.devices.has(target)) {
      throw ErrnoError.With("EPERM", target, "rmdir");
    }
    if (this.devices.has(link3)) {
      throw ErrnoError.With("EEXIST", link3, "link");
    }
    return super.linkSync(target, link3);
  }
  async sync(path, data, stats2) {
    if (this.devices.has(path)) {
      throw new ErrnoError(Errno.EINVAL, "Attempted to sync a device incorrectly (bug)", path, "sync");
    }
    return super.sync(path, data, stats2);
  }
  syncSync(path, data, stats2) {
    if (this.devices.has(path)) {
      throw new ErrnoError(Errno.EINVAL, "Attempted to sync a device incorrectly (bug)", path, "sync");
    }
    return super.syncSync(path, data, stats2);
  }
};
function defaultWrite(file, buffer, offset, length) {
  file.position += length;
  return length;
}
var nullDevice = {
  name: "null",
  singleton: true,
  init() {
    return { major: 1, minor: 3 };
  },
  read() {
    return 0;
  },
  write: defaultWrite
};
var zeroDevice = {
  name: "zero",
  singleton: true,
  init() {
    return { major: 1, minor: 5 };
  },
  read(file, buffer, offset = 0, length = buffer.byteLength) {
    const data = new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);
    for (let i = offset; i < offset + length; i++) {
      data[i] = 0;
    }
    file.position += length;
    return length;
  },
  write: defaultWrite
};
var fullDevice = {
  name: "full",
  singleton: true,
  init() {
    return { major: 1, minor: 7 };
  },
  read(file, buffer, offset = 0, length = buffer.byteLength) {
    const data = new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);
    for (let i = offset; i < offset + length; i++) {
      data[i] = 0;
    }
    file.position += length;
    return length;
  },
  write(file) {
    throw ErrnoError.With("ENOSPC", file.path, "write");
  }
};
var randomDevice = {
  name: "random",
  singleton: true,
  init() {
    return { major: 1, minor: 8 };
  },
  read(file, buffer, offset = 0, length = buffer.byteLength) {
    const data = new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);
    for (let i = offset; i < offset + length; i++) {
      data[i] = Math.floor(Math.random() * 256);
    }
    file.position += length;
    return length;
  },
  write: defaultWrite
};
var consoleDevice = {
  name: "console",
  singleton: true,
  init(ino, { output = console.log } = {}) {
    return { major: 5, minor: 1, data: { output } };
  },
  read() {
    return 0;
  },
  write(file, buffer, offset, length) {
    const text = decodeUTF8(buffer.slice(offset, offset + length));
    file.device.data.output(text);
    file.position += length;
    return length;
  }
};
var devices = {
  null: nullDevice,
  zero: zeroDevice,
  full: fullDevice,
  random: randomDevice,
  console: consoleDevice
};

// node_modules/@zenfs/core/dist/vfs/cache.js
var Cache = class {
  constructor() {
    this.isEnabled = false;
    this.sync = /* @__PURE__ */ new Map();
    this.async = /* @__PURE__ */ new Map();
  }
  /**
   * Whether the data exists in the cache
   */
  has(path) {
    return this.isEnabled && this.sync.has(path);
  }
  /**
   * Gets data from the cache, if is exists and the cache is enabled.
   */
  get(path) {
    if (!this.isEnabled)
      return;
    return this.sync.get(path);
  }
  /**
   * Adds data if the cache is enabled
   */
  set(path, value) {
    if (!this.isEnabled)
      return;
    this.sync.set(path, value);
    this.async.set(path, Promise.resolve(value));
  }
  /**
   * Whether the data exists in the cache
   */
  hasAsync(path) {
    return this.isEnabled && this.async.has(path);
  }
  /**
   * Gets data from the cache, if it exists and the cache is enabled.
   */
  getAsync(path) {
    if (!this.isEnabled)
      return;
    return this.async.get(path);
  }
  /**
   * Adds data if the cache is enabled
   */
  setAsync(path, value) {
    if (!this.isEnabled)
      return;
    this.async.set(path, value);
    void value.then((v) => this.sync.set(path, v));
  }
  /**
   * Clears the cache if it is enabled
   */
  clear() {
    if (!this.isEnabled)
      return;
    this.sync.clear();
    this.async.clear();
  }
};
var stats = new Cache();
var paths = new Cache();

// node_modules/@zenfs/core/dist/vfs/index.js
var vfs_exports = {};
__export(vfs_exports, {
  BigIntStatsFs: () => BigIntStatsFs,
  Dir: () => Dir,
  Dirent: () => Dirent,
  ReadStream: () => ReadStream,
  Stats: () => Stats,
  StatsFs: () => StatsFs,
  WriteStream: () => WriteStream,
  access: () => access2,
  accessSync: () => accessSync,
  appendFile: () => appendFile2,
  appendFileSync: () => appendFileSync,
  chmod: () => chmod2,
  chmodSync: () => chmodSync,
  chown: () => chown2,
  chownSync: () => chownSync,
  chroot: () => chroot,
  close: () => close,
  closeSync: () => closeSync,
  constants: () => constants_exports,
  copyFile: () => copyFile2,
  copyFileSync: () => copyFileSync,
  cp: () => cp2,
  cpSync: () => cpSync,
  createReadStream: () => createReadStream,
  createWriteStream: () => createWriteStream,
  exists: () => exists2,
  existsSync: () => existsSync,
  fchmod: () => fchmod,
  fchmodSync: () => fchmodSync,
  fchown: () => fchown,
  fchownSync: () => fchownSync,
  fdatasync: () => fdatasync,
  fdatasyncSync: () => fdatasyncSync,
  fstat: () => fstat,
  fstatSync: () => fstatSync,
  fsync: () => fsync,
  fsyncSync: () => fsyncSync,
  ftruncate: () => ftruncate,
  ftruncateSync: () => ftruncateSync,
  futimes: () => futimes,
  futimesSync: () => futimesSync,
  glob: () => glob2,
  globSync: () => globSync,
  lchmod: () => lchmod2,
  lchmodSync: () => lchmodSync,
  lchown: () => lchown2,
  lchownSync: () => lchownSync,
  link: () => link2,
  linkSync: () => linkSync,
  lopenSync: () => lopenSync,
  lstat: () => lstat2,
  lstatSync: () => lstatSync,
  lutimes: () => lutimes2,
  lutimesSync: () => lutimesSync,
  mkdir: () => mkdir2,
  mkdirSync: () => mkdirSync,
  mkdtemp: () => mkdtemp2,
  mkdtempSync: () => mkdtempSync,
  mount: () => mount,
  mountObject: () => mountObject,
  mounts: () => mounts,
  open: () => open2,
  openAsBlob: () => openAsBlob,
  openSync: () => openSync,
  opendir: () => opendir2,
  opendirSync: () => opendirSync,
  promises: () => promises_exports,
  read: () => read,
  readFile: () => readFile2,
  readFileSync: () => readFileSync,
  readSync: () => readSync,
  readdir: () => readdir2,
  readdirSync: () => readdirSync,
  readlink: () => readlink2,
  readlinkSync: () => readlinkSync,
  readv: () => readv,
  readvSync: () => readvSync,
  realpath: () => realpath2,
  realpathSync: () => realpathSync,
  rename: () => rename2,
  renameSync: () => renameSync,
  rm: () => rm2,
  rmSync: () => rmSync,
  rmdir: () => rmdir2,
  rmdirSync: () => rmdirSync,
  stat: () => stat2,
  statSync: () => statSync,
  statfs: () => statfs2,
  statfsSync: () => statfsSync,
  symlink: () => symlink2,
  symlinkSync: () => symlinkSync,
  truncate: () => truncate2,
  truncateSync: () => truncateSync,
  umount: () => umount,
  unlink: () => unlink2,
  unlinkSync: () => unlinkSync,
  unwatchFile: () => unwatchFile,
  utimes: () => utimes2,
  utimesSync: () => utimesSync,
  watch: () => watch2,
  watchFile: () => watchFile,
  write: () => write,
  writeFile: () => writeFile2,
  writeFileSync: () => writeFileSync,
  writeSync: () => writeSync,
  writev: () => writev,
  writevSync: () => writevSync
});

// node_modules/@zenfs/core/dist/vfs/async.js
var import_buffer3 = __toESM(require_buffer(), 1);

// node_modules/@zenfs/core/dist/vfs/promises.js
var promises_exports = {};
__export(promises_exports, {
  FileHandle: () => FileHandle,
  access: () => access,
  appendFile: () => appendFile,
  chmod: () => chmod,
  chown: () => chown,
  constants: () => constants_exports,
  copyFile: () => copyFile,
  cp: () => cp,
  exists: () => exists,
  glob: () => glob,
  lchmod: () => lchmod,
  lchown: () => lchown,
  link: () => link,
  lstat: () => lstat,
  lutimes: () => lutimes,
  mkdir: () => mkdir,
  mkdtemp: () => mkdtemp,
  open: () => open,
  opendir: () => opendir,
  readFile: () => readFile,
  readdir: () => readdir,
  readlink: () => readlink,
  realpath: () => realpath,
  rename: () => rename,
  rm: () => rm,
  rmdir: () => rmdir,
  stat: () => stat,
  statfs: () => statfs,
  symlink: () => symlink,
  truncate: () => truncate,
  unlink: () => unlink,
  utimes: () => utimes,
  watch: () => watch,
  writeFile: () => writeFile
});
var import_buffer2 = __toESM(require_buffer(), 1);

// node_modules/@zenfs/core/dist/vfs/sync.js
var import_buffer = __toESM(require_buffer(), 1);

// node_modules/@zenfs/core/dist/context.js
function _bindFunctions(fns, thisValue) {
  return Object.fromEntries(Object.entries(fns).map(([k, v]) => [k, typeof v == "function" ? v.bind(thisValue) : v]));
}
function bindContext(root, credentials2 = structuredClone(credentials)) {
  const ctx = {
    root,
    credentials: createCredentials(credentials2)
  };
  const fn_fs = _bindFunctions(vfs_exports, ctx);
  const fn_promises = _bindFunctions(promises_exports, ctx);
  return { ...ctx, fs: { ...vfs_exports, ...fn_fs, promises: { ...promises_exports, ...fn_promises } } };
}

// node_modules/@zenfs/core/dist/vfs/shared.js
var fdMap = /* @__PURE__ */ new Map();
var nextFd = 100;
function file2fd(file) {
  const fd = nextFd++;
  fdMap.set(fd, file);
  return fd;
}
function fd2file(fd) {
  if (!fdMap.has(fd)) {
    throw new ErrnoError(Errno.EBADF);
  }
  return fdMap.get(fd);
}
var mounts = /* @__PURE__ */ new Map();
mount("/", InMemory.create({ name: "root" }));
function mount(mountPoint, fs) {
  if (mountPoint[0] !== "/") {
    mountPoint = "/" + mountPoint;
  }
  mountPoint = resolve(mountPoint);
  if (mounts.has(mountPoint)) {
    throw new ErrnoError(Errno.EINVAL, "Mount point " + mountPoint + " is already in use.");
  }
  mounts.set(mountPoint, fs);
  paths.clear();
}
function umount(mountPoint) {
  if (mountPoint[0] !== "/") {
    mountPoint = "/" + mountPoint;
  }
  mountPoint = resolve(mountPoint);
  if (!mounts.has(mountPoint)) {
    throw new ErrnoError(Errno.EINVAL, "Mount point " + mountPoint + " is already unmounted.");
  }
  mounts.delete(mountPoint);
  paths.clear();
}
function resolveMount(path, ctx) {
  const root = (ctx === null || ctx === void 0 ? void 0 : ctx.root) || "/";
  path = normalizePath(join(root, path));
  const sortedMounts = [...mounts].sort((a, b) => a[0].length > b[0].length ? -1 : 1);
  for (const [mountPoint, fs] of sortedMounts) {
    if (_isParentOf(mountPoint, path)) {
      path = path.slice(mountPoint.length > 1 ? mountPoint.length : 0);
      if (path === "") {
        path = root;
      }
      return { fs, path, mountPoint, root };
    }
  }
  throw new ErrnoError(Errno.EIO, "No file system");
}
function fixPaths(text, paths2) {
  for (const [from, to] of Object.entries(paths2)) {
    text = text === null || text === void 0 ? void 0 : text.replaceAll(from, to);
  }
  return text;
}
function fixError(e, paths2) {
  if (typeof e.stack == "string") {
    e.stack = fixPaths(e.stack, paths2);
  }
  try {
    e.message = fixPaths(e.message, paths2);
  } catch {
  }
  if (e.path)
    e.path = fixPaths(e.path, paths2);
  return e;
}
function mountObject(mounts2) {
  if ("/" in mounts2) {
    umount("/");
  }
  for (const [point, fs] of Object.entries(mounts2)) {
    mount(point, fs);
  }
}
function _statfs(fs, bigint) {
  const md = fs.metadata();
  const bs = md.blockSize || 4096;
  return {
    type: (bigint ? BigInt : Number)(md.type),
    bsize: (bigint ? BigInt : Number)(bs),
    ffree: (bigint ? BigInt : Number)(md.freeNodes || size_max),
    files: (bigint ? BigInt : Number)(md.totalNodes || size_max),
    bavail: (bigint ? BigInt : Number)(md.freeSpace / bs),
    bfree: (bigint ? BigInt : Number)(md.freeSpace / bs),
    blocks: (bigint ? BigInt : Number)(md.totalSpace / bs)
  };
}
function chroot(path, inPlace) {
  const creds = this === null || this === void 0 ? void 0 : this.credentials;
  if ((creds === null || creds === void 0 ? void 0 : creds.uid) && (creds === null || creds === void 0 ? void 0 : creds.gid) && (creds === null || creds === void 0 ? void 0 : creds.euid) && (creds === null || creds === void 0 ? void 0 : creds.egid)) {
    throw new ErrnoError(Errno.EPERM, "Can not chroot() as non-root user");
  }
  if (inPlace && this) {
    this.root += path;
    return this;
  }
  return bindContext(join((this === null || this === void 0 ? void 0 : this.root) || "/", path), creds);
}
function _isParentOf(parent, child) {
  if (parent === "/" || parent === child)
    return true;
  if (!parent.endsWith("/"))
    parent += "/";
  return child.startsWith(parent);
}

// node_modules/@zenfs/core/dist/vfs/watchers.js
var Watcher = class extends import_index.default {
  /* eslint-disable @typescript-eslint/no-explicit-any */
  off(event, fn, context, once) {
    return super.off(event, fn, context, once);
  }
  removeListener(event, fn, context, once) {
    return super.removeListener(event, fn, context, once);
  }
  /* eslint-enable @typescript-eslint/no-explicit-any */
  constructor(_context, path) {
    super();
    this._context = _context;
    this.path = path;
  }
  setMaxListeners() {
    throw ErrnoError.With("ENOSYS", this.path, "Watcher.setMaxListeners");
  }
  getMaxListeners() {
    throw ErrnoError.With("ENOSYS", this.path, "Watcher.getMaxListeners");
  }
  prependListener() {
    throw ErrnoError.With("ENOSYS", this.path, "Watcher.prependListener");
  }
  prependOnceListener() {
    throw ErrnoError.With("ENOSYS", this.path, "Watcher.prependOnceListener");
  }
  rawListeners() {
    throw ErrnoError.With("ENOSYS", this.path, "Watcher.rawListeners");
  }
  ref() {
    return this;
  }
  unref() {
    return this;
  }
};
var FSWatcher = class extends Watcher {
  constructor(context, path, options) {
    super(context, path);
    this.options = options;
    addWatcher(path.toString(), this);
  }
  close() {
    super.emit("close");
    removeWatcher(this.path.toString(), this);
  }
  [Symbol.dispose]() {
    this.close();
  }
};
var StatWatcher = class extends Watcher {
  constructor(context, path, options) {
    super(context, path);
    this.options = options;
    this.start();
  }
  onInterval() {
    try {
      const current = statSync(this.path);
      if (!isStatsEqual(this.previous, current)) {
        this.emit("change", current, this.previous);
        this.previous = current;
      }
    } catch (e) {
      this.emit("error", e);
    }
  }
  start() {
    const interval = this.options.interval || 5e3;
    try {
      this.previous = statSync(this.path);
    } catch (e) {
      this.emit("error", e);
      return;
    }
    this.intervalId = setInterval(this.onInterval.bind(this), interval);
    if (!this.options.persistent && typeof this.intervalId == "object") {
      this.intervalId.unref();
    }
  }
  /**
   * @internal
   */
  stop() {
    if (this.intervalId) {
      clearInterval(this.intervalId);
      this.intervalId = void 0;
    }
    this.removeAllListeners();
  }
};
var watchers = /* @__PURE__ */ new Map();
function addWatcher(path, watcher) {
  const normalizedPath = normalizePath(path);
  if (!watchers.has(normalizedPath)) {
    watchers.set(normalizedPath, /* @__PURE__ */ new Set());
  }
  watchers.get(normalizedPath).add(watcher);
}
function removeWatcher(path, watcher) {
  const normalizedPath = normalizePath(path);
  if (watchers.has(normalizedPath)) {
    watchers.get(normalizedPath).delete(watcher);
    if (watchers.get(normalizedPath).size === 0) {
      watchers.delete(normalizedPath);
    }
  }
}
function emitChange(eventType, filename) {
  var _a3;
  filename = normalizePath(filename);
  if (watchers.has(filename)) {
    for (const watcher of watchers.get(filename)) {
      watcher.emit("change", eventType, basename(filename));
    }
  }
  let parent = filename, normalizedFilename;
  while (parent !== normalizedFilename) {
    normalizedFilename = parent;
    parent = dirname(parent);
    if (!watchers.has(parent))
      continue;
    for (const watcher of watchers.get(parent)) {
      const root = (_a3 = watcher._context) === null || _a3 === void 0 ? void 0 : _a3.root;
      const contextPath = root && filename.startsWith(root) ? filename.slice(root.length) : filename;
      const relativePath = contextPath.slice(parent.length + (parent == "/" ? 0 : 1));
      watcher.emit("change", eventType, relativePath);
    }
  }
}

// node_modules/@zenfs/core/dist/vfs/sync.js
var __addDisposableResource5 = function(env, value, async) {
  if (value !== null && value !== void 0) {
    if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
    var dispose, inner;
    if (async) {
      if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
      dispose = value[Symbol.asyncDispose];
    }
    if (dispose === void 0) {
      if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
      dispose = value[Symbol.dispose];
      if (async) inner = dispose;
    }
    if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
    if (inner) dispose = function() {
      try {
        inner.call(this);
      } catch (e) {
        return Promise.reject(e);
      }
    };
    env.stack.push({ value, dispose, async });
  } else if (async) {
    env.stack.push({ async: true });
  }
  return value;
};
var __disposeResources5 = /* @__PURE__ */ function(SuppressedError2) {
  return function(env) {
    function fail(e) {
      env.error = env.hasError ? new SuppressedError2(e, env.error, "An error was suppressed during disposal.") : e;
      env.hasError = true;
    }
    var r, s = 0;
    function next() {
      while (r = env.stack.pop()) {
        try {
          if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);
          if (r.dispose) {
            var result = r.dispose.call(r.value);
            if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) {
              fail(e);
              return next();
            });
          } else s |= 1;
        } catch (e) {
          fail(e);
        }
      }
      if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
      if (env.hasError) throw env.error;
    }
    return next();
  };
}(typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
});
function renameSync(oldPath, newPath) {
  oldPath = normalizePath(oldPath);
  newPath = normalizePath(newPath);
  const oldMount = resolveMount(oldPath, this);
  const newMount = resolveMount(newPath, this);
  if (config.checkAccess && !statSync.call(this, dirname(oldPath)).hasAccess(W_OK, this)) {
    throw ErrnoError.With("EACCES", oldPath, "rename");
  }
  try {
    if (oldMount === newMount) {
      oldMount.fs.renameSync(oldMount.path, newMount.path);
      emitChange("rename", oldPath.toString());
      emitChange("change", newPath.toString());
      return;
    }
    writeFileSync.call(this, newPath, readFileSync(oldPath));
    unlinkSync.call(this, oldPath);
    emitChange("rename", oldPath.toString());
  } catch (e) {
    throw fixError(e, { [oldMount.path]: oldPath, [newMount.path]: newPath });
  }
}
function existsSync(path) {
  path = normalizePath(path);
  try {
    const { fs, path: resolvedPath } = resolveMount(realpathSync.call(this, path), this);
    return fs.existsSync(resolvedPath);
  } catch (e) {
    if (e.errno == Errno.ENOENT) {
      return false;
    }
    throw e;
  }
}
function statSync(path, options) {
  path = normalizePath(path);
  const { fs, path: resolved } = resolveMount(realpathSync.call(this, path), this);
  try {
    const stats2 = fs.statSync(resolved);
    if (config.checkAccess && !stats2.hasAccess(R_OK, this)) {
      throw ErrnoError.With("EACCES", resolved, "stat");
    }
    return (options === null || options === void 0 ? void 0 : options.bigint) ? new BigIntStats(stats2) : stats2;
  } catch (e) {
    throw fixError(e, { [resolved]: path });
  }
}
function lstatSync(path, options) {
  path = normalizePath(path);
  const { fs, path: resolved } = resolveMount(path, this);
  try {
    const stats2 = fs.statSync(resolved);
    return (options === null || options === void 0 ? void 0 : options.bigint) ? new BigIntStats(stats2) : stats2;
  } catch (e) {
    throw fixError(e, { [resolved]: path });
  }
}
function truncateSync(path, len = 0) {
  const env_1 = { stack: [], error: void 0, hasError: false };
  try {
    const file = __addDisposableResource5(env_1, _openSync.call(this, path, "r+"), false);
    len || (len = 0);
    if (len < 0) {
      throw new ErrnoError(Errno.EINVAL);
    }
    file.truncateSync(len);
  } catch (e_1) {
    env_1.error = e_1;
    env_1.hasError = true;
  } finally {
    __disposeResources5(env_1);
  }
}
function unlinkSync(path) {
  path = normalizePath(path);
  const { fs, path: resolved } = resolveMount(path, this);
  try {
    if (config.checkAccess && !(stats.get(path) || fs.statSync(resolved)).hasAccess(W_OK, this)) {
      throw ErrnoError.With("EACCES", resolved, "unlink");
    }
    fs.unlinkSync(resolved);
    emitChange("rename", path.toString());
  } catch (e) {
    throw fixError(e, { [resolved]: path });
  }
}
function applySetId(file, uid, gid) {
  var _a3;
  if ((_a3 = file.fs.metadata().features) === null || _a3 === void 0 ? void 0 : _a3.includes("setid"))
    return;
  const parent = file.fs.statSync(dirname(file.path));
  file.chownSync(
    parent.mode & S_ISUID ? parent.uid : uid,
    // manually apply setuid/setgid
    parent.mode & S_ISGID ? parent.gid : gid
  );
}
function _openSync(path, _flag, _mode, resolveSymlinks = true) {
  var _a3;
  path = normalizePath(path);
  const mode = normalizeMode(_mode, 420), flag = parseFlag(_flag);
  path = resolveSymlinks ? realpathSync.call(this, path) : path;
  const { fs, path: resolved } = resolveMount(path, this);
  let stats2;
  try {
    stats2 = fs.statSync(resolved);
  } catch {
  }
  if (!stats2) {
    if (!isWriteable(flag) && !isAppendable(flag) || flag == "r+") {
      throw ErrnoError.With("ENOENT", path, "_open");
    }
    const parentStats = fs.statSync(dirname(resolved));
    if (config.checkAccess && !parentStats.hasAccess(W_OK, this)) {
      throw ErrnoError.With("EACCES", dirname(path), "_open");
    }
    if (!parentStats.isDirectory()) {
      throw ErrnoError.With("ENOTDIR", dirname(path), "_open");
    }
    const { euid: uid, egid: gid } = (_a3 = this === null || this === void 0 ? void 0 : this.credentials) !== null && _a3 !== void 0 ? _a3 : credentials;
    const file2 = fs.createFileSync(resolved, flag, mode, { uid, gid });
    applySetId(file2, uid, gid);
    return file2;
  }
  if (config.checkAccess && (!stats2.hasAccess(mode, this) || !stats2.hasAccess(flagToMode(flag), this))) {
    throw ErrnoError.With("EACCES", path, "_open");
  }
  if (isExclusive(flag)) {
    throw ErrnoError.With("EEXIST", path, "_open");
  }
  const file = fs.openFileSync(resolved, flag);
  if (isTruncating(flag)) {
    file.truncateSync(0);
  }
  return file;
}
function openSync(path, flag, mode = F_OK) {
  return file2fd(_openSync.call(this, path, flag, mode, true));
}
function lopenSync(path, flag, mode) {
  return file2fd(_openSync.call(this, path, flag, mode, false));
}
function _readFileSync(fname, flag, resolveSymlinks) {
  const env_2 = { stack: [], error: void 0, hasError: false };
  try {
    const file = __addDisposableResource5(env_2, _openSync.call(this, fname, flag, 420, resolveSymlinks), false);
    const stat3 = file.statSync();
    const data = new Uint8Array(stat3.size);
    file.readSync(data, 0, stat3.size, 0);
    return data;
  } catch (e_2) {
    env_2.error = e_2;
    env_2.hasError = true;
  } finally {
    __disposeResources5(env_2);
  }
}
function readFileSync(path, _options = {}) {
  const options = normalizeOptions(_options, null, "r", 420);
  const flag = parseFlag(options.flag);
  if (!isReadable(flag)) {
    throw new ErrnoError(Errno.EINVAL, "Flag passed to readFile must allow for reading.");
  }
  const data = import_buffer.Buffer.from(_readFileSync.call(this, typeof path == "number" ? fd2file(path).path : path.toString(), options.flag, true));
  return options.encoding ? data.toString(options.encoding) : data;
}
function writeFileSync(path, data, _options = {}) {
  const env_3 = { stack: [], error: void 0, hasError: false };
  try {
    const options = normalizeOptions(_options, "utf8", "w+", 420);
    const flag = parseFlag(options.flag);
    if (!isWriteable(flag)) {
      throw new ErrnoError(Errno.EINVAL, "Flag passed to writeFile must allow for writing.");
    }
    if (typeof data != "string" && !options.encoding) {
      throw new ErrnoError(Errno.EINVAL, "Encoding not specified");
    }
    const encodedData = typeof data == "string" ? import_buffer.Buffer.from(data, options.encoding) : new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
    if (!encodedData) {
      throw new ErrnoError(Errno.EINVAL, "Data not specified");
    }
    const file = __addDisposableResource5(env_3, _openSync.call(this, typeof path == "number" ? fd2file(path).path : path.toString(), flag, options.mode, true), false);
    file.writeSync(encodedData, 0, encodedData.byteLength, 0);
    emitChange("change", path.toString());
  } catch (e_3) {
    env_3.error = e_3;
    env_3.hasError = true;
  } finally {
    __disposeResources5(env_3);
  }
}
function appendFileSync(filename, data, _options = {}) {
  const env_4 = { stack: [], error: void 0, hasError: false };
  try {
    const options = normalizeOptions(_options, "utf8", "a+", 420);
    const flag = parseFlag(options.flag);
    if (!isAppendable(flag)) {
      throw new ErrnoError(Errno.EINVAL, "Flag passed to appendFile must allow for appending.");
    }
    if (typeof data != "string" && !options.encoding) {
      throw new ErrnoError(Errno.EINVAL, "Encoding not specified");
    }
    const encodedData = typeof data == "string" ? import_buffer.Buffer.from(data, options.encoding) : new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
    const file = __addDisposableResource5(env_4, _openSync.call(this, typeof filename == "number" ? fd2file(filename).path : filename.toString(), flag, options.mode, true), false);
    file.writeSync(encodedData, 0, encodedData.byteLength);
  } catch (e_4) {
    env_4.error = e_4;
    env_4.hasError = true;
  } finally {
    __disposeResources5(env_4);
  }
}
function fstatSync(fd, options) {
  const stats2 = fd2file(fd).statSync();
  return (options === null || options === void 0 ? void 0 : options.bigint) ? new BigIntStats(stats2) : stats2;
}
function closeSync(fd) {
  fd2file(fd).closeSync();
  fdMap.delete(fd);
}
function ftruncateSync(fd, len = 0) {
  len || (len = 0);
  if (len < 0) {
    throw new ErrnoError(Errno.EINVAL);
  }
  fd2file(fd).truncateSync(len);
}
function fsyncSync(fd) {
  fd2file(fd).syncSync();
}
function fdatasyncSync(fd) {
  fd2file(fd).datasyncSync();
}
function writeSync(fd, data, posOrOff, lenOrEnc, pos) {
  let buffer, offset, length, position;
  if (typeof data === "string") {
    position = typeof posOrOff === "number" ? posOrOff : null;
    const encoding = typeof lenOrEnc === "string" ? lenOrEnc : "utf8";
    offset = 0;
    buffer = import_buffer.Buffer.from(data, encoding);
    length = buffer.byteLength;
  } else {
    buffer = new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
    offset = posOrOff;
    length = lenOrEnc;
    position = typeof pos === "number" ? pos : null;
  }
  const file = fd2file(fd);
  position !== null && position !== void 0 ? position : position = file.position;
  const bytesWritten = file.writeSync(buffer, offset, length, position);
  emitChange("change", file.path);
  return bytesWritten;
}
function readSync(fd, buffer, options, length, position) {
  const file = fd2file(fd);
  const offset = typeof options == "object" ? options.offset : options;
  if (typeof options == "object") {
    length = options.length;
    position = options.position;
  }
  position = Number(position);
  if (isNaN(position)) {
    position = file.position;
  }
  return file.readSync(buffer, offset, length, position);
}
function fchownSync(fd, uid, gid) {
  fd2file(fd).chownSync(uid, gid);
}
function fchmodSync(fd, mode) {
  const numMode = normalizeMode(mode, -1);
  if (numMode < 0) {
    throw new ErrnoError(Errno.EINVAL, `Invalid mode.`);
  }
  fd2file(fd).chmodSync(numMode);
}
function futimesSync(fd, atime, mtime) {
  fd2file(fd).utimesSync(normalizeTime(atime), normalizeTime(mtime));
}
function rmdirSync(path) {
  path = normalizePath(path);
  const { fs, path: resolved } = resolveMount(realpathSync.call(this, path), this);
  try {
    const stats2 = stats.get(path) || fs.statSync(resolved);
    if (!stats2.isDirectory()) {
      throw ErrnoError.With("ENOTDIR", resolved, "rmdir");
    }
    if (config.checkAccess && !stats2.hasAccess(W_OK, this)) {
      throw ErrnoError.With("EACCES", resolved, "rmdir");
    }
    fs.rmdirSync(resolved);
    emitChange("rename", path.toString());
  } catch (e) {
    throw fixError(e, { [resolved]: path });
  }
}
function mkdirSync(path, options) {
  var _a3, _b2;
  const { euid: uid, egid: gid } = (_a3 = this === null || this === void 0 ? void 0 : this.credentials) !== null && _a3 !== void 0 ? _a3 : credentials;
  options = typeof options === "object" ? options : { mode: options };
  const mode = normalizeMode(options === null || options === void 0 ? void 0 : options.mode, 511);
  path = realpathSync.call(this, path);
  const { fs, path: resolved, root } = resolveMount(path, this);
  const errorPaths = { [resolved]: path };
  try {
    if (!(options === null || options === void 0 ? void 0 : options.recursive)) {
      if (config.checkAccess && !fs.statSync(dirname(resolved)).hasAccess(W_OK, this)) {
        throw ErrnoError.With("EACCES", dirname(resolved), "mkdir");
      }
      fs.mkdirSync(resolved, mode, { uid, gid });
      applySetId(fs.openFileSync(resolved, "r+"), uid, gid);
      return;
    }
    const dirs = [];
    for (let dir = resolved, original = path; !fs.existsSync(dir); dir = dirname(dir), original = dirname(original)) {
      dirs.unshift(dir);
      errorPaths[dir] = original;
    }
    for (const dir of dirs) {
      if (config.checkAccess && !fs.statSync(dirname(dir)).hasAccess(W_OK, this)) {
        throw ErrnoError.With("EACCES", dirname(dir), "mkdir");
      }
      fs.mkdirSync(dir, mode, { uid, gid });
      applySetId(fs.openFileSync(dir, "r+"), uid, gid);
      emitChange("rename", dir);
    }
    return root.length == 1 ? dirs[0] : (_b2 = dirs[0]) === null || _b2 === void 0 ? void 0 : _b2.slice(root.length);
  } catch (e) {
    throw fixError(e, errorPaths);
  }
}
function readdirSync(path, options) {
  options = typeof options === "object" ? options : { encoding: options };
  path = normalizePath(path);
  const { fs, path: resolved } = resolveMount(realpathSync.call(this, path), this);
  let entries;
  try {
    const stats2 = stats.get(path) || fs.statSync(resolved);
    stats.set(path, stats2);
    if (config.checkAccess && !stats2.hasAccess(R_OK, this)) {
      throw ErrnoError.With("EACCES", resolved, "readdir");
    }
    if (!stats2.isDirectory()) {
      throw ErrnoError.With("ENOTDIR", resolved, "readdir");
    }
    entries = fs.readdirSync(resolved);
  } catch (e) {
    throw fixError(e, { [resolved]: path });
  }
  const values = [];
  for (const entry of entries) {
    const entryStat = stats.get(join(path, entry)) || fs.statSync(join(resolved, entry));
    stats.set(join(path, entry), entryStat);
    if (options === null || options === void 0 ? void 0 : options.withFileTypes) {
      values.push(new Dirent(entry, entryStat));
    } else if ((options === null || options === void 0 ? void 0 : options.encoding) == "buffer") {
      values.push(import_buffer.Buffer.from(entry));
    } else {
      values.push(entry);
    }
    if (!entryStat.isDirectory() || !(options === null || options === void 0 ? void 0 : options.recursive))
      continue;
    for (const subEntry of readdirSync.call(this, join(path, entry), { ...options, _isIndirect: true })) {
      if (subEntry instanceof Dirent) {
        subEntry.path = join(entry, subEntry.path);
        values.push(subEntry);
      } else if (import_buffer.Buffer.isBuffer(subEntry)) {
        values.push(import_buffer.Buffer.from(join(entry, decodeUTF8(subEntry))));
      } else {
        values.push(join(entry, subEntry));
      }
    }
  }
  if (!(options === null || options === void 0 ? void 0 : options._isIndirect)) {
    stats.clear();
  }
  return values;
}
function linkSync(targetPath, linkPath) {
  targetPath = normalizePath(targetPath);
  if (config.checkAccess && !statSync(dirname(targetPath)).hasAccess(R_OK, this)) {
    throw ErrnoError.With("EACCES", dirname(targetPath), "link");
  }
  linkPath = normalizePath(linkPath);
  if (config.checkAccess && !statSync(dirname(linkPath)).hasAccess(W_OK, this)) {
    throw ErrnoError.With("EACCES", dirname(linkPath), "link");
  }
  const { fs, path } = resolveMount(targetPath, this);
  const link3 = resolveMount(linkPath, this);
  if (fs != link3.fs) {
    throw ErrnoError.With("EXDEV", linkPath, "link");
  }
  try {
    if (config.checkAccess && !fs.statSync(path).hasAccess(R_OK, this)) {
      throw ErrnoError.With("EACCES", path, "link");
    }
    return fs.linkSync(path, link3.path);
  } catch (e) {
    throw fixError(e, { [path]: targetPath, [link3.path]: linkPath });
  }
}
function symlinkSync(target, path, type = "file") {
  if (!["file", "dir", "junction"].includes(type)) {
    throw new ErrnoError(Errno.EINVAL, "Invalid type: " + type);
  }
  if (existsSync.call(this, path)) {
    throw ErrnoError.With("EEXIST", path.toString(), "symlink");
  }
  writeFileSync.call(this, path, target.toString());
  const file = _openSync.call(this, path, "r+", 420, false);
  file.chmodSync(S_IFLNK);
}
function readlinkSync(path, options) {
  const value = import_buffer.Buffer.from(_readFileSync.call(this, path.toString(), "r", false));
  const encoding = typeof options == "object" ? options === null || options === void 0 ? void 0 : options.encoding : options;
  if (encoding == "buffer") {
    return value;
  }
  return value.toString(encoding !== null && encoding !== void 0 ? encoding : "utf-8");
}
function chownSync(path, uid, gid) {
  const fd = openSync.call(this, path, "r+");
  fchownSync(fd, uid, gid);
  closeSync(fd);
}
function lchownSync(path, uid, gid) {
  const fd = lopenSync.call(this, path, "r+");
  fchownSync(fd, uid, gid);
  closeSync(fd);
}
function chmodSync(path, mode) {
  const fd = openSync.call(this, path, "r+");
  fchmodSync(fd, mode);
  closeSync(fd);
}
function lchmodSync(path, mode) {
  const fd = lopenSync.call(this, path, "r+");
  fchmodSync(fd, mode);
  closeSync(fd);
}
function utimesSync(path, atime, mtime) {
  const fd = openSync.call(this, path, "r+");
  futimesSync(fd, atime, mtime);
  closeSync(fd);
}
function lutimesSync(path, atime, mtime) {
  const fd = lopenSync.call(this, path, "r+");
  futimesSync(fd, atime, mtime);
  closeSync(fd);
}
function realpathSync(path, options) {
  path = normalizePath(path);
  const ctx_path = ((this === null || this === void 0 ? void 0 : this.root) || "") + path;
  if (paths.has(ctx_path))
    return paths.get(ctx_path);
  const { base, dir } = parse2(path);
  const realDir = dir == "/" ? "/" : paths.get(((this === null || this === void 0 ? void 0 : this.root) || "") + dir) || realpathSync.call(this, dir);
  const lpath = join(realDir, base);
  const { fs, path: resolvedPath } = resolveMount(lpath, this);
  try {
    const stats2 = stats.get(lpath) || fs.statSync(resolvedPath);
    stats.set(lpath, stats2);
    if (!stats2.isSymbolicLink()) {
      paths.set(path, lpath);
      return lpath;
    }
    const target = resolve(realDir, readlinkSync.call(this, lpath, options).toString());
    const real = paths.get(((this === null || this === void 0 ? void 0 : this.root) || "") + target) || realpathSync.call(this, target);
    paths.set(ctx_path, real);
    return real;
  } catch (e) {
    if (e.code == "ENOENT") {
      return path;
    }
    throw fixError(e, { [resolvedPath]: lpath });
  }
}
function accessSync(path, mode = 384) {
  if (!config.checkAccess)
    return;
  if (!statSync.call(this, path).hasAccess(mode, this)) {
    throw new ErrnoError(Errno.EACCES);
  }
}
function rmSync(path, options) {
  path = normalizePath(path);
  let stats2;
  try {
    stats2 = stats.get(path) || lstatSync.bind(this)(path);
  } catch (error) {
    if (error.code != "ENOENT" || !(options === null || options === void 0 ? void 0 : options.force))
      throw error;
  }
  if (!stats2) {
    return;
  }
  stats.set(path, stats2);
  switch (stats2.mode & S_IFMT) {
    case S_IFDIR:
      if (options === null || options === void 0 ? void 0 : options.recursive) {
        for (const entry of readdirSync.call(this, path, { _isIndirect: true })) {
          rmSync.call(this, join(path, entry), { ...options, _isIndirect: true });
        }
      }
      rmdirSync.call(this, path);
      break;
    case S_IFREG:
    case S_IFLNK:
    case S_IFBLK:
    case S_IFCHR:
      unlinkSync.call(this, path);
      break;
    case S_IFIFO:
    case S_IFSOCK:
    default:
      stats.clear();
      throw new ErrnoError(Errno.EPERM, "File type not supported", path, "rm");
  }
  if (!(options === null || options === void 0 ? void 0 : options._isIndirect)) {
    stats.clear();
  }
}
function mkdtempSync(prefix, options) {
  const encoding = typeof options === "object" ? options === null || options === void 0 ? void 0 : options.encoding : options || "utf8";
  const fsName = `${prefix}${Date.now()}-${Math.random().toString(36).slice(2)}`;
  const resolvedPath = "/tmp/" + fsName;
  mkdirSync.call(this, resolvedPath);
  return encoding == "buffer" ? import_buffer.Buffer.from(resolvedPath) : resolvedPath;
}
function copyFileSync(source, destination, flags) {
  source = normalizePath(source);
  destination = normalizePath(destination);
  if (flags && flags & COPYFILE_EXCL && existsSync(destination)) {
    throw new ErrnoError(Errno.EEXIST, "Destination file already exists.", destination, "copyFile");
  }
  writeFileSync.call(this, destination, readFileSync(source));
  emitChange("rename", destination.toString());
}
function readvSync(fd, buffers, position) {
  const file = fd2file(fd);
  let bytesRead = 0;
  for (const buffer of buffers) {
    bytesRead += file.readSync(buffer, 0, buffer.byteLength, position + bytesRead);
  }
  return bytesRead;
}
function writevSync(fd, buffers, position) {
  const file = fd2file(fd);
  let bytesWritten = 0;
  for (const buffer of buffers) {
    bytesWritten += file.writeSync(new Uint8Array(buffer.buffer), 0, buffer.byteLength, position + bytesWritten);
  }
  return bytesWritten;
}
function opendirSync(path, options) {
  path = normalizePath(path);
  return new Dir(path, this);
}
function cpSync(source, destination, opts) {
  source = normalizePath(source);
  destination = normalizePath(destination);
  const srcStats = lstatSync.call(this, source);
  if ((opts === null || opts === void 0 ? void 0 : opts.errorOnExist) && existsSync.call(this, destination)) {
    throw new ErrnoError(Errno.EEXIST, "Destination file or directory already exists.", destination, "cp");
  }
  switch (srcStats.mode & S_IFMT) {
    case S_IFDIR:
      if (!(opts === null || opts === void 0 ? void 0 : opts.recursive)) {
        throw new ErrnoError(Errno.EISDIR, source + " is a directory (not copied)", source, "cp");
      }
      mkdirSync.call(this, destination, { recursive: true });
      for (const dirent of readdirSync.call(this, source, { withFileTypes: true })) {
        if (opts.filter && !opts.filter(join(source, dirent.name), join(destination, dirent.name))) {
          continue;
        }
        cpSync.call(this, join(source, dirent.name), join(destination, dirent.name), opts);
      }
      break;
    case S_IFREG:
    case S_IFLNK:
      copyFileSync.call(this, source, destination);
      break;
    case S_IFBLK:
    case S_IFCHR:
    case S_IFIFO:
    case S_IFSOCK:
    default:
      throw new ErrnoError(Errno.EPERM, "File type not supported", source, "rm");
  }
  if (opts === null || opts === void 0 ? void 0 : opts.preserveTimestamps) {
    utimesSync.call(this, destination, srcStats.atime, srcStats.mtime);
  }
}
function statfsSync(path, options) {
  path = normalizePath(path);
  const { fs } = resolveMount(path, this);
  return _statfs(fs, options === null || options === void 0 ? void 0 : options.bigint);
}
function globSync(pattern, options = {}) {
  pattern = Array.isArray(pattern) ? pattern : [pattern];
  const { cwd: cwd2 = "/", withFileTypes = false, exclude = () => false } = options;
  const regexPatterns = pattern.map((p) => {
    p = p.replace(/([.?+^$(){}|[\]/])/g, "\\$1").replace(/\*\*/g, ".*").replace(/\*/g, "[^/]*").replace(/\?/g, ".");
    return new RegExp(`^${p}$`);
  });
  const results = [];
  function recursiveList(dir) {
    const entries = readdirSync(dir, { withFileTypes, encoding: "utf8" });
    for (const entry of entries) {
      const fullPath = withFileTypes ? entry.path : dir + "/" + entry;
      if (exclude(withFileTypes ? entry : fullPath))
        continue;
      if (statSync(fullPath).isDirectory() && regexPatterns.some((pattern2) => pattern2.source.includes(".*"))) {
        recursiveList(fullPath);
      }
      if (regexPatterns.some((pattern2) => pattern2.test(fullPath.replace(/^\/+/g, "")))) {
        results.push(withFileTypes ? entry.path : fullPath.replace(/^\/+/g, ""));
      }
    }
  }
  recursiveList(cwd2);
  return results;
}

// node_modules/@zenfs/core/dist/vfs/dir.js
var Dirent = class {
  get name() {
    return basename(this.path);
  }
  constructor(path, stats2) {
    this.path = path;
    this.stats = stats2;
  }
  get parentPath() {
    return this.path;
  }
  isFile() {
    return this.stats.isFile();
  }
  isDirectory() {
    return this.stats.isDirectory();
  }
  isBlockDevice() {
    return this.stats.isBlockDevice();
  }
  isCharacterDevice() {
    return this.stats.isCharacterDevice();
  }
  isSymbolicLink() {
    return this.stats.isSymbolicLink();
  }
  isFIFO() {
    return this.stats.isFIFO();
  }
  isSocket() {
    return this.stats.isSocket();
  }
};
var Dir = class {
  checkClosed() {
    if (this.closed) {
      throw new ErrnoError(Errno.EBADF, "Can not use closed Dir");
    }
  }
  constructor(path, context) {
    this.path = path;
    this.context = context;
    this.closed = false;
  }
  close(cb) {
    this.closed = true;
    if (!cb) {
      return Promise.resolve();
    }
    cb();
  }
  /**
   * Synchronously close the directory's underlying resource handle.
   * Subsequent reads will result in errors.
   */
  closeSync() {
    this.closed = true;
  }
  async _read() {
    var _a3, _b2;
    this.checkClosed();
    (_a3 = this._entries) !== null && _a3 !== void 0 ? _a3 : this._entries = await readdir.call(this.context, this.path, { withFileTypes: true });
    if (!this._entries.length)
      return null;
    return (_b2 = this._entries.shift()) !== null && _b2 !== void 0 ? _b2 : null;
  }
  read(cb) {
    if (!cb) {
      return this._read();
    }
    void this._read().then((value) => cb(void 0, value));
  }
  /**
   * Synchronously read the next directory entry via `readdir(3)` as a `Dirent`.
   * If there are no more directory entries to read, null will be returned.
   * Directory entries returned by this function are in no particular order as provided by the operating system's underlying directory mechanisms.
   */
  readSync() {
    var _a3, _b2;
    this.checkClosed();
    (_a3 = this._entries) !== null && _a3 !== void 0 ? _a3 : this._entries = readdirSync.call(this.context, this.path, { withFileTypes: true });
    if (!this._entries.length)
      return null;
    return (_b2 = this._entries.shift()) !== null && _b2 !== void 0 ? _b2 : null;
  }
  async next() {
    const value = await this._read();
    if (value) {
      return { done: false, value };
    }
    await this.close();
    return { done: true, value: void 0 };
  }
  /**
   * Asynchronously iterates over the directory via `readdir(3)` until all entries have been read.
   */
  [Symbol.asyncIterator]() {
    return this;
  }
  [Symbol.asyncDispose]() {
    return Promise.resolve();
  }
};

// node_modules/@zenfs/core/dist/vfs/streams.js
var import_readable_stream = __toESM(require_browser3(), 1);
var ReadStream = class extends import_readable_stream.Readable {
  close(callback = () => null) {
    try {
      super.destroy();
      super.emit("close");
      callback(null);
    } catch (err) {
      callback(new ErrnoError(Errno.EIO, err.toString()));
    }
  }
  wrap(oldStream) {
    super.wrap(oldStream);
    return this;
  }
};
var WriteStream = class extends import_readable_stream.Writable {
  close(callback = () => null) {
    try {
      super.destroy();
      super.emit("close");
      callback(null);
    } catch (err) {
      callback(new ErrnoError(Errno.EIO, err.toString()));
    }
  }
};

// node_modules/@zenfs/core/dist/vfs/promises.js
var __addDisposableResource6 = function(env, value, async) {
  if (value !== null && value !== void 0) {
    if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
    var dispose, inner;
    if (async) {
      if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
      dispose = value[Symbol.asyncDispose];
    }
    if (dispose === void 0) {
      if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
      dispose = value[Symbol.dispose];
      if (async) inner = dispose;
    }
    if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
    if (inner) dispose = function() {
      try {
        inner.call(this);
      } catch (e) {
        return Promise.reject(e);
      }
    };
    env.stack.push({ value, dispose, async });
  } else if (async) {
    env.stack.push({ async: true });
  }
  return value;
};
var __disposeResources6 = /* @__PURE__ */ function(SuppressedError2) {
  return function(env) {
    function fail(e) {
      env.error = env.hasError ? new SuppressedError2(e, env.error, "An error was suppressed during disposal.") : e;
      env.hasError = true;
    }
    var r, s = 0;
    function next() {
      while (r = env.stack.pop()) {
        try {
          if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);
          if (r.dispose) {
            var result = r.dispose.call(r.value);
            if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) {
              fail(e);
              return next();
            });
          } else s |= 1;
        } catch (e) {
          fail(e);
        }
      }
      if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
      if (env.hasError) throw env.error;
    }
    return next();
  };
}(typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
});
var FileHandle = class {
  constructor(fdOrFile, context) {
    this.context = context;
    const isFile = typeof fdOrFile != "number";
    this.fd = isFile ? file2fd(fdOrFile) : fdOrFile;
    this.file = isFile ? fdOrFile : fd2file(fdOrFile);
  }
  /**
   * Asynchronous fchown(2) - Change ownership of a file.
   */
  async chown(uid, gid) {
    await this.file.chown(uid, gid);
    emitChange("change", this.file.path);
  }
  /**
   * Asynchronous fchmod(2) - Change permissions of a file.
   * @param mode A file mode. If a string is passed, it is parsed as an octal integer.
   */
  async chmod(mode) {
    const numMode = normalizeMode(mode, -1);
    if (numMode < 0) {
      throw new ErrnoError(Errno.EINVAL, "Invalid mode.");
    }
    await this.file.chmod(numMode);
    emitChange("change", this.file.path);
  }
  /**
   * Asynchronous fdatasync(2) - synchronize a file's in-core state with storage device.
   */
  datasync() {
    return this.file.datasync();
  }
  /**
   * Asynchronous fsync(2) - synchronize a file's in-core state with the underlying storage device.
   */
  sync() {
    return this.file.sync();
  }
  /**
   * Asynchronous ftruncate(2) - Truncate a file to a specified length.
   * @param length If not specified, defaults to `0`.
   */
  async truncate(length) {
    length || (length = 0);
    if (length < 0) {
      throw new ErrnoError(Errno.EINVAL);
    }
    await this.file.truncate(length);
    emitChange("change", this.file.path);
  }
  /**
   * Asynchronously change file timestamps of the file.
   * @param atime The last access time. If a string is provided, it will be coerced to number.
   * @param mtime The last modified time. If a string is provided, it will be coerced to number.
   */
  async utimes(atime, mtime) {
    await this.file.utimes(normalizeTime(atime), normalizeTime(mtime));
    emitChange("change", this.file.path);
  }
  /**
   * Asynchronously append data to a file, creating the file if it does not exist. The underlying file will _not_ be closed automatically.
   * The `FileHandle` must have been opened for appending.
   * @param data The data to write. If something other than a `Buffer` or `Uint8Array` is provided, the value is coerced to a string.
   * @param _options Either the encoding for the file, or an object optionally specifying the encoding, file mode, and flag.
   * - `encoding` defaults to `'utf8'`.
   * - `mode` defaults to `0o666`.
   * - `flag` defaults to `'a'`.
   */
  async appendFile(data, _options = {}) {
    const options = normalizeOptions(_options, "utf8", "a", 420);
    const flag = parseFlag(options.flag);
    if (!isAppendable(flag)) {
      throw new ErrnoError(Errno.EINVAL, "Flag passed to appendFile must allow for appending.");
    }
    if (typeof data != "string" && !options.encoding) {
      throw new ErrnoError(Errno.EINVAL, "Encoding not specified");
    }
    const encodedData = typeof data == "string" ? import_buffer2.Buffer.from(data, options.encoding) : data;
    await this.file.write(encodedData, 0, encodedData.length);
    emitChange("change", this.file.path);
  }
  async read(buffer, offset, length, position) {
    if (typeof offset == "object" && offset != null) {
      position = offset.position;
      length = offset.length;
      offset = offset.offset;
    }
    if (!ArrayBuffer.isView(buffer) && typeof buffer == "object") {
      position = buffer.position;
      length = buffer.length;
      offset = buffer.offset;
      buffer = buffer.buffer;
    }
    if (isNaN(+position)) {
      position = this.file.position;
    }
    buffer || (buffer = new Uint8Array((await this.file.stat()).size));
    return this.file.read(buffer, offset !== null && offset !== void 0 ? offset : void 0, length !== null && length !== void 0 ? length : void 0, position !== null && position !== void 0 ? position : void 0);
  }
  async readFile(_options) {
    const options = normalizeOptions(_options, null, "r", 292);
    const flag = parseFlag(options.flag);
    if (!isReadable(flag)) {
      throw new ErrnoError(Errno.EINVAL, "Flag passed must allow for reading.");
    }
    const { size } = await this.stat();
    const { buffer: data } = await this.file.read(new Uint8Array(size), 0, size, 0);
    const buffer = import_buffer2.Buffer.from(data);
    return options.encoding ? buffer.toString(options.encoding) : buffer;
  }
  /**
   * Returns a `ReadableStream` that may be used to read the files data.
   *
   * An error will be thrown if this method is called more than once or is called after the `FileHandle` is closed or closing.
   *
   * While the `ReadableStream` will read the file to completion,
   * it will not close the `FileHandle` automatically.
   * User code must still call the `fileHandle.close()` method.
   */
  readableWebStream(options = {}) {
    const start = async (controller) => {
      try {
        const chunkSize = 64 * 1024, maxChunks = 1e7;
        let i = 0, position = 0, bytesRead = NaN;
        while (bytesRead > 0) {
          const result = await this.read(new Uint8Array(chunkSize), 0, chunkSize, position);
          if (!result.bytesRead) {
            controller.close();
            return;
          }
          controller.enqueue(result.buffer.slice(0, result.bytesRead));
          position += result.bytesRead;
          if (++i >= maxChunks) {
            throw new ErrnoError(Errno.EFBIG, "Too many iterations on readable stream", this.file.path, "FileHandle.readableWebStream");
          }
          bytesRead = result.bytesRead;
        }
      } catch (e) {
        controller.error(e);
      }
    };
    const _gt = globalThis;
    if (!("ReadableStream" in _gt)) {
      throw new ErrnoError(Errno.ENOSYS, "ReadableStream is missing on globalThis");
    }
    return new _gt.ReadableStream({ start, type: options.type });
  }
  /**
   * @todo Implement
   */
  readLines(options) {
    throw ErrnoError.With("ENOSYS", this.file.path, "FileHandle.readLines");
  }
  [Symbol.asyncDispose]() {
    return this.close();
  }
  async stat(opts) {
    const stats2 = await this.file.stat();
    if (config.checkAccess && !stats2.hasAccess(R_OK, this.context)) {
      throw ErrnoError.With("EACCES", this.file.path, "stat");
    }
    return (opts === null || opts === void 0 ? void 0 : opts.bigint) ? new BigIntStats(stats2) : stats2;
  }
  /**
   * Asynchronously writes `string` to the file.
   * The `FileHandle` must have been opened for writing.
   * It is unsafe to call `write()` multiple times on the same file without waiting for the `Promise`
   * to be resolved (or rejected). For this scenario, `fs.createWriteStream` is strongly recommended.
   */
  async write(data, options, lenOrEnc, position) {
    let buffer, offset, length;
    if (typeof options == "object") {
      lenOrEnc = options === null || options === void 0 ? void 0 : options.length;
      position = options === null || options === void 0 ? void 0 : options.position;
      options = options === null || options === void 0 ? void 0 : options.offset;
    }
    if (typeof data === "string") {
      position = typeof options === "number" ? options : null;
      const encoding = typeof lenOrEnc === "string" ? lenOrEnc : "utf8";
      offset = 0;
      buffer = import_buffer2.Buffer.from(data, encoding);
      length = buffer.length;
    } else {
      buffer = new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
      offset = options;
      length = lenOrEnc;
      position = typeof position === "number" ? position : null;
    }
    position !== null && position !== void 0 ? position : position = this.file.position;
    const bytesWritten = await this.file.write(buffer, offset, length, position);
    emitChange("change", this.file.path);
    return { buffer: data, bytesWritten };
  }
  /**
   * Asynchronously writes data to a file, replacing the file if it already exists. The underlying file will _not_ be closed automatically.
   * The `FileHandle` must have been opened for writing.
   * It is unsafe to call `writeFile()` multiple times on the same file without waiting for the `Promise` to be resolved (or rejected).
   * @param data The data to write. If something other than a `Buffer` or `Uint8Array` is provided, the value is coerced to a string.
   * @param _options Either the encoding for the file, or an object optionally specifying the encoding, file mode, and flag.
   * - `encoding` defaults to `'utf8'`.
   * - `mode` defaults to `0o666`.
   * - `flag` defaults to `'w'`.
   */
  async writeFile(data, _options = {}) {
    const options = normalizeOptions(_options, "utf8", "w", 420);
    const flag = parseFlag(options.flag);
    if (!isWriteable(flag)) {
      throw new ErrnoError(Errno.EINVAL, "Flag passed must allow for writing.");
    }
    if (typeof data != "string" && !options.encoding) {
      throw new ErrnoError(Errno.EINVAL, "Encoding not specified");
    }
    const encodedData = typeof data == "string" ? import_buffer2.Buffer.from(data, options.encoding) : data;
    await this.file.write(encodedData, 0, encodedData.length, 0);
    emitChange("change", this.file.path);
  }
  /**
   * Asynchronous close(2) - close a `FileHandle`.
   */
  async close() {
    await this.file.close();
    fdMap.delete(this.fd);
  }
  /**
   * Asynchronous `writev`. Writes from multiple buffers.
   * @param buffers An array of Uint8Array buffers.
   * @param position The position in the file where to begin writing.
   * @returns The number of bytes written.
   */
  async writev(buffers, position) {
    let bytesWritten = 0;
    for (const buffer of buffers) {
      bytesWritten += (await this.write(buffer, 0, buffer.length, position + bytesWritten)).bytesWritten;
    }
    return { bytesWritten, buffers };
  }
  /**
   * Asynchronous `readv`. Reads into multiple buffers.
   * @param buffers An array of Uint8Array buffers.
   * @param position The position in the file where to begin reading.
   * @returns The number of bytes read.
   */
  async readv(buffers, position) {
    let bytesRead = 0;
    for (const buffer of buffers) {
      bytesRead += (await this.read(buffer, 0, buffer.byteLength, position + bytesRead)).bytesRead;
    }
    return { bytesRead, buffers };
  }
  /**
   * Creates a stream for reading from the file.
   * @param options Options for the readable stream
   */
  createReadStream(options) {
    const stream = new ReadStream({
      highWaterMark: (options === null || options === void 0 ? void 0 : options.highWaterMark) || 64 * 1024,
      encoding: options.encoding,
      // eslint-disable-next-line @typescript-eslint/no-misused-promises
      read: async (size) => {
        try {
          const result = await this.read(new Uint8Array(size), 0, size, this.file.position);
          stream.push(!result.bytesRead ? null : result.buffer.slice(0, result.bytesRead));
          this.file.position += result.bytesRead;
        } catch (error) {
          stream.destroy(error);
        }
      }
    });
    stream.path = this.file.path;
    return stream;
  }
  /**
   * Creates a stream for writing to the file.
   * @param options Options for the writeable stream.
   */
  createWriteStream(options) {
    const streamOptions = {
      highWaterMark: options === null || options === void 0 ? void 0 : options.highWaterMark,
      encoding: options === null || options === void 0 ? void 0 : options.encoding,
      write: async (chunk, encoding, callback) => {
        try {
          const { bytesWritten } = await this.write(chunk, null, encoding);
          callback(bytesWritten == chunk.length ? null : new Error("Failed to write full chunk"));
        } catch (error) {
          callback(error);
        }
      }
    };
    const stream = new WriteStream(streamOptions);
    stream.path = this.file.path;
    return stream;
  }
};
async function rename(oldPath, newPath) {
  oldPath = normalizePath(oldPath);
  newPath = normalizePath(newPath);
  const src = resolveMount(oldPath, this);
  const dst = resolveMount(newPath, this);
  if (config.checkAccess && !(await stat.call(this, dirname(oldPath))).hasAccess(W_OK, this)) {
    throw ErrnoError.With("EACCES", oldPath, "rename");
  }
  try {
    if (src.mountPoint == dst.mountPoint) {
      await src.fs.rename(src.path, dst.path);
      emitChange("rename", oldPath.toString());
      emitChange("change", newPath.toString());
      return;
    }
    await writeFile.call(this, newPath, await readFile(oldPath));
    await unlink.call(this, oldPath);
    emitChange("rename", oldPath.toString());
  } catch (e) {
    throw fixError(e, { [src.path]: oldPath, [dst.path]: newPath });
  }
}
async function exists(path) {
  try {
    const { fs, path: resolved } = resolveMount(await realpath.call(this, path), this);
    return await fs.exists(resolved);
  } catch (e) {
    if (e instanceof ErrnoError && e.code == "ENOENT") {
      return false;
    }
    throw e;
  }
}
async function stat(path, options) {
  path = normalizePath(path);
  const { fs, path: resolved } = resolveMount(await realpath.call(this, path), this);
  try {
    const stats2 = await fs.stat(resolved);
    if (config.checkAccess && !stats2.hasAccess(R_OK, this)) {
      throw ErrnoError.With("EACCES", resolved, "stat");
    }
    return (options === null || options === void 0 ? void 0 : options.bigint) ? new BigIntStats(stats2) : stats2;
  } catch (e) {
    throw fixError(e, { [resolved]: path });
  }
}
async function lstat(path, options) {
  path = normalizePath(path);
  const { fs, path: resolved } = resolveMount(path, this);
  try {
    const stats2 = await fs.stat(resolved);
    return (options === null || options === void 0 ? void 0 : options.bigint) ? new BigIntStats(stats2) : stats2;
  } catch (e) {
    throw fixError(e, { [resolved]: path });
  }
}
async function truncate(path, len = 0) {
  const env_1 = { stack: [], error: void 0, hasError: false };
  try {
    const handle = __addDisposableResource6(env_1, await open.call(this, path, "r+"), true);
    await handle.truncate(len);
  } catch (e_1) {
    env_1.error = e_1;
    env_1.hasError = true;
  } finally {
    const result_1 = __disposeResources6(env_1);
    if (result_1)
      await result_1;
  }
}
async function unlink(path) {
  path = normalizePath(path);
  const { fs, path: resolved } = resolveMount(path, this);
  try {
    if (config.checkAccess && !(await (stats.getAsync(path) || fs.stat(resolved))).hasAccess(W_OK, this)) {
      throw ErrnoError.With("EACCES", resolved, "unlink");
    }
    await fs.unlink(resolved);
    emitChange("rename", path.toString());
  } catch (e) {
    throw fixError(e, { [resolved]: path });
  }
}
async function applySetId2(file, uid, gid) {
  var _a3;
  if ((_a3 = file.fs.metadata().features) === null || _a3 === void 0 ? void 0 : _a3.includes("setid"))
    return;
  const parent = await file.fs.stat(dirname(file.path));
  await file.chown(
    parent.mode & S_ISUID ? parent.uid : uid,
    // manually apply setuid/setgid
    parent.mode & S_ISGID ? parent.gid : gid
  );
}
async function _open(path, _flag, _mode = 420, resolveSymlinks) {
  var _a3;
  path = normalizePath(path);
  const mode = normalizeMode(_mode, 420), flag = parseFlag(_flag);
  path = resolveSymlinks ? await realpath.call(this, path) : path;
  const { fs, path: resolved } = resolveMount(path, this);
  const stats2 = await fs.stat(resolved).catch(() => null);
  if (!stats2) {
    if (!isWriteable(flag) && !isAppendable(flag) || flag == "r+") {
      throw ErrnoError.With("ENOENT", path, "_open");
    }
    const parentStats = await fs.stat(dirname(resolved));
    if (config.checkAccess && !parentStats.hasAccess(W_OK, this)) {
      throw ErrnoError.With("EACCES", dirname(path), "_open");
    }
    if (!parentStats.isDirectory()) {
      throw ErrnoError.With("ENOTDIR", dirname(path), "_open");
    }
    const { euid: uid, egid: gid } = (_a3 = this === null || this === void 0 ? void 0 : this.credentials) !== null && _a3 !== void 0 ? _a3 : credentials;
    const file = await fs.createFile(resolved, flag, mode, { uid, gid });
    await applySetId2(file, uid, gid);
    return new FileHandle(file, this);
  }
  if (config.checkAccess && !stats2.hasAccess(flagToMode(flag), this)) {
    throw ErrnoError.With("EACCES", path, "_open");
  }
  if (isExclusive(flag)) {
    throw ErrnoError.With("EEXIST", path, "_open");
  }
  const handle = new FileHandle(await fs.openFile(resolved, flag), this);
  if (isTruncating(flag)) {
    await handle.truncate(0);
  }
  return handle;
}
async function open(path, flag = "r", mode = 420) {
  return await _open.call(this, path, flag, mode, true);
}
async function readFile(path, _options) {
  const env_2 = { stack: [], error: void 0, hasError: false };
  try {
    const options = normalizeOptions(_options, null, "r", 420);
    const handle = __addDisposableResource6(env_2, typeof path == "object" && "fd" in path ? path : await open.call(this, path, options.flag, options.mode), true);
    return await handle.readFile(options);
  } catch (e_2) {
    env_2.error = e_2;
    env_2.hasError = true;
  } finally {
    const result_2 = __disposeResources6(env_2);
    if (result_2)
      await result_2;
  }
}
async function writeFile(path, data, _options) {
  const env_3 = { stack: [], error: void 0, hasError: false };
  try {
    const options = normalizeOptions(_options, "utf8", "w+", 420);
    const handle = __addDisposableResource6(env_3, path instanceof FileHandle ? path : await open.call(this, path.toString(), options.flag, options.mode), true);
    const _data = typeof data == "string" ? data : data instanceof DataView ? new Uint8Array(data.buffer.slice(data.byteOffset, data.byteOffset + data.byteLength)) : data;
    if (typeof _data != "string" && !(_data instanceof Uint8Array)) {
      throw new ErrnoError(Errno.EINVAL, 'The "data" argument must be of type string or an instance of Buffer, TypedArray, or DataView. Received ' + typeof data, handle.file.path, "writeFile");
    }
    await handle.writeFile(_data, options);
  } catch (e_3) {
    env_3.error = e_3;
    env_3.hasError = true;
  } finally {
    const result_3 = __disposeResources6(env_3);
    if (result_3)
      await result_3;
  }
}
async function appendFile(path, data, _options) {
  const env_4 = { stack: [], error: void 0, hasError: false };
  try {
    const options = normalizeOptions(_options, "utf8", "a", 420);
    const flag = parseFlag(options.flag);
    if (!isAppendable(flag)) {
      throw new ErrnoError(Errno.EINVAL, "Flag passed to appendFile must allow for appending.");
    }
    if (typeof data != "string" && !options.encoding) {
      throw new ErrnoError(Errno.EINVAL, "Encoding not specified");
    }
    const encodedData = typeof data == "string" ? import_buffer2.Buffer.from(data, options.encoding) : new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
    const handle = __addDisposableResource6(env_4, typeof path == "object" && "fd" in path ? path : await open.call(this, path, options.flag, options.mode), true);
    await handle.appendFile(encodedData, options);
  } catch (e_4) {
    env_4.error = e_4;
    env_4.hasError = true;
  } finally {
    const result_4 = __disposeResources6(env_4);
    if (result_4)
      await result_4;
  }
}
async function rmdir(path) {
  path = await realpath.call(this, path);
  const { fs, path: resolved } = resolveMount(path, this);
  try {
    const stats2 = await (stats.getAsync(path) || fs.stat(resolved));
    if (!stats2) {
      throw ErrnoError.With("ENOENT", path, "rmdir");
    }
    if (!stats2.isDirectory()) {
      throw ErrnoError.With("ENOTDIR", resolved, "rmdir");
    }
    if (config.checkAccess && !stats2.hasAccess(W_OK, this)) {
      throw ErrnoError.With("EACCES", resolved, "rmdir");
    }
    await fs.rmdir(resolved);
    emitChange("rename", path.toString());
  } catch (e) {
    throw fixError(e, { [resolved]: path });
  }
}
async function mkdir(path, options) {
  var _a3, _b2;
  const { euid: uid, egid: gid } = (_a3 = this === null || this === void 0 ? void 0 : this.credentials) !== null && _a3 !== void 0 ? _a3 : credentials;
  options = typeof options === "object" ? options : { mode: options };
  const mode = normalizeMode(options === null || options === void 0 ? void 0 : options.mode, 511);
  path = await realpath.call(this, path);
  const { fs, path: resolved, root } = resolveMount(path, this);
  const errorPaths = { [resolved]: path };
  try {
    if (!(options === null || options === void 0 ? void 0 : options.recursive)) {
      if (config.checkAccess && !(await fs.stat(dirname(resolved))).hasAccess(W_OK, this)) {
        throw ErrnoError.With("EACCES", dirname(resolved), "mkdir");
      }
      await fs.mkdir(resolved, mode, { uid, gid });
      await applySetId2(await fs.openFile(resolved, "r+"), uid, gid);
      emitChange("rename", path.toString());
      return;
    }
    const dirs = [];
    for (let dir = resolved, origDir = path; !await fs.exists(dir); dir = dirname(dir), origDir = dirname(origDir)) {
      dirs.unshift(dir);
      errorPaths[dir] = origDir;
    }
    for (const dir of dirs) {
      if (config.checkAccess && !(await fs.stat(dirname(dir))).hasAccess(W_OK, this)) {
        throw ErrnoError.With("EACCES", dirname(dir), "mkdir");
      }
      await fs.mkdir(dir, mode, { uid, gid });
      await applySetId2(await fs.openFile(dir, "r+"), uid, gid);
      emitChange("rename", dir);
    }
    return root.length == 1 ? dirs[0] : (_b2 = dirs[0]) === null || _b2 === void 0 ? void 0 : _b2.slice(root.length);
  } catch (e) {
    throw fixError(e, errorPaths);
  }
}
async function readdir(path, options) {
  options = typeof options === "object" ? options : { encoding: options };
  path = await realpath.call(this, path);
  const handleError = (e) => {
    throw fixError(e, { [resolved]: path });
  };
  const { fs, path: resolved } = resolveMount(path, this);
  const _stats = stats.getAsync(path) || fs.stat(resolved).catch(handleError);
  stats.setAsync(path, _stats);
  const stats2 = await _stats;
  if (!stats2) {
    throw ErrnoError.With("ENOENT", path, "readdir");
  }
  if (config.checkAccess && !stats2.hasAccess(R_OK, this)) {
    throw ErrnoError.With("EACCES", path, "readdir");
  }
  if (!stats2.isDirectory()) {
    throw ErrnoError.With("ENOTDIR", path, "readdir");
  }
  const entries = await fs.readdir(resolved).catch(handleError);
  const values = [];
  const addEntry = async (entry) => {
    let entryStats;
    if ((options === null || options === void 0 ? void 0 : options.recursive) || (options === null || options === void 0 ? void 0 : options.withFileTypes)) {
      const _entryStats = stats.getAsync(join(path, entry)) || fs.stat(join(resolved, entry)).catch(handleError);
      stats.setAsync(join(path, entry), _entryStats);
      entryStats = await _entryStats;
    }
    if (options === null || options === void 0 ? void 0 : options.withFileTypes) {
      values.push(new Dirent(entry, entryStats));
    } else if ((options === null || options === void 0 ? void 0 : options.encoding) == "buffer") {
      values.push(import_buffer2.Buffer.from(entry));
    } else {
      values.push(entry);
    }
    if (!(options === null || options === void 0 ? void 0 : options.recursive) || !(entryStats === null || entryStats === void 0 ? void 0 : entryStats.isDirectory()))
      return;
    for (const subEntry of await readdir.call(this, join(path, entry), { ...options, _isIndirect: true })) {
      if (subEntry instanceof Dirent) {
        subEntry.path = join(entry, subEntry.path);
        values.push(subEntry);
      } else if (import_buffer2.Buffer.isBuffer(subEntry)) {
        values.push(import_buffer2.Buffer.from(join(entry, decodeUTF8(subEntry))));
      } else {
        values.push(join(entry, subEntry));
      }
    }
  };
  await Promise.all(entries.map(addEntry));
  if (!(options === null || options === void 0 ? void 0 : options._isIndirect)) {
    stats.clear();
  }
  return values;
}
async function link(targetPath, linkPath) {
  targetPath = normalizePath(targetPath);
  linkPath = normalizePath(linkPath);
  const { fs, path } = resolveMount(targetPath, this);
  const link3 = resolveMount(linkPath, this);
  if (fs != link3.fs) {
    throw ErrnoError.With("EXDEV", linkPath, "link");
  }
  try {
    if (config.checkAccess && !(await fs.stat(dirname(targetPath))).hasAccess(R_OK, this)) {
      throw ErrnoError.With("EACCES", dirname(path), "link");
    }
    if (config.checkAccess && !(await stat.call(this, dirname(linkPath))).hasAccess(W_OK, this)) {
      throw ErrnoError.With("EACCES", dirname(linkPath), "link");
    }
    if (config.checkAccess && !(await fs.stat(path)).hasAccess(R_OK, this)) {
      throw ErrnoError.With("EACCES", path, "link");
    }
    return await fs.link(path, link3.path);
  } catch (e) {
    throw fixError(e, { [link3.path]: linkPath, [path]: targetPath });
  }
}
async function symlink(target, path, type = "file") {
  const env_5 = { stack: [], error: void 0, hasError: false };
  try {
    if (!["file", "dir", "junction"].includes(type)) {
      throw new ErrnoError(Errno.EINVAL, "Invalid symlink type: " + type);
    }
    if (await exists.call(this, path)) {
      throw ErrnoError.With("EEXIST", path.toString(), "symlink");
    }
    const handle = __addDisposableResource6(env_5, await _open.call(this, path, "w+", 420, false), true);
    await handle.writeFile(target.toString());
    await handle.file.chmod(S_IFLNK);
  } catch (e_5) {
    env_5.error = e_5;
    env_5.hasError = true;
  } finally {
    const result_5 = __disposeResources6(env_5);
    if (result_5)
      await result_5;
  }
}
async function readlink(path, options) {
  const env_6 = { stack: [], error: void 0, hasError: false };
  try {
    const handle = __addDisposableResource6(env_6, await _open.call(this, normalizePath(path), "r", 420, false), true);
    const value = await handle.readFile();
    const encoding = typeof options == "object" ? options === null || options === void 0 ? void 0 : options.encoding : options;
    return encoding == "buffer" ? value : value.toString(encoding !== null && encoding !== void 0 ? encoding : "utf-8");
  } catch (e_6) {
    env_6.error = e_6;
    env_6.hasError = true;
  } finally {
    const result_6 = __disposeResources6(env_6);
    if (result_6)
      await result_6;
  }
}
async function chown(path, uid, gid) {
  const env_7 = { stack: [], error: void 0, hasError: false };
  try {
    const handle = __addDisposableResource6(env_7, await open.call(this, path, "r+"), true);
    await handle.chown(uid, gid);
  } catch (e_7) {
    env_7.error = e_7;
    env_7.hasError = true;
  } finally {
    const result_7 = __disposeResources6(env_7);
    if (result_7)
      await result_7;
  }
}
async function lchown(path, uid, gid) {
  const env_8 = { stack: [], error: void 0, hasError: false };
  try {
    const handle = __addDisposableResource6(env_8, await _open.call(this, path, "r+", 420, false), true);
    await handle.chown(uid, gid);
  } catch (e_8) {
    env_8.error = e_8;
    env_8.hasError = true;
  } finally {
    const result_8 = __disposeResources6(env_8);
    if (result_8)
      await result_8;
  }
}
async function chmod(path, mode) {
  const env_9 = { stack: [], error: void 0, hasError: false };
  try {
    const handle = __addDisposableResource6(env_9, await open.call(this, path, "r+"), true);
    await handle.chmod(mode);
  } catch (e_9) {
    env_9.error = e_9;
    env_9.hasError = true;
  } finally {
    const result_9 = __disposeResources6(env_9);
    if (result_9)
      await result_9;
  }
}
async function lchmod(path, mode) {
  const env_10 = { stack: [], error: void 0, hasError: false };
  try {
    const handle = __addDisposableResource6(env_10, await _open.call(this, path, "r+", 420, false), true);
    await handle.chmod(mode);
  } catch (e_10) {
    env_10.error = e_10;
    env_10.hasError = true;
  } finally {
    const result_10 = __disposeResources6(env_10);
    if (result_10)
      await result_10;
  }
}
async function utimes(path, atime, mtime) {
  const env_11 = { stack: [], error: void 0, hasError: false };
  try {
    const handle = __addDisposableResource6(env_11, await open.call(this, path, "r+"), true);
    await handle.utimes(atime, mtime);
  } catch (e_11) {
    env_11.error = e_11;
    env_11.hasError = true;
  } finally {
    const result_11 = __disposeResources6(env_11);
    if (result_11)
      await result_11;
  }
}
async function lutimes(path, atime, mtime) {
  const env_12 = { stack: [], error: void 0, hasError: false };
  try {
    const handle = __addDisposableResource6(env_12, await _open.call(this, path, "r+", 420, false), true);
    await handle.utimes(new Date(atime), new Date(mtime));
  } catch (e_12) {
    env_12.error = e_12;
    env_12.hasError = true;
  } finally {
    const result_12 = __disposeResources6(env_12);
    if (result_12)
      await result_12;
  }
}
async function realpath(path, options) {
  path = normalizePath(path);
  const ctx_path = ((this === null || this === void 0 ? void 0 : this.root) || "") + path;
  if (paths.hasAsync(ctx_path))
    return paths.getAsync(ctx_path);
  const { base, dir } = parse2(path);
  const realDir = dir == "/" ? "/" : await (paths.getAsync(((this === null || this === void 0 ? void 0 : this.root) || "") + dir) || realpath.call(this, dir));
  const lpath = join(realDir, base);
  const { fs, path: resolvedPath } = resolveMount(lpath, this);
  try {
    const _stats = stats.getAsync(lpath) || fs.stat(resolvedPath);
    stats.setAsync(lpath, _stats);
    if (!(await _stats).isSymbolicLink()) {
      paths.set(path, lpath);
      return lpath;
    }
    const target = resolve(realDir, (await readlink.call(this, lpath)).toString());
    const real = paths.getAsync(((this === null || this === void 0 ? void 0 : this.root) || "") + target) || realpath.call(this, target);
    paths.setAsync(ctx_path, real);
    return await real;
  } catch (e) {
    if (e.code == "ENOENT") {
      return path;
    }
    throw fixError(e, { [resolvedPath]: lpath });
  }
}
function watch(filename, options = {}) {
  const context = this;
  return {
    [Symbol.asyncIterator]() {
      const watcher = new FSWatcher(context, filename.toString(), typeof options !== "string" ? options : { encoding: options });
      const eventQueue = [];
      watcher.on("change", (eventType, filename2) => {
        var _a3;
        (_a3 = eventQueue.shift()) === null || _a3 === void 0 ? void 0 : _a3({ value: { eventType, filename: filename2 }, done: false });
      });
      function cleanup() {
        watcher.close();
        for (const resolve2 of eventQueue) {
          resolve2({ value: null, done: true });
        }
        eventQueue.length = 0;
        return Promise.resolve({ value: null, done: true });
      }
      return {
        async next() {
          const { promise, resolve: resolve2 } = Promise.withResolvers();
          eventQueue.push(resolve2);
          return promise;
        },
        return: cleanup,
        throw: cleanup,
        [Symbol.asyncDispose]() {
          return Promise.resolve();
        }
      };
    }
  };
}
async function access(path, mode = F_OK) {
  if (!config.checkAccess)
    return;
  const stats2 = await stat.call(this, path);
  if (!stats2.hasAccess(mode, this)) {
    throw new ErrnoError(Errno.EACCES);
  }
}
async function rm(path, options) {
  path = normalizePath(path);
  const stats2 = await (stats.getAsync(path) || lstat.call(this, path).catch((error) => {
    if (error.code == "ENOENT" && (options === null || options === void 0 ? void 0 : options.force))
      return void 0;
    throw error;
  }));
  if (!stats2) {
    return;
  }
  stats.set(path, stats2);
  switch (stats2.mode & S_IFMT) {
    case S_IFDIR:
      if (options === null || options === void 0 ? void 0 : options.recursive) {
        for (const entry of await readdir.call(this, path, { _isIndirect: true })) {
          await rm.call(this, join(path, entry), { ...options, _isIndirect: true });
        }
      }
      await rmdir.call(this, path);
      break;
    case S_IFREG:
    case S_IFLNK:
    case S_IFBLK:
    case S_IFCHR:
      await unlink.call(this, path);
      break;
    case S_IFIFO:
    case S_IFSOCK:
    default:
      stats.clear();
      throw new ErrnoError(Errno.EPERM, "File type not supported", path, "rm");
  }
  if (!(options === null || options === void 0 ? void 0 : options._isIndirect)) {
    stats.clear();
  }
}
async function mkdtemp(prefix, options) {
  const encoding = typeof options === "object" ? options === null || options === void 0 ? void 0 : options.encoding : options || "utf8";
  const fsName = `${prefix}${Date.now()}-${Math.random().toString(36).slice(2)}`;
  const resolvedPath = "/tmp/" + fsName;
  await mkdir.call(this, resolvedPath);
  return encoding == "buffer" ? import_buffer2.Buffer.from(resolvedPath) : resolvedPath;
}
async function copyFile(src, dest, mode) {
  src = normalizePath(src);
  dest = normalizePath(dest);
  if (mode && mode & COPYFILE_EXCL && await exists.call(this, dest)) {
    throw new ErrnoError(Errno.EEXIST, "Destination file already exists.", dest, "copyFile");
  }
  await writeFile.call(this, dest, await readFile.call(this, src));
  emitChange("rename", dest.toString());
}
function opendir(path, options) {
  path = normalizePath(path);
  return Promise.resolve(new Dir(path, this));
}
async function cp(source, destination, opts) {
  source = normalizePath(source);
  destination = normalizePath(destination);
  const srcStats = await lstat.call(this, source);
  if ((opts === null || opts === void 0 ? void 0 : opts.errorOnExist) && await exists.call(this, destination)) {
    throw new ErrnoError(Errno.EEXIST, "Destination file or directory already exists.", destination, "cp");
  }
  switch (srcStats.mode & S_IFMT) {
    case S_IFDIR: {
      if (!(opts === null || opts === void 0 ? void 0 : opts.recursive)) {
        throw new ErrnoError(Errno.EISDIR, source + " is a directory (not copied)", source, "cp");
      }
      const [entries] = await Promise.all(
        [readdir.call(this, source, { withFileTypes: true }), mkdir.call(this, destination, { recursive: true })]
        // Ensure the destination directory exists
      );
      const _cp = async (dirent) => {
        if (opts.filter && !opts.filter(join(source, dirent.name), join(destination, dirent.name))) {
          return;
        }
        await cp.call(this, join(source, dirent.name), join(destination, dirent.name), opts);
      };
      await Promise.all(entries.map(_cp));
      break;
    }
    case S_IFREG:
    case S_IFLNK:
      await copyFile.call(this, source, destination);
      break;
    case S_IFBLK:
    case S_IFCHR:
    case S_IFIFO:
    case S_IFSOCK:
    default:
      throw new ErrnoError(Errno.EPERM, "File type not supported", source, "rm");
  }
  if (opts === null || opts === void 0 ? void 0 : opts.preserveTimestamps) {
    await utimes.call(this, destination, srcStats.atime, srcStats.mtime);
  }
}
async function statfs(path, opts) {
  path = normalizePath(path);
  const { fs } = resolveMount(path, this);
  return Promise.resolve(_statfs(fs, opts === null || opts === void 0 ? void 0 : opts.bigint));
}
function glob(pattern, opt) {
  pattern = Array.isArray(pattern) ? pattern : [pattern];
  const { cwd: cwd2 = "/", withFileTypes = false, exclude = () => false } = opt || {};
  const regexPatterns = pattern.map((p) => {
    p = p.replace(/([.?+^$(){}|[\]/])/g, "$1").replace(/\*\*/g, ".*").replace(/\*/g, "[^/]*").replace(/\?/g, ".");
    return new RegExp(`^${p}$`);
  });
  async function* recursiveList(dir) {
    const entries = await readdir(dir, { withFileTypes, encoding: "utf8" });
    for (const entry of entries) {
      const fullPath = withFileTypes ? entry.path : dir + "/" + entry;
      if (exclude(withFileTypes ? entry : fullPath))
        continue;
      if ((await stat(fullPath)).isDirectory() && regexPatterns.some((pattern2) => pattern2.source.includes(".*"))) {
        yield* recursiveList(fullPath);
      }
      if (regexPatterns.some((pattern2) => pattern2.test(fullPath.replace(/^\/+/g, "")))) {
        yield withFileTypes ? entry : fullPath.replace(/^\/+/g, "");
      }
    }
  }
  return recursiveList(cwd2);
}

// node_modules/@zenfs/core/dist/vfs/async.js
var nop = () => {
};
async function collectAsyncIterator(it) {
  const results = [];
  for await (const result of it) {
    results.push(result);
  }
  return results;
}
function rename2(oldPath, newPath, cb = nop) {
  rename.call(this, oldPath, newPath).then(() => cb()).catch(cb);
}
function exists2(path, cb = nop) {
  exists.call(this, path).then(cb).catch(() => cb(false));
}
function stat2(path, options, callback = nop) {
  callback = typeof options == "function" ? options : callback;
  stat.call(this, path, typeof options != "function" ? options : {}).then((stats2) => callback(void 0, stats2)).catch(callback);
}
function lstat2(path, options, callback = nop) {
  callback = typeof options == "function" ? options : callback;
  lstat.call(this, path, typeof options != "function" ? options : {}).then((stats2) => callback(void 0, stats2)).catch(callback);
}
function truncate2(path, cbLen = 0, cb = nop) {
  cb = typeof cbLen === "function" ? cbLen : cb;
  const len = typeof cbLen === "number" ? cbLen : 0;
  truncate.call(this, path, len).then(() => cb()).catch(cb);
}
function unlink2(path, cb = nop) {
  unlink.call(this, path).then(() => cb()).catch(cb);
}
function open2(path, flag, cbMode, cb = nop) {
  const mode = normalizeMode(cbMode, 420);
  cb = typeof cbMode === "function" ? cbMode : cb;
  open.call(this, path, flag, mode).then((handle) => cb(void 0, handle.fd)).catch(cb);
}
function readFile2(filename, options, cb = nop) {
  cb = typeof options === "function" ? options : cb;
  readFile.call(this, filename, typeof options === "function" ? null : options).then((data) => cb(void 0, data)).catch(cb);
}
function writeFile2(filename, data, cbEncOpts, cb = nop) {
  cb = typeof cbEncOpts === "function" ? cbEncOpts : cb;
  writeFile.call(this, filename, data, typeof cbEncOpts != "function" ? cbEncOpts : null).then(() => cb(void 0)).catch(cb);
}
function appendFile2(filename, data, cbEncOpts, cb = nop) {
  const optionsOrEncoding = typeof cbEncOpts != "function" ? cbEncOpts : void 0;
  cb = typeof cbEncOpts === "function" ? cbEncOpts : cb;
  appendFile.call(this, filename, data, optionsOrEncoding).then(() => cb()).catch(cb);
}
function fstat(fd, options, cb = nop) {
  cb = typeof options == "function" ? options : cb;
  fd2file(fd).stat().then((stats2) => cb(void 0, typeof options == "object" && (options === null || options === void 0 ? void 0 : options.bigint) ? new BigIntStats(stats2) : stats2)).catch(cb);
}
function close(fd, cb = nop) {
  const close2 = fd2file(fd).close();
  fdMap.delete(fd);
  close2.then(() => cb()).catch(cb);
}
function ftruncate(fd, lenOrCB, cb = nop) {
  const length = typeof lenOrCB === "number" ? lenOrCB : 0;
  cb = typeof lenOrCB === "function" ? lenOrCB : cb;
  const file = fd2file(fd);
  if (length < 0) {
    throw new ErrnoError(Errno.EINVAL);
  }
  file.truncate(length).then(() => cb()).catch(cb);
}
function fsync(fd, cb = nop) {
  fd2file(fd).sync().then(() => cb()).catch(cb);
}
function fdatasync(fd, cb = nop) {
  fd2file(fd).datasync().then(() => cb()).catch(cb);
}
function write(fd, data, cbPosOff, cbLenEnc, cbPosEnc, cb = nop) {
  let buffer, offset, length, position, encoding;
  const handle = new FileHandle(fd, this);
  if (typeof data === "string") {
    encoding = "utf8";
    switch (typeof cbPosOff) {
      case "function":
        cb = cbPosOff;
        break;
      case "number":
        position = cbPosOff;
        encoding = typeof cbLenEnc === "string" ? cbLenEnc : "utf8";
        cb = typeof cbPosEnc === "function" ? cbPosEnc : cb;
        break;
      default:
        cb = typeof cbLenEnc === "function" ? cbLenEnc : typeof cbPosEnc === "function" ? cbPosEnc : cb;
        cb(new ErrnoError(Errno.EINVAL, "Invalid arguments."));
        return;
    }
    buffer = import_buffer3.Buffer.from(data);
    offset = 0;
    length = buffer.length;
    const _cb = cb;
    handle.write(buffer, offset, length, position).then(({ bytesWritten }) => _cb(void 0, bytesWritten, buffer.toString(encoding))).catch(_cb);
  } else {
    buffer = import_buffer3.Buffer.from(data.buffer);
    offset = cbPosOff;
    length = cbLenEnc;
    position = typeof cbPosEnc === "number" ? cbPosEnc : null;
    const _cb = typeof cbPosEnc === "function" ? cbPosEnc : cb;
    void handle.write(buffer, offset, length, position).then(({ bytesWritten }) => _cb(void 0, bytesWritten, buffer)).catch(_cb);
  }
}
function read(fd, buffer, offset, length, position, cb = nop) {
  new FileHandle(fd, this).read(buffer, offset, length, position).then(({ bytesRead, buffer: buffer2 }) => cb(void 0, bytesRead, buffer2)).catch(cb);
}
function fchown(fd, uid, gid, cb = nop) {
  new FileHandle(fd, this).chown(uid, gid).then(() => cb()).catch(cb);
}
function fchmod(fd, mode, cb) {
  new FileHandle(fd, this).chmod(mode).then(() => cb()).catch(cb);
}
function futimes(fd, atime, mtime, cb = nop) {
  new FileHandle(fd, this).utimes(atime, mtime).then(() => cb()).catch(cb);
}
function rmdir2(path, cb = nop) {
  rmdir.call(this, path).then(() => cb()).catch(cb);
}
function mkdir2(path, mode, cb = nop) {
  mkdir.call(this, path, mode).then(() => cb()).catch(cb);
}
function readdir2(path, _options, cb = nop) {
  cb = typeof _options == "function" ? _options : cb;
  const options = typeof _options != "function" ? _options : {};
  readdir.call(this, path, options).then((entries) => cb(void 0, entries)).catch(cb);
}
function link2(existing, newpath, cb = nop) {
  link.call(this, existing, newpath).then(() => cb()).catch(cb);
}
function symlink2(target, path, typeOrCB, cb = nop) {
  const type = typeof typeOrCB === "string" ? typeOrCB : "file";
  cb = typeof typeOrCB === "function" ? typeOrCB : cb;
  symlink.call(this, target, path, type).then(() => cb()).catch(cb);
}
function readlink2(path, options, callback = nop) {
  callback = typeof options == "function" ? options : callback;
  readlink.call(this, path).then((result) => callback(void 0, result)).catch(callback);
}
function chown2(path, uid, gid, cb = nop) {
  chown.call(this, path, uid, gid).then(() => cb()).catch(cb);
}
function lchown2(path, uid, gid, cb = nop) {
  lchown.call(this, path, uid, gid).then(() => cb()).catch(cb);
}
function chmod2(path, mode, cb = nop) {
  chmod.call(this, path, mode).then(() => cb()).catch(cb);
}
function lchmod2(path, mode, cb = nop) {
  lchmod.call(this, path, mode).then(() => cb()).catch(cb);
}
function utimes2(path, atime, mtime, cb = nop) {
  utimes.call(this, path, atime, mtime).then(() => cb()).catch(cb);
}
function lutimes2(path, atime, mtime, cb = nop) {
  lutimes.call(this, path, atime, mtime).then(() => cb()).catch(cb);
}
function realpath2(path, arg2, cb = nop) {
  cb = typeof arg2 === "function" ? arg2 : cb;
  realpath.call(this, path, typeof arg2 === "function" ? null : arg2).then((result) => cb(void 0, result)).catch(cb);
}
function access2(path, cbMode, cb = nop) {
  const mode = typeof cbMode === "number" ? cbMode : R_OK;
  cb = typeof cbMode === "function" ? cbMode : cb;
  access.call(this, path, mode).then(() => cb()).catch(cb);
}
var statWatchers = /* @__PURE__ */ new Map();
function watchFile(path, options, listener) {
  const normalizedPath = normalizePath(path.toString());
  const opts = typeof options != "function" ? options : {};
  if (typeof options == "function") {
    listener = options;
  }
  if (!listener) {
    throw new ErrnoError(Errno.EINVAL, "No listener specified", path.toString(), "watchFile");
  }
  if (statWatchers.has(normalizedPath)) {
    const entry = statWatchers.get(normalizedPath);
    if (entry) {
      entry.listeners.add(listener);
    }
    return;
  }
  const watcher = new StatWatcher(this, normalizedPath, opts);
  watcher.on("change", (curr, prev) => {
    const entry = statWatchers.get(normalizedPath);
    if (!entry) {
      return;
    }
    for (const listener2 of entry.listeners) {
      listener2(curr, prev);
    }
  });
  statWatchers.set(normalizedPath, { watcher, listeners: /* @__PURE__ */ new Set() });
}
function unwatchFile(path, listener = nop) {
  const normalizedPath = normalizePath(path.toString());
  const entry = statWatchers.get(normalizedPath);
  if (entry) {
    if (listener && listener !== nop) {
      entry.listeners.delete(listener);
    } else {
      entry.listeners.clear();
    }
    if (entry.listeners.size === 0) {
      entry.watcher.stop();
      statWatchers.delete(normalizedPath);
    }
  }
}
function watch2(path, options, listener) {
  const watcher = new FSWatcher(this, normalizePath(path), typeof options == "object" ? options : {});
  listener = typeof options == "function" ? options : listener;
  watcher.on("change", listener || nop);
  return watcher;
}
function createReadStream(path, options) {
  const context = this;
  options = typeof options == "object" ? options : { encoding: options };
  let handle;
  const stream = new ReadStream({
    highWaterMark: options.highWaterMark || 64 * 1024,
    encoding: options.encoding || "utf8",
    async read(size) {
      try {
        handle || (handle = await open.call(context, path, "r", options === null || options === void 0 ? void 0 : options.mode));
        const result = await handle.read(new Uint8Array(size), 0, size, handle.file.position);
        stream.push(!result.bytesRead ? null : result.buffer.slice(0, result.bytesRead));
        handle.file.position += result.bytesRead;
        if (!result.bytesRead) {
          await handle.close();
        }
      } catch (error) {
        await (handle === null || handle === void 0 ? void 0 : handle.close());
        stream.destroy(error);
      }
    },
    destroy(error, callback) {
      handle === null || handle === void 0 ? void 0 : handle.close().then(() => callback(error)).catch(nop);
    }
  });
  stream.path = path.toString();
  return stream;
}
function createWriteStream(path, options) {
  const context = this;
  options = typeof options == "object" ? options : { encoding: options };
  let handle;
  const stream = new WriteStream({
    highWaterMark: options === null || options === void 0 ? void 0 : options.highWaterMark,
    async write(chunk, encoding, callback) {
      try {
        handle || (handle = await open.call(context, path, "w", (options === null || options === void 0 ? void 0 : options.mode) || 438));
        await handle.write(chunk, 0, encoding);
        callback(void 0);
      } catch (error) {
        await (handle === null || handle === void 0 ? void 0 : handle.close());
        callback(error);
      }
    },
    destroy(error, callback) {
      callback(error);
      handle === null || handle === void 0 ? void 0 : handle.close().then(() => callback(error)).catch(callback);
    },
    final(callback) {
      handle === null || handle === void 0 ? void 0 : handle.close().then(() => callback()).catch(callback);
    }
  });
  stream.path = path.toString();
  return stream;
}
function rm2(path, options, callback = nop) {
  callback = typeof options === "function" ? options : callback;
  rm.call(this, path, typeof options === "function" ? void 0 : options).then(() => callback(void 0)).catch(callback);
}
function mkdtemp2(prefix, options, callback = nop) {
  callback = typeof options === "function" ? options : callback;
  mkdtemp.call(this, prefix, typeof options != "function" ? options : null).then((result) => callback(void 0, result)).catch(callback);
}
function copyFile2(src, dest, flags, callback = nop) {
  callback = typeof flags === "function" ? flags : callback;
  copyFile.call(this, src, dest, typeof flags === "function" ? void 0 : flags).then(() => callback(void 0)).catch(callback);
}
function readv(fd, buffers, position, cb = nop) {
  cb = typeof position === "function" ? position : cb;
  new FileHandle(fd, this).readv(buffers, typeof position === "function" ? void 0 : position).then(({ buffers: buffers2, bytesRead }) => cb(void 0, bytesRead, buffers2)).catch(cb);
}
function writev(fd, buffers, position, cb = nop) {
  cb = typeof position === "function" ? position : cb;
  new FileHandle(fd, this).writev(buffers, typeof position === "function" ? void 0 : position).then(({ buffers: buffers2, bytesWritten }) => cb(void 0, bytesWritten, buffers2)).catch(cb);
}
function opendir2(path, options, cb = nop) {
  cb = typeof options === "function" ? options : cb;
  opendir.call(this, path, typeof options === "function" ? void 0 : options).then((result) => cb(void 0, result)).catch(cb);
}
function cp2(source, destination, opts, callback = nop) {
  callback = typeof opts === "function" ? opts : callback;
  cp.call(this, source, destination, typeof opts === "function" ? void 0 : opts).then(() => callback(void 0)).catch(callback);
}
function statfs2(path, options, callback = nop) {
  callback = typeof options === "function" ? options : callback;
  statfs.call(this, path, typeof options === "function" ? void 0 : options).then((result) => callback(void 0, result)).catch(callback);
}
async function openAsBlob(path, options) {
  const handle = await open.call(this, path.toString(), "r");
  const buffer = await handle.readFile();
  await handle.close();
  return new Blob([buffer], options);
}
function glob2(pattern, options, callback = nop) {
  callback = typeof options == "function" ? options : callback;
  const it = glob.call(this, pattern, typeof options === "function" ? void 0 : options);
  collectAsyncIterator(it).then((results) => {
    var _a3;
    return callback(null, (_a3 = results) !== null && _a3 !== void 0 ? _a3 : []);
  }).catch((e) => callback(e));
}

// node_modules/@zenfs/core/dist/config.js
function isMountConfig(arg) {
  return isBackendConfig(arg) || isBackend(arg) || arg instanceof FileSystem;
}
async function resolveMountConfig(configuration, _depth = 0) {
  if (typeof configuration !== "object" || configuration == null) {
    throw new ErrnoError(Errno.EINVAL, "Invalid options on mount configuration");
  }
  if (!isMountConfig(configuration)) {
    throw new ErrnoError(Errno.EINVAL, "Invalid mount configuration");
  }
  if (configuration instanceof FileSystem) {
    await configuration.ready();
    return configuration;
  }
  if (isBackend(configuration)) {
    configuration = { backend: configuration };
  }
  for (const [key, value] of Object.entries(configuration)) {
    if (key == "backend") {
      continue;
    }
    if (!isMountConfig(value)) {
      continue;
    }
    if (_depth > 10) {
      throw new ErrnoError(Errno.EINVAL, "Invalid configuration, too deep and possibly infinite");
    }
    configuration[key] = await resolveMountConfig(value, ++_depth);
  }
  const { backend } = configuration;
  if (typeof backend.isAvailable == "function" && !await backend.isAvailable()) {
    throw new ErrnoError(Errno.EPERM, "Backend not available: " + backend.name);
  }
  await checkOptions(backend, configuration);
  const mount3 = await backend.create(configuration);
  mount3._disableSync = configuration.disableAsyncCache || false;
  await mount3.ready();
  return mount3;
}
async function configureSingle(configuration) {
  if (!isBackendConfig(configuration)) {
    throw new TypeError("Invalid single mount point configuration");
  }
  const resolved = await resolveMountConfig(configuration);
  umount("/");
  mount("/", resolved);
}
async function mount2(path, mount3) {
  if (path == "/") {
    mount(path, mount3);
    return;
  }
  const stats2 = await promises_exports.stat(path).catch(() => null);
  if (!stats2) {
    await promises_exports.mkdir(path, { recursive: true });
  } else if (!stats2.isDirectory()) {
    throw ErrnoError.With("ENOTDIR", path, "configure");
  }
  mount(path, mount3);
}
function addDevice(driver, options) {
  const devfs = mounts.get("/dev");
  if (!(devfs instanceof DeviceFS))
    throw new ErrnoError(Errno.ENOTSUP, "/dev does not exist or is not a device file system");
  return devfs._createDevice(driver, options);
}
async function configure(configuration) {
  var _a3, _b2, _c2;
  const uid = "uid" in configuration ? configuration.uid || 0 : 0;
  const gid = "gid" in configuration ? configuration.gid || 0 : 0;
  useCredentials({ uid, gid });
  stats.isEnabled = (_a3 = configuration.cacheStats) !== null && _a3 !== void 0 ? _a3 : false;
  paths.isEnabled = (_b2 = configuration.cachePaths) !== null && _b2 !== void 0 ? _b2 : false;
  config.checkAccess = !configuration.disableAccessChecks;
  config.updateOnRead = !configuration.disableUpdateOnRead;
  config.syncImmediately = !configuration.onlySyncOnClose;
  if (configuration.mounts) {
    for (const [_point, mountConfig] of Object.entries(configuration.mounts).sort(([a], [b]) => a.length > b.length ? 1 : -1)) {
      const point = _point.startsWith("/") ? _point : "/" + _point;
      if (isBackendConfig(mountConfig)) {
        (_c2 = mountConfig.disableAsyncCache) !== null && _c2 !== void 0 ? _c2 : mountConfig.disableAsyncCache = configuration.disableAsyncCache || false;
      }
      if (point == "/")
        umount("/");
      await mount2(point, await resolveMountConfig(mountConfig));
    }
  }
  if (configuration.addDevices) {
    const devfs = new DeviceFS();
    devfs.addDefaults();
    await devfs.ready();
    await mount2("/dev", devfs);
  }
}

// node_modules/@zenfs/core/dist/mixins/async.js
var __addDisposableResource7 = function(env, value, async) {
  if (value !== null && value !== void 0) {
    if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
    var dispose, inner;
    if (async) {
      if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
      dispose = value[Symbol.asyncDispose];
    }
    if (dispose === void 0) {
      if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
      dispose = value[Symbol.dispose];
      if (async) inner = dispose;
    }
    if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
    if (inner) dispose = function() {
      try {
        inner.call(this);
      } catch (e) {
        return Promise.reject(e);
      }
    };
    env.stack.push({ value, dispose, async });
  } else if (async) {
    env.stack.push({ async: true });
  }
  return value;
};
var __disposeResources7 = /* @__PURE__ */ function(SuppressedError2) {
  return function(env) {
    function fail(e) {
      env.error = env.hasError ? new SuppressedError2(e, env.error, "An error was suppressed during disposal.") : e;
      env.hasError = true;
    }
    var r, s = 0;
    function next() {
      while (r = env.stack.pop()) {
        try {
          if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);
          if (r.dispose) {
            var result = r.dispose.call(r.value);
            if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) {
              fail(e);
              return next();
            });
          } else s |= 1;
        } catch (e) {
          fail(e);
        }
      }
      if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
      if (env.hasError) throw env.error;
    }
    return next();
  };
}(typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
});
function Async(FS) {
  class AsyncFS extends FS {
    get _queueRunning() {
      return !!this._queue.length;
    }
    queueDone() {
      return new Promise((resolve2) => {
        const check = () => this._queueRunning ? setTimeout(check) : resolve2();
        check();
      });
    }
    constructor(...args) {
      super(...args);
      this._queue = [];
      this._isInitialized = false;
      this._patchAsync();
    }
    async ready() {
      await super.ready();
      await this.queueDone();
      if (this._isInitialized || this._disableSync) {
        return;
      }
      this.checkSync();
      await this._sync.ready();
      if (this._sync instanceof StoreFS && this instanceof StoreFS) {
        const sync = this._sync["store"].transaction();
        const async = this["store"].transaction();
        const promises = [];
        for (const key of await async.keys()) {
          promises.push(async.get(key).then((data) => sync.setSync(key, data)));
        }
        await Promise.all(promises);
        this._isInitialized = true;
        return;
      }
      try {
        await this.crossCopy("/");
        this._isInitialized = true;
      } catch (e) {
        this._isInitialized = false;
        throw e;
      }
    }
    checkSync(path, syscall) {
      if (this._disableSync) {
        throw new ErrnoError(Errno.ENOTSUP, "Sync caching has been disabled for this async file system", path, syscall);
      }
      if (!this._sync) {
        throw new ErrnoError(Errno.ENOTSUP, "No sync cache is attached to this async file system", path, syscall);
      }
    }
    renameSync(oldPath, newPath) {
      this.checkSync(oldPath, "rename");
      this._sync.renameSync(oldPath, newPath);
      this.queue("rename", oldPath, newPath);
    }
    statSync(path) {
      this.checkSync(path, "stat");
      return this._sync.statSync(path);
    }
    createFileSync(path, flag, mode, options) {
      this.checkSync(path, "createFile");
      this._sync.createFileSync(path, flag, mode, options);
      this.queue("createFile", path, flag, mode, options);
      return this.openFileSync(path, flag);
    }
    openFileSync(path, flag) {
      this.checkSync(path, "openFile");
      const file = this._sync.openFileSync(path, flag + "+");
      const stats2 = file.statSync();
      const buffer = new Uint8Array(stats2.size);
      file.readSync(buffer);
      return new PreloadFile(this, path, flag, stats2, buffer);
    }
    unlinkSync(path) {
      this.checkSync(path, "unlinkSync");
      this._sync.unlinkSync(path);
      this.queue("unlink", path);
    }
    rmdirSync(path) {
      this.checkSync(path, "rmdir");
      this._sync.rmdirSync(path);
      this.queue("rmdir", path);
    }
    mkdirSync(path, mode, options) {
      this.checkSync(path, "mkdir");
      this._sync.mkdirSync(path, mode, options);
      this.queue("mkdir", path, mode, options);
    }
    readdirSync(path) {
      this.checkSync(path, "readdir");
      return this._sync.readdirSync(path);
    }
    linkSync(srcpath, dstpath) {
      this.checkSync(srcpath, "link");
      this._sync.linkSync(srcpath, dstpath);
      this.queue("link", srcpath, dstpath);
    }
    syncSync(path, data, stats2) {
      this.checkSync(path, "sync");
      this._sync.syncSync(path, data, stats2);
      this.queue("sync", path, data, stats2);
    }
    existsSync(path) {
      this.checkSync(path, "exists");
      return this._sync.existsSync(path);
    }
    /**
     * @internal
     */
    async crossCopy(path) {
      this.checkSync(path, "crossCopy");
      const stats2 = await this.stat(path);
      if (!stats2.isDirectory()) {
        const env_1 = { stack: [], error: void 0, hasError: false };
        try {
          const asyncFile = __addDisposableResource7(env_1, await this.openFile(path, parseFlag("r")), true);
          const syncFile = __addDisposableResource7(env_1, this._sync.createFileSync(path, parseFlag("w"), stats2.mode, stats2), false);
          const buffer = new Uint8Array(stats2.size);
          await asyncFile.read(buffer);
          syncFile.writeSync(buffer, 0, stats2.size);
          return;
        } catch (e_1) {
          env_1.error = e_1;
          env_1.hasError = true;
        } finally {
          const result_1 = __disposeResources7(env_1);
          if (result_1)
            await result_1;
        }
      }
      if (path !== "/") {
        const stats3 = await this.stat(path);
        this._sync.mkdirSync(path, stats3.mode, stats3);
      }
      const promises = [];
      for (const file of await this.readdir(path)) {
        promises.push(this.crossCopy(join(path, file)));
      }
      await Promise.all(promises);
    }
    /**
     * @internal
     */
    async _next() {
      if (!this._queueRunning) {
        return;
      }
      const [method, ...args] = this._queue.shift();
      await this[method](...args);
      await this._next();
    }
    /**
     * @internal
     */
    queue(...op) {
      this._queue.push(op);
      void this._next();
    }
    /**
     * @internal
     * Patch all async methods to also call their synchronous counterparts unless called from the queue
     */
    _patchAsync() {
      const asyncFSMethodKeys = ["rename", "stat", "createFile", "openFile", "unlink", "rmdir", "mkdir", "readdir", "link", "sync", "exists"];
      for (const key of asyncFSMethodKeys) {
        if (typeof this[key] !== "function")
          continue;
        const originalMethod = this[key];
        this[key] = async (...args) => {
          var _a3, _b2;
          const result = await originalMethod.apply(this, args);
          if (new Error().stack.includes(`at async ${this.constructor.name}._next`) || !this._isInitialized)
            return result;
          try {
            (_b2 = (_a3 = this._sync) === null || _a3 === void 0 ? void 0 : _a3[`${key}Sync`]) === null || _b2 === void 0 ? void 0 : _b2.call(_a3, ...args);
          } catch (e) {
            throw new ErrnoError(e.errno, e.message + " (Out of sync!)", e.path, key);
          }
          return result;
        };
      }
    }
  }
  return AsyncFS;
}

// node_modules/@zenfs/core/dist/backends/port/rpc.js
function isFileData(value) {
  return typeof value == "object" && value != null && "fd" in value && "path" in value && "position" in value;
}
function isMessage(arg) {
  return typeof arg == "object" && arg != null && "_zenfs" in arg && !!arg._zenfs;
}
var executors = /* @__PURE__ */ new Map();
function request(request2, { port, timeout = 1e3, fs } = {}) {
  const stack = "\n" + new Error().stack.slice("Error:".length);
  if (!port) {
    throw ErrnoError.With("EINVAL");
  }
  return new Promise((resolve2, reject) => {
    const id = Math.random().toString(16).slice(10);
    executors.set(id, { resolve: resolve2, reject, fs });
    port.postMessage({ ...request2, _zenfs: true, id, stack });
    const _ = setTimeout(() => {
      const error = new ErrnoError(Errno.EIO, "RPC Failed");
      error.stack += stack;
      reject(error);
      if (typeof _ == "object")
        _.unref();
    }, timeout);
  });
}
function handleResponse(response) {
  if (!isMessage(response)) {
    return;
  }
  const { id, value, error, stack } = response;
  if (!executors.has(id)) {
    const error2 = new ErrnoError(Errno.EIO, "Invalid RPC id:" + id);
    error2.stack += stack;
    throw error2;
  }
  const { resolve: resolve2, reject, fs } = executors.get(id);
  if (error) {
    const e = typeof value == "string" ? new Error(value) : ErrnoError.fromJSON(value);
    e.stack += stack;
    reject(e);
    executors.delete(id);
    return;
  }
  if (isFileData(value)) {
    const { fd, path, position } = value;
    const file = new PortFile(fs, fd, path, position);
    resolve2(file);
    executors.delete(id);
    return;
  }
  resolve2(value);
  executors.delete(id);
  return;
}
function attach(port, handler) {
  if (!port) {
    throw ErrnoError.With("EINVAL");
  }
  port["on" in port ? "on" : "addEventListener"]("message", (message) => {
    handler("data" in message ? message.data : message);
  });
}
function detach(port, handler) {
  if (!port) {
    throw ErrnoError.With("EINVAL");
  }
  port["off" in port ? "off" : "removeEventListener"]("message", (message) => {
    handler("data" in message ? message.data : message);
  });
}
function catchMessages(port) {
  const events = [];
  const handler = events.push.bind(events);
  attach(port, handler);
  return function(fs) {
    detach(port, handler);
    for (const event of events) {
      const request2 = "data" in event ? event.data : event;
      void handleRequest(port, fs, request2);
    }
  };
}

// node_modules/@zenfs/core/dist/backends/port/fs.js
var PortFile = class extends File {
  constructor(fs, fd, path, position) {
    super(fs, path);
    this.fs = fs;
    this.fd = fd;
    this.position = position;
  }
  rpc(method, ...args) {
    return request({
      scope: "file",
      fd: this.fd,
      method,
      args
    }, this.fs.options);
  }
  _throwNoSync(syscall) {
    throw new ErrnoError(Errno.ENOTSUP, "Synchronous operations not supported on PortFile", this.path, syscall);
  }
  async stat() {
    return new Stats(await this.rpc("stat"));
  }
  statSync() {
    this._throwNoSync("stat");
  }
  truncate(len) {
    return this.rpc("truncate", len);
  }
  truncateSync() {
    this._throwNoSync("truncate");
  }
  write(buffer, offset, length, position) {
    return this.rpc("write", buffer, offset, length, position);
  }
  writeSync() {
    this._throwNoSync("write");
  }
  async read(buffer, offset, length, position) {
    const result = await this.rpc("read", buffer, offset, length, position);
    return result;
  }
  readSync() {
    this._throwNoSync("read");
  }
  chown(uid, gid) {
    return this.rpc("chown", uid, gid);
  }
  chownSync() {
    this._throwNoSync("chown");
  }
  chmod(mode) {
    return this.rpc("chmod", mode);
  }
  chmodSync() {
    this._throwNoSync("chmod");
  }
  utimes(atime, mtime) {
    return this.rpc("utimes", atime, mtime);
  }
  utimesSync() {
    this._throwNoSync("utimes");
  }
  _setTypeSync() {
    this._throwNoSync("_setType");
  }
  close() {
    return this.rpc("close");
  }
  closeSync() {
    this._throwNoSync("close");
  }
  sync() {
    return this.rpc("sync");
  }
  syncSync() {
    this._throwNoSync("sync");
  }
};
var PortFS = class extends Async(FileSystem) {
  /**
   * Constructs a new PortFS instance that connects with the FS running on `options.port`.
   */
  constructor(options) {
    super();
    this.options = options;
    this._sync = InMemory.create({ name: "port-tmpfs" });
    this.port = options.port;
    attach(this.port, handleResponse);
  }
  metadata() {
    return {
      ...super.metadata(),
      name: "PortFS"
    };
  }
  rpc(method, ...args) {
    return request({
      scope: "fs",
      method,
      args
    }, { ...this.options, fs: this });
  }
  async ready() {
    await this.rpc("ready");
    await super.ready();
  }
  rename(oldPath, newPath) {
    return this.rpc("rename", oldPath, newPath);
  }
  async stat(path) {
    return new Stats(await this.rpc("stat", path));
  }
  sync(path, data, stats2) {
    return this.rpc("sync", path, data, stats2);
  }
  openFile(path, flag) {
    return this.rpc("openFile", path, flag);
  }
  createFile(path, flag, mode, options) {
    return this.rpc("createFile", path, flag, mode, options);
  }
  unlink(path) {
    return this.rpc("unlink", path);
  }
  rmdir(path) {
    return this.rpc("rmdir", path);
  }
  mkdir(path, mode, options) {
    return this.rpc("mkdir", path, mode, options);
  }
  readdir(path) {
    return this.rpc("readdir", path);
  }
  exists(path) {
    return this.rpc("exists", path);
  }
  link(srcpath, dstpath) {
    return this.rpc("link", srcpath, dstpath);
  }
};
var nextFd2 = 0;
var descriptors = /* @__PURE__ */ new Map();
async function handleRequest(port, fs, request2) {
  if (!isMessage(request2)) {
    return;
  }
  const { method, args, id, scope, stack } = request2;
  let value, error = false;
  try {
    switch (scope) {
      case "fs":
        value = await fs[method](...args);
        if (value instanceof File) {
          descriptors.set(++nextFd2, value);
          value = {
            fd: nextFd2,
            path: value.path,
            position: value.position
          };
        }
        break;
      case "file": {
        const { fd } = request2;
        if (!descriptors.has(fd)) {
          throw new ErrnoError(Errno.EBADF);
        }
        value = await descriptors.get(fd)[method](...args);
        if (method == "close") {
          descriptors.delete(fd);
        }
        break;
      }
      default:
        return;
    }
  } catch (e) {
    value = e instanceof ErrnoError ? e.toJSON() : e.toString();
    error = true;
  }
  port.postMessage({ _zenfs: true, scope, id, error, method, stack, value });
}
function attachFS(port, fs) {
  attach(port, (request2) => handleRequest(port, fs, request2));
}
function detachFS(port, fs) {
  detach(port, (request2) => handleRequest(port, fs, request2));
}
var _Port = {
  name: "Port",
  options: {
    port: {
      type: "object",
      required: true,
      validator(port) {
        if (typeof (port === null || port === void 0 ? void 0 : port.postMessage) != "function") {
          throw new ErrnoError(Errno.EINVAL, "option must be a port.");
        }
      }
    },
    timeout: { type: "number", required: false }
  },
  create(options) {
    return new PortFS(options);
  }
};
var Port = _Port;
async function resolveRemoteMount(port, config2, _depth = 0) {
  const stopAndReplay = catchMessages(port);
  const fs = await resolveMountConfig(config2, _depth);
  attachFS(port, fs);
  stopAndReplay(fs);
  return fs;
}

// node_modules/@zenfs/core/dist/mixins/sync.js
function Sync(FS) {
  class SyncFS extends FS {
    async exists(path) {
      return this.existsSync(path);
    }
    async rename(oldPath, newPath) {
      return this.renameSync(oldPath, newPath);
    }
    async stat(path) {
      return this.statSync(path);
    }
    async createFile(path, flag, mode, options) {
      return this.createFileSync(path, flag, mode, options);
    }
    async openFile(path, flag) {
      return this.openFileSync(path, flag);
    }
    async unlink(path) {
      return this.unlinkSync(path);
    }
    async rmdir(path) {
      return this.rmdirSync(path);
    }
    async mkdir(path, mode, options) {
      return this.mkdirSync(path, mode, options);
    }
    async readdir(path) {
      return this.readdirSync(path);
    }
    async link(srcpath, dstpath) {
      return this.linkSync(srcpath, dstpath);
    }
    async sync(path, data, stats2) {
      return this.syncSync(path, data, stats2);
    }
  }
  return SyncFS;
}

// node_modules/@zenfs/core/dist/index.js
var dist_default = vfs_exports;
globalThis.__zenfs__ = vfs_exports;

export {
  Errno,
  errorMessages,
  ErrnoError,
  isBackend,
  checkOptions,
  isBackendConfig,
  credentials,
  createCredentials,
  useCredentials,
  constants_exports,
  StatsCommon,
  _chown,
  Stats,
  BigIntStats,
  isStatsEqual,
  ZenFsType,
  StatsFs,
  BigIntStatsFs,
  parseFlag,
  flagToString,
  flagToNumber,
  flagToMode,
  isReadable,
  isWriteable,
  isTruncating,
  isAppendable,
  isSynchronous,
  isExclusive,
  File,
  PreloadFile,
  NoSyncFile,
  FileSystem,
  Readonly,
  join,
  dirname,
  basename,
  encodeRaw,
  decodeRaw,
  encodeUTF8,
  decodeUTF8,
  decodeDirListing,
  encodeDirListing,
  normalizeMode,
  normalizeTime,
  normalizePath,
  normalizeOptions,
  randomBigInt,
  version,
  Index,
  IndexFS,
  FetchFS,
  Fetch,
  rootIno,
  Inode,
  StoreFS,
  Transaction,
  SyncTransaction,
  AsyncTransaction,
  SimpleAsyncStore,
  SimpleTransaction,
  InMemoryStore,
  InMemory,
  MutexLock,
  _MutexedFS,
  Mutexed,
  UnmutexedOverlayFS,
  OverlayFS,
  Overlay,
  PassthroughFS,
  Passthrough,
  DeviceFile,
  DeviceFS,
  nullDevice,
  zeroDevice,
  fullDevice,
  randomDevice,
  devices,
  bindContext,
  mounts,
  mount,
  umount,
  mountObject,
  chroot,
  renameSync,
  existsSync,
  statSync,
  lstatSync,
  truncateSync,
  unlinkSync,
  openSync,
  lopenSync,
  readFileSync,
  writeFileSync,
  appendFileSync,
  fstatSync,
  closeSync,
  ftruncateSync,
  fsyncSync,
  fdatasyncSync,
  writeSync,
  readSync,
  fchownSync,
  fchmodSync,
  futimesSync,
  rmdirSync,
  mkdirSync,
  readdirSync,
  linkSync,
  symlinkSync,
  readlinkSync,
  chownSync,
  lchownSync,
  chmodSync,
  lchmodSync,
  utimesSync,
  lutimesSync,
  realpathSync,
  accessSync,
  rmSync,
  mkdtempSync,
  copyFileSync,
  readvSync,
  writevSync,
  opendirSync,
  cpSync,
  statfsSync,
  globSync,
  Dirent,
  Dir,
  ReadStream,
  WriteStream,
  promises_exports,
  rename2 as rename,
  exists2 as exists,
  stat2 as stat,
  lstat2 as lstat,
  truncate2 as truncate,
  unlink2 as unlink,
  open2 as open,
  readFile2 as readFile,
  writeFile2 as writeFile,
  appendFile2 as appendFile,
  fstat,
  close,
  ftruncate,
  fsync,
  fdatasync,
  write,
  read,
  fchown,
  fchmod,
  futimes,
  rmdir2 as rmdir,
  mkdir2 as mkdir,
  readdir2 as readdir,
  link2 as link,
  symlink2 as symlink,
  readlink2 as readlink,
  chown2 as chown,
  lchown2 as lchown,
  chmod2 as chmod,
  lchmod2 as lchmod,
  utimes2 as utimes,
  lutimes2 as lutimes,
  realpath2 as realpath,
  access2 as access,
  watchFile,
  unwatchFile,
  watch2 as watch,
  createReadStream,
  createWriteStream,
  rm2 as rm,
  mkdtemp2 as mkdtemp,
  copyFile2 as copyFile,
  readv,
  writev,
  opendir2 as opendir,
  cp2 as cp,
  statfs2 as statfs,
  openAsBlob,
  glob2 as glob,
  vfs_exports,
  resolveMountConfig,
  configureSingle,
  addDevice,
  configure,
  Async,
  PortFile,
  PortFS,
  handleRequest,
  attachFS,
  detachFS,
  Port,
  resolveRemoteMount,
  Sync,
  dist_default
};
/*! Bundled license information:

safe-buffer/index.js:
  (*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)
*/
//# sourceMappingURL=chunk-HW2WK2AC.js.map
