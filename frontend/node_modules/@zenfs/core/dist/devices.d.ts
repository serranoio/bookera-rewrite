import type { FileReadResult } from 'node:fs/promises';
import { InMemoryStore } from '@zenfs/core/backends/memory.js';
import { StoreFS } from '@zenfs/core/backends/store/fs.js';
import { File } from '@zenfs/core/file.js';
import type { StatsLike } from '@zenfs/core/stats.js';
import { Stats } from '@zenfs/core/stats.js';
/**
 * A device
 * @todo Maybe add some other device information, like a UUID?
 * @privateRemarks
 * UUIDs were considered, however they don't make sense without an easy mechanism for persistence
 */
export interface Device<TData = any> {
    /**
     * The device's driver
     */
    driver: DeviceDriver;
    /**
     * Which inode the device is assigned
     */
    ino: bigint;
    /**
     * Data associated with a device.
     * This is meant to be used by device drivers.
     */
    data: TData;
    /**
     * Major device number
     */
    major: number;
    /**
     * Minor device number
     */
    minor: number;
}
/**
 * A device driver
 */
export interface DeviceDriver<TData = any> {
    /**
     * The name of the device driver
     */
    name: string;
    /**
     * If true, only a single device can exist per device FS.
     * Note that if this is unset or false, auto-named devices will have a number suffix
     */
    singleton?: boolean;
    /**
     * Whether the device is buffered (a "block" device) or unbuffered (a "character" device)
     * @default false
     */
    isBuffered?: boolean;
    /**
     * Initializes a new device.
     * @returns `Device.data`
     */
    init?(ino: bigint, options: object): {
        data?: TData;
        minor?: number;
        major?: number;
        name?: string;
    };
    /**
     * Synchronously read from the device
     * @group File operations
     */
    read(file: DeviceFile<TData>, buffer: ArrayBufferView, offset?: number, length?: number, position?: number): number;
    /**
     * Synchronously write to the device
     * @group File operations
     */
    write(file: DeviceFile<TData>, buffer: Uint8Array, offset: number, length: number, position?: number): number;
    /**
     * Sync the device
     * @group File operations
     */
    sync?(file: DeviceFile<TData>): void;
    /**
     * Close the device
     * @group File operations
     */
    close?(file: DeviceFile<TData>): void;
}
/**
 * The base class for device files
 * This class only does some simple things:
 * It implements `truncate` using `write` and it has non-device methods throw.
 * It is up to device drivers to implement the rest of the functionality.
 */
export declare class DeviceFile<TData = any> extends File {
    fs: DeviceFS;
    readonly device: Device<TData>;
    position: number;
    constructor(fs: DeviceFS, path: string, device: Device<TData>);
    get driver(): DeviceDriver<TData>;
    protected get stats(): Partial<StatsLike>;
    stat(): Promise<Stats>;
    statSync(): Stats;
    readSync(buffer: ArrayBufferView, offset?: number, length?: number, position?: number): number;
    read<TBuffer extends NodeJS.ArrayBufferView>(buffer: TBuffer, offset?: number, length?: number): Promise<FileReadResult<TBuffer>>;
    writeSync(buffer: Uint8Array, offset?: number, length?: number, position?: number): number;
    write(buffer: Uint8Array, offset?: number, length?: number, position?: number): Promise<number>;
    truncate(length: number): Promise<void>;
    truncateSync(length: number): void;
    closeSync(): void;
    close(): Promise<void>;
    syncSync(): void;
    sync(): Promise<void>;
    chown(): Promise<void>;
    chownSync(): void;
    chmod(): Promise<void>;
    chmodSync(): void;
    utimes(): Promise<void>;
    utimesSync(): void;
    _setType(): Promise<void>;
    _setTypeSync(): void;
}
/**
 * A temporary file system that manages and interfaces with devices
 */
export declare class DeviceFS extends StoreFS<InMemoryStore> {
    protected readonly devices: Map<string, Device<any>>;
    /**
     * Creates a new device at `path` relative to the `DeviceFS` root.
     * @deprecated
     */
    createDevice<TData = any>(path: string, driver: DeviceDriver<TData>, options?: object): Device<TData | Record<string, never>>;
    protected devicesWithDriver(driver: DeviceDriver<unknown> | string, forceIdentity?: boolean): Device[];
    /**
     * @internal
     */
    _createDevice<TData = any>(driver: DeviceDriver<TData>, options?: object): Device<TData | Record<string, never>>;
    /**
     * Adds default devices
     */
    addDefaults(): void;
    constructor();
    rename(oldPath: string, newPath: string): Promise<void>;
    renameSync(oldPath: string, newPath: string): void;
    stat(path: string): Promise<Stats>;
    statSync(path: string): Stats;
    openFile(path: string, flag: string): Promise<File>;
    openFileSync(path: string, flag: string): File;
    createFile(path: string, flag: string, mode: number): Promise<File>;
    createFileSync(path: string, flag: string, mode: number): File;
    unlink(path: string): Promise<void>;
    unlinkSync(path: string): void;
    rmdir(path: string): Promise<void>;
    rmdirSync(path: string): void;
    mkdir(path: string, mode: number): Promise<void>;
    mkdirSync(path: string, mode: number): void;
    readdir(path: string): Promise<string[]>;
    readdirSync(path: string): string[];
    link(target: string, link: string): Promise<void>;
    linkSync(target: string, link: string): void;
    sync(path: string, data: Uint8Array, stats: Readonly<Stats>): Promise<void>;
    syncSync(path: string, data: Uint8Array, stats: Readonly<Stats>): void;
}
/**
 * Simulates the `/dev/null` device.
 * - Reads return 0 bytes (EOF).
 * - Writes discard data, advancing the file position.
 * @internal
 */
export declare const nullDevice: DeviceDriver;
/**
 * Simulates the `/dev/zero` device
 * Provides an infinite stream of zeroes when read.
 * Discards any data written to it.
 *
 * - Reads fill the buffer with zeroes.
 * - Writes discard data but update the file position.
 * - Provides basic file metadata, treating it as a character device.
 * @internal
 */
export declare const zeroDevice: DeviceDriver;
/**
 * Simulates the `/dev/full` device.
 * - Reads behave like `/dev/zero` (returns zeroes).
 * - Writes always fail with ENOSPC (no space left on device).
 * @internal
 */
export declare const fullDevice: DeviceDriver;
/**
 * Simulates the `/dev/random` device.
 * - Reads return random bytes.
 * - Writes discard data, advancing the file position.
 * @internal
 */
export declare const randomDevice: DeviceDriver;
/**
 * Shortcuts for importing.
 */
export declare const devices: {
    null: DeviceDriver<any>;
    zero: DeviceDriver<any>;
    full: DeviceDriver<any>;
    random: DeviceDriver<any>;
    console: DeviceDriver<{
        output: (text: string) => unknown;
    }>;
};
