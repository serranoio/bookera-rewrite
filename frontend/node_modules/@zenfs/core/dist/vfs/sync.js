var __addDisposableResource = (this && this.__addDisposableResource) || function (env, value, async) {
    if (value !== null && value !== void 0) {
        if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
        var dispose, inner;
        if (async) {
            if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
            dispose = value[Symbol.asyncDispose];
        }
        if (dispose === void 0) {
            if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
            dispose = value[Symbol.dispose];
            if (async) inner = dispose;
        }
        if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
        if (inner) dispose = function() { try { inner.call(this); } catch (e) { return Promise.reject(e); } };
        env.stack.push({ value: value, dispose: dispose, async: async });
    }
    else if (async) {
        env.stack.push({ async: true });
    }
    return value;
};
var __disposeResources = (this && this.__disposeResources) || (function (SuppressedError) {
    return function (env) {
        function fail(e) {
            env.error = env.hasError ? new SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
            env.hasError = true;
        }
        var r, s = 0;
        function next() {
            while (r = env.stack.pop()) {
                try {
                    if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);
                    if (r.dispose) {
                        var result = r.dispose.call(r.value);
                        if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) { fail(e); return next(); });
                    }
                    else s |= 1;
                }
                catch (e) {
                    fail(e);
                }
            }
            if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
            if (env.hasError) throw env.error;
        }
        return next();
    };
})(typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
});
import { deleteFD, fromFD, SyncHandle, toFD } from './file.js';
import { Stats } from './stats.js';
import { Buffer } from 'buffer';
import { decodeUTF8, encodeUTF8 } from 'utilium';
import { defaultContext } from '../internal/contexts.js';
import { Errno, ErrnoError } from '../internal/error.js';
import { hasAccess, isDirectory, isSymbolicLink } from '../internal/inode.js';
import { dirname, join, parse, resolve } from '../path.js';
import { normalizeMode, normalizeOptions, normalizePath, normalizeTime } from '../utils.js';
import { checkAccess } from './config.js';
import * as constants from './constants.js';
import { Dir, Dirent } from './dir.js';
import * as flags from './flags.js';
import { _statfs, fixError, resolveMount } from './shared.js';
import { BigIntStats } from './stats.js';
import { emitChange } from './watchers.js';
export function renameSync(oldPath, newPath) {
    oldPath = normalizePath(oldPath);
    newPath = normalizePath(newPath);
    const oldMount = resolveMount(oldPath, this);
    const newMount = resolveMount(newPath, this);
    if (checkAccess && !statSync.call(this, dirname(oldPath)).hasAccess(constants.W_OK, this)) {
        throw ErrnoError.With('EACCES', oldPath, 'rename');
    }
    try {
        if (oldMount === newMount) {
            oldMount.fs.renameSync(oldMount.path, newMount.path);
            emitChange(this, 'rename', oldPath.toString());
            emitChange(this, 'change', newPath.toString());
            return;
        }
        writeFileSync.call(this, newPath, readFileSync(oldPath));
        unlinkSync.call(this, oldPath);
        emitChange(this, 'rename', oldPath.toString());
    }
    catch (e) {
        throw fixError(e, { [oldMount.path]: oldPath, [newMount.path]: newPath });
    }
}
renameSync;
/**
 * Test whether or not `path` exists by checking with the file system.
 */
export function existsSync(path) {
    path = normalizePath(path);
    try {
        const { fs, path: resolvedPath } = resolveMount(realpathSync.call(this, path), this);
        return fs.existsSync(resolvedPath);
    }
    catch (e) {
        if (e.errno == Errno.ENOENT) {
            return false;
        }
        throw e;
    }
}
existsSync;
export function statSync(path, options) {
    path = normalizePath(path);
    const { fs, path: resolved } = resolveMount(realpathSync.call(this, path), this);
    try {
        const stats = fs.statSync(resolved);
        if (checkAccess && !hasAccess(this, stats, constants.R_OK)) {
            throw ErrnoError.With('EACCES', resolved, 'stat');
        }
        return (options === null || options === void 0 ? void 0 : options.bigint) ? new BigIntStats(stats) : new Stats(stats);
    }
    catch (e) {
        throw fixError(e, { [resolved]: path });
    }
}
statSync;
export function lstatSync(path, options) {
    path = normalizePath(path);
    const { fs, path: resolved } = resolveMount(path, this);
    try {
        const stats = fs.statSync(resolved);
        if (checkAccess && !hasAccess(this, stats, constants.R_OK)) {
            throw ErrnoError.With('EACCES', resolved, 'lstat');
        }
        return (options === null || options === void 0 ? void 0 : options.bigint) ? new BigIntStats(stats) : new Stats(stats);
    }
    catch (e) {
        throw fixError(e, { [resolved]: path });
    }
}
lstatSync;
export function truncateSync(path, len = 0) {
    const env_1 = { stack: [], error: void 0, hasError: false };
    try {
        const file = __addDisposableResource(env_1, _openSync.call(this, path, { flag: 'r+' }), false);
        len || (len = 0);
        if (len < 0) {
            throw new ErrnoError(Errno.EINVAL);
        }
        file.truncate(len);
    }
    catch (e_1) {
        env_1.error = e_1;
        env_1.hasError = true;
    }
    finally {
        __disposeResources(env_1);
    }
}
truncateSync;
export function unlinkSync(path) {
    path = normalizePath(path);
    const { fs, path: resolved } = resolveMount(path, this);
    try {
        if (checkAccess && !hasAccess(this, fs.statSync(resolved), constants.W_OK)) {
            throw ErrnoError.With('EACCES', resolved, 'unlink');
        }
        fs.unlinkSync(resolved);
        emitChange(this, 'rename', path.toString());
    }
    catch (e) {
        throw fixError(e, { [resolved]: path });
    }
}
unlinkSync;
function _openSync(path, opt) {
    var _a;
    path = normalizePath(path);
    const mode = normalizeMode(opt.mode, 0o644), flag = flags.parse(opt.flag);
    path = opt.preserveSymlinks ? path : realpathSync.call(this, path);
    const { fs, path: resolved } = resolveMount(path, this);
    let stats;
    try {
        stats = fs.statSync(resolved);
    }
    catch {
        // nothing
    }
    if (!stats) {
        if (!(flag & constants.O_CREAT)) {
            throw ErrnoError.With('ENOENT', path, '_open');
        }
        // Create the file
        const parentStats = fs.statSync(dirname(resolved));
        if (checkAccess && !hasAccess(this, parentStats, constants.W_OK)) {
            throw ErrnoError.With('EACCES', dirname(path), '_open');
        }
        if (!isDirectory(parentStats)) {
            throw ErrnoError.With('ENOTDIR', dirname(path), '_open');
        }
        if (!opt.allowDirectory && mode & constants.S_IFDIR)
            throw ErrnoError.With('EISDIR', path, '_open');
        if (checkAccess && !hasAccess(this, parentStats, constants.W_OK)) {
            throw ErrnoError.With('EACCES', dirname(resolved), '_open');
        }
        const { euid: uid, egid: gid } = (_a = this === null || this === void 0 ? void 0 : this.credentials) !== null && _a !== void 0 ? _a : defaultContext.credentials;
        const inode = fs.createFileSync(resolved, {
            mode,
            uid: parentStats.mode & constants.S_ISUID ? parentStats.uid : uid,
            gid: parentStats.mode & constants.S_ISGID ? parentStats.gid : gid,
        });
        return new SyncHandle(this, path, fs, resolved, flag, inode);
    }
    if (checkAccess && (!hasAccess(this, stats, mode) || !hasAccess(this, stats, flags.toMode(flag)))) {
        throw ErrnoError.With('EACCES', path, '_open');
    }
    if (flag & constants.O_EXCL)
        throw ErrnoError.With('EEXIST', path, '_open');
    const file = new SyncHandle(this, path, fs, resolved, flag, stats);
    if (flag & constants.O_TRUNC)
        file.truncate(0);
    if (!opt.allowDirectory && stats.mode & constants.S_IFDIR)
        throw ErrnoError.With('EISDIR', path, '_open');
    return file;
}
/**
 * Synchronous file open.
 * @see https://nodejs.org/api/fs.html#fsopensyncpath-flags-mode
 * @param flag {@link https://nodejs.org/api/fs.html#file-system-flags}
 */
export function openSync(path, flag, mode = constants.F_OK) {
    return toFD(_openSync.call(this, path, { flag, mode }));
}
openSync;
/**
 * Opens a file or symlink
 * @internal
 */
export function lopenSync(path, flag, mode) {
    return toFD(_openSync.call(this, path, { flag, mode, preserveSymlinks: true }));
}
function _readFileSync(path, flag, preserveSymlinks) {
    const env_2 = { stack: [], error: void 0, hasError: false };
    try {
        const file = __addDisposableResource(env_2, typeof path == 'number' ? fromFD(this, path) : _openSync.call(this, path.toString(), { flag, mode: 0o644, preserveSymlinks }), false);
        const { size } = file.stat();
        const data = new Uint8Array(size);
        file.read(data, 0, size, 0);
        return data;
    }
    catch (e_2) {
        env_2.error = e_2;
        env_2.hasError = true;
    }
    finally {
        __disposeResources(env_2);
    }
}
export function readFileSync(path, _options = {}) {
    const options = normalizeOptions(_options, null, 'r', 0o644);
    const flag = flags.parse(options.flag);
    if (flag & constants.O_WRONLY) {
        throw new ErrnoError(Errno.EINVAL, 'Flag passed to readFile must allow for reading');
    }
    const data = Buffer.from(_readFileSync.call(this, path, options.flag, false));
    return options.encoding ? data.toString(options.encoding) : data;
}
readFileSync;
export function writeFileSync(path, data, _options = {}) {
    const env_3 = { stack: [], error: void 0, hasError: false };
    try {
        const options = normalizeOptions(_options, 'utf8', 'w+', 0o644);
        const flag = flags.parse(options.flag);
        if (!(flag & constants.O_WRONLY || flag & constants.O_RDWR)) {
            throw new ErrnoError(Errno.EINVAL, 'Flag passed to writeFile must allow for writing');
        }
        if (typeof data != 'string' && !options.encoding) {
            throw new ErrnoError(Errno.EINVAL, 'Encoding not specified');
        }
        const encodedData = typeof data == 'string' ? Buffer.from(data, options.encoding) : new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
        if (!encodedData) {
            throw new ErrnoError(Errno.EINVAL, 'Data not specified');
        }
        const file = __addDisposableResource(env_3, typeof path == 'number'
            ? fromFD(this, path)
            : _openSync.call(this, path.toString(), {
                flag,
                mode: options.mode,
                preserveSymlinks: true,
            }), false);
        file.write(encodedData, 0, encodedData.byteLength, 0);
        emitChange(this, 'change', path.toString());
    }
    catch (e_3) {
        env_3.error = e_3;
        env_3.hasError = true;
    }
    finally {
        __disposeResources(env_3);
    }
}
writeFileSync;
/**
 * Asynchronously append data to a file, creating the file if it not yet exists.
 * @option encoding Defaults to `'utf8'`.
 * @option mode Defaults to `0644`.
 * @option flag Defaults to `'a+'`.
 */
export function appendFileSync(filename, data, _options = {}) {
    const env_4 = { stack: [], error: void 0, hasError: false };
    try {
        const options = normalizeOptions(_options, 'utf8', 'a+', 0o644);
        const flag = flags.parse(options.flag);
        if (!(flag & constants.O_APPEND)) {
            throw new ErrnoError(Errno.EINVAL, 'Flag passed to appendFile must allow for appending');
        }
        if (typeof data != 'string' && !options.encoding) {
            throw new ErrnoError(Errno.EINVAL, 'Encoding not specified');
        }
        const encodedData = typeof data == 'string' ? Buffer.from(data, options.encoding) : new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
        const file = __addDisposableResource(env_4, _openSync.call(this, typeof filename == 'number' ? fromFD(this, filename).path : filename.toString(), {
            flag,
            mode: options.mode,
            preserveSymlinks: true,
        }), false);
        file.write(encodedData, 0, encodedData.byteLength);
    }
    catch (e_4) {
        env_4.error = e_4;
        env_4.hasError = true;
    }
    finally {
        __disposeResources(env_4);
    }
}
appendFileSync;
export function fstatSync(fd, options) {
    const stats = fromFD(this, fd).stat();
    return (options === null || options === void 0 ? void 0 : options.bigint) ? new BigIntStats(stats) : new Stats(stats);
}
fstatSync;
export function closeSync(fd) {
    fromFD(this, fd).close();
    deleteFD(this, fd);
}
closeSync;
export function ftruncateSync(fd, len = 0) {
    len || (len = 0);
    if (len < 0) {
        throw new ErrnoError(Errno.EINVAL);
    }
    fromFD(this, fd).truncate(len);
}
ftruncateSync;
export function fsyncSync(fd) {
    fromFD(this, fd).sync();
}
fsyncSync;
export function fdatasyncSync(fd) {
    fromFD(this, fd).datasync();
}
fdatasyncSync;
export function writeSync(fd, data, posOrOff, lenOrEnc, pos) {
    let buffer, offset, length, position;
    if (typeof data === 'string') {
        // Signature 1: (fd, string, [position?, [encoding?]])
        position = typeof posOrOff === 'number' ? posOrOff : null;
        const encoding = typeof lenOrEnc === 'string' ? lenOrEnc : 'utf8';
        offset = 0;
        buffer = Buffer.from(data, encoding);
        length = buffer.byteLength;
    }
    else {
        // Signature 2: (fd, buffer, offset, length, position?)
        buffer = new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
        offset = posOrOff;
        length = lenOrEnc;
        position = typeof pos === 'number' ? pos : null;
    }
    const file = fromFD(this, fd);
    position !== null && position !== void 0 ? position : (position = file.position);
    const bytesWritten = file.write(buffer, offset, length, position);
    emitChange(this, 'change', file.path);
    return bytesWritten;
}
writeSync;
/**
 * Read data from the file specified by `fd`.
 * @param buffer The buffer that the data will be written to.
 * @param offset The offset within the buffer where writing will start.
 * @param length An integer specifying the number of bytes to read.
 * @param position An integer specifying where to begin reading from in the file.
 * If position is null, data will be read from the current file position.
 */
export function readSync(fd, buffer, options, length, position) {
    const file = fromFD(this, fd);
    const offset = typeof options == 'object' ? options.offset : options;
    if (typeof options == 'object') {
        length = options.length;
        position = options.position;
    }
    position = Number(position);
    if (isNaN(position)) {
        position = file.position;
    }
    return file.read(buffer, offset, length, position);
}
readSync;
export function fchownSync(fd, uid, gid) {
    fromFD(this, fd).chown(uid, gid);
}
fchownSync;
export function fchmodSync(fd, mode) {
    const numMode = normalizeMode(mode, -1);
    if (numMode < 0) {
        throw new ErrnoError(Errno.EINVAL, `Invalid mode.`);
    }
    fromFD(this, fd).chmod(numMode);
}
fchmodSync;
/**
 * Change the file timestamps of a file referenced by the supplied file descriptor.
 */
export function futimesSync(fd, atime, mtime) {
    fromFD(this, fd).utimes(normalizeTime(atime), normalizeTime(mtime));
}
futimesSync;
export function rmdirSync(path) {
    path = normalizePath(path);
    const { fs, path: resolved } = resolveMount(realpathSync.call(this, path), this);
    try {
        const stats = fs.statSync(resolved);
        if (!isDirectory(stats)) {
            throw ErrnoError.With('ENOTDIR', resolved, 'rmdir');
        }
        if (checkAccess && !hasAccess(this, stats, constants.W_OK)) {
            throw ErrnoError.With('EACCES', resolved, 'rmdir');
        }
        fs.rmdirSync(resolved);
        emitChange(this, 'rename', path.toString());
    }
    catch (e) {
        throw fixError(e, { [resolved]: path });
    }
}
rmdirSync;
export function mkdirSync(path, options) {
    var _a, _b;
    const { euid: uid, egid: gid } = (_a = this === null || this === void 0 ? void 0 : this.credentials) !== null && _a !== void 0 ? _a : defaultContext.credentials;
    options = typeof options === 'object' ? options : { mode: options };
    const mode = normalizeMode(options === null || options === void 0 ? void 0 : options.mode, 0o777);
    path = realpathSync.call(this, path);
    const { fs, path: resolved, root } = resolveMount(path, this);
    const errorPaths = { [resolved]: path };
    const __create = (path, parent) => {
        if (checkAccess && !hasAccess(this, parent, constants.W_OK)) {
            throw ErrnoError.With('EACCES', dirname(path), 'mkdir');
        }
        const inode = fs.mkdirSync(path, {
            mode,
            uid: parent.mode & constants.S_ISUID ? parent.uid : uid,
            gid: parent.mode & constants.S_ISGID ? parent.gid : gid,
        });
        emitChange(this, 'rename', path);
        return inode;
    };
    try {
        if (!(options === null || options === void 0 ? void 0 : options.recursive)) {
            __create(resolved, fs.statSync(dirname(resolved)));
            return;
        }
        const dirs = [];
        for (let dir = resolved, original = path; !fs.existsSync(dir); dir = dirname(dir), original = dirname(original)) {
            dirs.unshift(dir);
            errorPaths[dir] = original;
        }
        if (!dirs.length)
            return;
        const stats = [fs.statSync(dirname(dirs[0]))];
        for (const [i, dir] of dirs.entries()) {
            stats.push(__create(dir, stats[i]));
        }
        return root.length == 1 ? dirs[0] : (_b = dirs[0]) === null || _b === void 0 ? void 0 : _b.slice(root.length);
    }
    catch (e) {
        throw fixError(e, errorPaths);
    }
}
mkdirSync;
export function readdirSync(path, options) {
    options = typeof options === 'object' ? options : { encoding: options };
    path = normalizePath(path);
    const { fs, path: resolved } = resolveMount(realpathSync.call(this, path), this);
    let entries;
    try {
        const stats = fs.statSync(resolved);
        if (checkAccess && !hasAccess(this, stats, constants.R_OK)) {
            throw ErrnoError.With('EACCES', resolved, 'readdir');
        }
        if (!isDirectory(stats)) {
            throw ErrnoError.With('ENOTDIR', resolved, 'readdir');
        }
        entries = fs.readdirSync(resolved);
    }
    catch (e) {
        throw fixError(e, { [resolved]: path });
    }
    // Iterate over entries and handle recursive case if needed
    const values = [];
    for (const entry of entries) {
        let entryStat;
        try {
            entryStat = fs.statSync(join(resolved, entry));
        }
        catch {
            continue;
        }
        if (options === null || options === void 0 ? void 0 : options.withFileTypes) {
            values.push(new Dirent(entry, entryStat));
        }
        else if ((options === null || options === void 0 ? void 0 : options.encoding) == 'buffer') {
            values.push(Buffer.from(entry));
        }
        else {
            values.push(entry);
        }
        if (!isDirectory(entryStat) || !(options === null || options === void 0 ? void 0 : options.recursive))
            continue;
        for (const subEntry of readdirSync.call(this, join(path, entry), options)) {
            if (subEntry instanceof Dirent) {
                subEntry.path = join(entry, subEntry.path);
                values.push(subEntry);
            }
            else if (Buffer.isBuffer(subEntry)) {
                values.push(Buffer.from(join(entry, decodeUTF8(subEntry))));
            }
            else {
                values.push(join(entry, subEntry));
            }
        }
    }
    return values;
}
readdirSync;
export function linkSync(targetPath, linkPath) {
    targetPath = normalizePath(targetPath);
    if (checkAccess && !statSync(dirname(targetPath)).hasAccess(constants.R_OK, this)) {
        throw ErrnoError.With('EACCES', dirname(targetPath), 'link');
    }
    linkPath = normalizePath(linkPath);
    if (checkAccess && !statSync(dirname(linkPath)).hasAccess(constants.W_OK, this)) {
        throw ErrnoError.With('EACCES', dirname(linkPath), 'link');
    }
    const { fs, path } = resolveMount(targetPath, this);
    const link = resolveMount(linkPath, this);
    if (fs != link.fs) {
        throw ErrnoError.With('EXDEV', linkPath, 'link');
    }
    try {
        if (checkAccess && !hasAccess(this, fs.statSync(path), constants.R_OK)) {
            throw ErrnoError.With('EACCES', path, 'link');
        }
        return fs.linkSync(path, link.path);
    }
    catch (e) {
        throw fixError(e, { [path]: targetPath, [link.path]: linkPath });
    }
}
linkSync;
/**
 * Synchronous `symlink`.
 * @param target target path
 * @param path link path
 * @param type can be either `'dir'` or `'file'` (default is `'file'`)
 */
export function symlinkSync(target, path, type = 'file') {
    const env_5 = { stack: [], error: void 0, hasError: false };
    try {
        if (!['file', 'dir', 'junction'].includes(type)) {
            throw new ErrnoError(Errno.EINVAL, 'Invalid type: ' + type);
        }
        path = normalizePath(path);
        const file = __addDisposableResource(env_5, _openSync.call(this, path, { flag: 'wx', mode: 0o644 }), false);
        file.write(encodeUTF8(normalizePath(target, true)));
        file.chmod(constants.S_IFLNK);
    }
    catch (e_5) {
        env_5.error = e_5;
        env_5.hasError = true;
    }
    finally {
        __disposeResources(env_5);
    }
}
symlinkSync;
export function readlinkSync(path, options) {
    const value = Buffer.from(_readFileSync.call(this, path, 'r', true));
    const encoding = typeof options == 'object' ? options === null || options === void 0 ? void 0 : options.encoding : options;
    if (encoding == 'buffer') {
        return value;
    }
    // always defaults to utf-8 to avoid wrangler (cloudflare) worker "unknown encoding" exception
    return value.toString(encoding !== null && encoding !== void 0 ? encoding : 'utf-8');
}
readlinkSync;
export function chownSync(path, uid, gid) {
    const fd = openSync.call(this, path, 'r+');
    fchownSync.call(this, fd, uid, gid);
    closeSync.call(this, fd);
}
chownSync;
export function lchownSync(path, uid, gid) {
    const fd = lopenSync.call(this, path, 'r+');
    fchownSync.call(this, fd, uid, gid);
    closeSync.call(this, fd);
}
lchownSync;
export function chmodSync(path, mode) {
    const fd = openSync.call(this, path, 'r+');
    fchmodSync.call(this, fd, mode);
    closeSync.call(this, fd);
}
chmodSync;
export function lchmodSync(path, mode) {
    const fd = lopenSync.call(this, path, 'r+');
    fchmodSync.call(this, fd, mode);
    closeSync.call(this, fd);
}
lchmodSync;
/**
 * Change file timestamps of the file referenced by the supplied path.
 */
export function utimesSync(path, atime, mtime) {
    const fd = openSync.call(this, path, 'r+');
    futimesSync.call(this, fd, atime, mtime);
    closeSync.call(this, fd);
}
utimesSync;
/**
 * Change file timestamps of the file referenced by the supplied path.
 */
export function lutimesSync(path, atime, mtime) {
    const fd = lopenSync.call(this, path, 'r+');
    futimesSync.call(this, fd, atime, mtime);
    closeSync.call(this, fd);
}
lutimesSync;
/**
 * Resolves the mount and real path for a path.
 * Additionally, any stats fetched will be returned for de-duplication
 * @internal @hidden
 */
function _resolveSync($, path, preserveSymlinks) {
    if (preserveSymlinks) {
        const resolved = resolveMount(path, $);
        const stats = resolved.fs.statSync(resolved.path);
        return { ...resolved, fullPath: path, stats };
    }
    /* Try to resolve it directly. If this works,
    that means we don't need to perform any resolution for parent directories. */
    try {
        const resolved = resolveMount(path, $);
        // Stat it to make sure it exists
        const stats = resolved.fs.statSync(resolved.path);
        if (!isSymbolicLink(stats)) {
            return { ...resolved, fullPath: path, stats };
        }
        const target = resolve.call($, dirname(path), readlinkSync.call($, path).toString());
        return _resolveSync($, target);
    }
    catch {
        // Go the long way
    }
    const { base, dir } = parse(path);
    const realDir = dir == '/' ? '/' : realpathSync.call($, dir);
    const maybePath = join(realDir, base);
    const resolved = resolveMount(maybePath, $);
    try {
        const stats = resolved.fs.statSync(resolved.path);
        if (!isSymbolicLink(stats)) {
            return { ...resolved, fullPath: maybePath, stats };
        }
        const target = resolve.call($, realDir, readlinkSync.call($, maybePath).toString());
        return _resolveSync($, target);
    }
    catch (e) {
        if (e.code == 'ENOENT') {
            return { ...resolved, fullPath: path };
        }
        throw fixError(e, { [resolved.path]: maybePath });
    }
}
export function realpathSync(path, options) {
    var _a;
    const encoding = typeof options == 'string' ? options : ((_a = options === null || options === void 0 ? void 0 : options.encoding) !== null && _a !== void 0 ? _a : 'utf8');
    path = normalizePath(path);
    const { fullPath } = _resolveSync(this, path);
    if (encoding == 'utf8' || encoding == 'utf-8')
        return fullPath;
    const buf = Buffer.from(fullPath, 'utf-8');
    if (encoding == 'buffer')
        return buf;
    return buf.toString(encoding);
}
realpathSync;
export function accessSync(path, mode = 0o600) {
    if (!checkAccess)
        return;
    if (!hasAccess(this, statSync.call(this, path), mode)) {
        throw new ErrnoError(Errno.EACCES);
    }
}
accessSync;
/**
 * Synchronous `rm`. Removes files or directories (recursively).
 * @param path The path to the file or directory to remove.
 */
export function rmSync(path, options) {
    path = normalizePath(path);
    let stats;
    try {
        stats = lstatSync.bind(this)(path);
    }
    catch (error) {
        if (error.code != 'ENOENT' || !(options === null || options === void 0 ? void 0 : options.force))
            throw error;
    }
    if (!stats)
        return;
    switch (stats.mode & constants.S_IFMT) {
        case constants.S_IFDIR:
            if (options === null || options === void 0 ? void 0 : options.recursive) {
                for (const entry of readdirSync.call(this, path)) {
                    rmSync.call(this, join(path, entry), options);
                }
            }
            rmdirSync.call(this, path);
            break;
        case constants.S_IFREG:
        case constants.S_IFLNK:
        case constants.S_IFBLK:
        case constants.S_IFCHR:
            unlinkSync.call(this, path);
            break;
        case constants.S_IFIFO:
        case constants.S_IFSOCK:
        default:
            throw new ErrnoError(Errno.EPERM, 'File type not supported', path, 'rm');
    }
}
rmSync;
export function mkdtempSync(prefix, options) {
    const encoding = typeof options === 'object' ? options === null || options === void 0 ? void 0 : options.encoding : options || 'utf8';
    const fsName = `${prefix}${Date.now()}-${Math.random().toString(36).slice(2)}`;
    const resolvedPath = '/tmp/' + fsName;
    mkdirSync.call(this, resolvedPath);
    return encoding == 'buffer' ? Buffer.from(resolvedPath) : resolvedPath;
}
mkdtempSync;
/**
 * Synchronous `copyFile`. Copies a file.
 * @param flags Optional flags for the copy operation. Currently supports these flags:
 * - `fs.constants.COPYFILE_EXCL`: If the destination file already exists, the operation fails.
 */
export function copyFileSync(source, destination, flags) {
    source = normalizePath(source);
    destination = normalizePath(destination);
    if (flags && flags & constants.COPYFILE_EXCL && existsSync(destination)) {
        throw new ErrnoError(Errno.EEXIST, 'Destination file already exists', destination, 'copyFile');
    }
    writeFileSync.call(this, destination, readFileSync(source));
    emitChange(this, 'rename', destination.toString());
}
copyFileSync;
/**
 * Synchronous `readv`. Reads from a file descriptor into multiple buffers.
 * @param fd The file descriptor.
 * @param buffers An array of Uint8Array buffers.
 * @param position The position in the file where to begin reading.
 * @returns The number of bytes read.
 */
export function readvSync(fd, buffers, position) {
    const file = fromFD(this, fd);
    let bytesRead = 0;
    for (const buffer of buffers) {
        bytesRead += file.read(buffer, 0, buffer.byteLength, position + bytesRead);
    }
    return bytesRead;
}
readvSync;
/**
 * Synchronous `writev`. Writes from multiple buffers into a file descriptor.
 * @param fd The file descriptor.
 * @param buffers An array of Uint8Array buffers.
 * @param position The position in the file where to begin writing.
 * @returns The number of bytes written.
 */
export function writevSync(fd, buffers, position) {
    const file = fromFD(this, fd);
    let bytesWritten = 0;
    for (const buffer of buffers) {
        bytesWritten += file.write(new Uint8Array(buffer.buffer), 0, buffer.byteLength, position + bytesWritten);
    }
    return bytesWritten;
}
writevSync;
/**
 * Synchronous `opendir`. Opens a directory.
 * @param path The path to the directory.
 * @param options Options for opening the directory.
 * @returns A `Dir` object representing the opened directory.
 * @todo Handle options
 */
export function opendirSync(path, options) {
    path = normalizePath(path);
    return new Dir(path, this);
}
opendirSync;
/**
 * Synchronous `cp`. Recursively copies a file or directory.
 * @param source The source file or directory.
 * @param destination The destination file or directory.
 * @param opts Options for the copy operation. Currently supports these options from Node.js 'fs.cpSync':
 * - `dereference`: Dereference symbolic links. *(unconfirmed)*
 * - `errorOnExist`: Throw an error if the destination file or directory already exists.
 * - `filter`: A function that takes a source and destination path and returns a boolean, indicating whether to copy `source` element.
 * - `force`: Overwrite the destination if it exists, and overwrite existing readonly destination files. *(unconfirmed)*
 * - `preserveTimestamps`: Preserve file timestamps.
 * - `recursive`: If `true`, copies directories recursively.
 */
export function cpSync(source, destination, opts) {
    source = normalizePath(source);
    destination = normalizePath(destination);
    const srcStats = lstatSync.call(this, source); // Use lstat to follow symlinks if not dereferencing
    if ((opts === null || opts === void 0 ? void 0 : opts.errorOnExist) && existsSync.call(this, destination)) {
        throw new ErrnoError(Errno.EEXIST, 'Destination file or directory already exists', destination, 'cp');
    }
    switch (srcStats.mode & constants.S_IFMT) {
        case constants.S_IFDIR:
            if (!(opts === null || opts === void 0 ? void 0 : opts.recursive)) {
                throw new ErrnoError(Errno.EISDIR, source + ' is a directory (not copied)', source, 'cp');
            }
            mkdirSync.call(this, destination, { recursive: true }); // Ensure the destination directory exists
            for (const dirent of readdirSync.call(this, source, { withFileTypes: true })) {
                if (opts.filter && !opts.filter(join(source, dirent.name), join(destination, dirent.name))) {
                    continue; // Skip if the filter returns false
                }
                cpSync.call(this, join(source, dirent.name), join(destination, dirent.name), opts);
            }
            break;
        case constants.S_IFREG:
        case constants.S_IFLNK:
            copyFileSync.call(this, source, destination);
            break;
        case constants.S_IFBLK:
        case constants.S_IFCHR:
        case constants.S_IFIFO:
        case constants.S_IFSOCK:
        default:
            throw new ErrnoError(Errno.EPERM, 'File type not supported', source, 'rm');
    }
    // Optionally preserve timestamps
    if (opts === null || opts === void 0 ? void 0 : opts.preserveTimestamps) {
        utimesSync.call(this, destination, srcStats.atime, srcStats.mtime);
    }
}
cpSync;
export function statfsSync(path, options) {
    path = normalizePath(path);
    const { fs } = resolveMount(path, this);
    return _statfs(fs, options === null || options === void 0 ? void 0 : options.bigint);
}
export function globSync(pattern, options = {}) {
    pattern = Array.isArray(pattern) ? pattern : [pattern];
    const { cwd = '/', withFileTypes = false, exclude = () => false } = options;
    // Escape special characters in pattern
    const regexPatterns = pattern.map(p => {
        p = p
            .replace(/([.?+^$(){}|[\]/])/g, '\\$1')
            .replace(/\*\*/g, '.*')
            .replace(/\*/g, '[^/]*')
            .replace(/\?/g, '.');
        return new RegExp(`^${p}$`);
    });
    const results = [];
    function recursiveList(dir) {
        const entries = readdirSync(dir, { withFileTypes, encoding: 'utf8' });
        for (const entry of entries) {
            const fullPath = withFileTypes ? entry.path : dir + '/' + entry;
            if (exclude((withFileTypes ? entry : fullPath)))
                continue;
            /**
             * @todo is the pattern.source check correct?
             */
            if (statSync(fullPath).isDirectory() && regexPatterns.some(pattern => pattern.source.includes('.*'))) {
                recursiveList(fullPath);
            }
            if (regexPatterns.some(pattern => pattern.test(fullPath.replace(/^\/+/g, '')))) {
                results.push(withFileTypes ? entry.path : fullPath.replace(/^\/+/g, ''));
            }
        }
    }
    recursiveList(cwd);
    return results;
}
globSync;
