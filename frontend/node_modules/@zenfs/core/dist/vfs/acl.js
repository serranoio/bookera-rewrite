var __esDecorate = (this && this.__esDecorate) || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for (var i = decorators.length - 1; i >= 0; i--) {
        var context = {};
        for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access) context.access[p] = contextIn.access[p];
        context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
            if (result === void 0) continue;
            if (result === null || typeof result !== "object") throw new TypeError("Object expected");
            if (_ = accept(result.get)) descriptor.get = _;
            if (_ = accept(result.set)) descriptor.set = _;
            if (_ = accept(result.init)) initializers.unshift(_);
        }
        else if (_ = accept(result)) {
            if (kind === "field") initializers.unshift(_);
            else descriptor[key] = _;
        }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
};
var __runInitializers = (this && this.__runInitializers) || function (thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i = 0; i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    }
    return useValue ? value : void 0;
};
var __setFunctionName = (this && this.__setFunctionName) || function (f, name, prefix) {
    if (typeof name === "symbol") name = name.description ? "[".concat(name.description, "]") : "";
    return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
};
/*
    Access Control Lists.
    At the moment, they are only intended for internal use.
    They also are not checked for permissions yet.
    Please use a namespace import for the best experience.
*/
import { assignWithDefaults, deserialize, serialize, sizeof, struct, types as t } from 'utilium';
import { defaultContext } from '../internal/contexts.js';
import { Errno, ErrnoError } from '../internal/error.js';
import { Attributes } from '../internal/inode.js';
import { err } from '../internal/log.js';
import { S_IRWXG, S_IRWXO, S_IRWXU, W_OK, X_OK, R_OK } from './constants.js';
import * as xattr from './xattr.js';
const version = 2;
export var Type;
(function (Type) {
    Type[Type["Access"] = 32768] = "Access";
    Type[Type["Default"] = 16384] = "Default";
})(Type || (Type = {}));
export var Tag;
(function (Tag) {
    Tag[Tag["UserObj"] = 1] = "UserObj";
    Tag[Tag["User"] = 2] = "User";
    Tag[Tag["GroupObj"] = 4] = "GroupObj";
    Tag[Tag["Group"] = 8] = "Group";
    Tag[Tag["Mask"] = 16] = "Mask";
    Tag[Tag["Other"] = 32] = "Other";
    /**
     * @internal @hidden
     */
    Tag[Tag["_None"] = 0] = "_None";
})(Tag || (Tag = {}));
let Entry = (() => {
    var _a, _b, _c;
    let _classDecorators = [struct()];
    let _classDescriptor;
    let _classExtraInitializers = [];
    let _classThis;
    let _tag_decorators;
    let _tag_initializers = [];
    let _tag_extraInitializers = [];
    let _perm_decorators;
    let _perm_initializers = [];
    let _perm_extraInitializers = [];
    let _id_decorators;
    let _id_initializers = [];
    let _id_extraInitializers = [];
    var Entry = _classThis = class {
        constructor(data) {
            this.tag = __runInitializers(this, _tag_initializers, 0);
            this.perm = (__runInitializers(this, _tag_extraInitializers), __runInitializers(this, _perm_initializers, 0));
            this.id = (__runInitializers(this, _perm_extraInitializers), __runInitializers(this, _id_initializers, 0));
            __runInitializers(this, _id_extraInitializers);
            if (data instanceof Uint8Array)
                deserialize(this, data);
            else if (typeof data == 'object')
                assignWithDefaults(this, data);
        }
    };
    __setFunctionName(_classThis, "Entry");
    (() => {
        const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(null) : void 0;
        _tag_decorators = [(_a = t).uint16.bind(_a)];
        _perm_decorators = [(_b = t).uint16.bind(_b)];
        _id_decorators = [(_c = t).uint32.bind(_c)];
        __esDecorate(null, null, _tag_decorators, { kind: "field", name: "tag", static: false, private: false, access: { has: obj => "tag" in obj, get: obj => obj.tag, set: (obj, value) => { obj.tag = value; } }, metadata: _metadata }, _tag_initializers, _tag_extraInitializers);
        __esDecorate(null, null, _perm_decorators, { kind: "field", name: "perm", static: false, private: false, access: { has: obj => "perm" in obj, get: obj => obj.perm, set: (obj, value) => { obj.perm = value; } }, metadata: _metadata }, _perm_initializers, _perm_extraInitializers);
        __esDecorate(null, null, _id_decorators, { kind: "field", name: "id", static: false, private: false, access: { has: obj => "id" in obj, get: obj => obj.id, set: (obj, value) => { obj.id = value; } }, metadata: _metadata }, _id_initializers, _id_extraInitializers);
        __esDecorate(null, _classDescriptor = { value: _classThis }, _classDecorators, { kind: "class", name: _classThis.name, metadata: _metadata }, null, _classExtraInitializers);
        Entry = _classThis = _classDescriptor.value;
        if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
        __runInitializers(_classThis, _classExtraInitializers);
    })();
    return Entry = _classThis;
})();
export { Entry };
let ACL = (() => {
    var _a;
    let _classDecorators = [struct()];
    let _classDescriptor;
    let _classExtraInitializers = [];
    let _classThis;
    let _version_decorators;
    let _version_initializers = [];
    let _version_extraInitializers = [];
    var ACL = _classThis = class {
        constructor(data) {
            this.version = __runInitializers(this, _version_initializers, version);
            this.entries = (__runInitializers(this, _version_extraInitializers), []);
            if (!data)
                return;
            if (!(data instanceof Uint8Array)) {
                this.entries.push(...data);
                return;
            }
            deserialize(this, data);
            if (this.version != version)
                throw err(new ErrnoError(Errno.EINVAL, 'Invalid ACL version'));
            for (let offset = sizeof(ACL); offset < data.length; offset += sizeof(Entry)) {
                if (offset + sizeof(Entry) > data.length)
                    throw err(new ErrnoError(Errno.EIO, 'Invalid ACL data'));
                const slice = data.subarray(offset, offset + sizeof(Entry));
                this.entries.push(new Entry(slice));
            }
        }
    };
    __setFunctionName(_classThis, "ACL");
    (() => {
        const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(null) : void 0;
        _version_decorators = [(_a = t).uint32.bind(_a)];
        __esDecorate(null, null, _version_decorators, { kind: "field", name: "version", static: false, private: false, access: { has: obj => "version" in obj, get: obj => obj.version, set: (obj, value) => { obj.version = value; } }, metadata: _metadata }, _version_initializers, _version_extraInitializers);
        __esDecorate(null, _classDescriptor = { value: _classThis }, _classDecorators, { kind: "class", name: _classThis.name, metadata: _metadata }, null, _classExtraInitializers);
        ACL = _classThis = _classDescriptor.value;
        if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
        __runInitializers(_classThis, _classExtraInitializers);
    })();
    return ACL = _classThis;
})();
export { ACL };
export function fromMode(mode) {
    return new ACL([
        new Entry({ tag: Tag.UserObj, perm: (mode & S_IRWXU) >> 6 }),
        new Entry({ tag: Tag.GroupObj, perm: (mode & S_IRWXG) >> 3 }),
        new Entry({ tag: Tag.Other, perm: mode & S_IRWXO }),
    ]);
}
export function toMode(acl) {
    let mode = 0;
    for (const entry of acl.entries) {
        switch (entry.tag) {
            case Tag.UserObj:
                mode |= entry.perm << 6;
                break;
            case Tag.GroupObj:
                mode |= entry.perm << 3;
                break;
            case Tag.Other:
                mode |= entry.perm;
                break;
            case Tag.User:
            case Tag.Group:
            case Tag.Mask:
            case Tag._None:
                continue;
        }
    }
    return mode;
}
export async function get($, path) {
    return new ACL(await xattr.get.call($, path, 'system.posix_acl_access'));
}
export function getSync($, path) {
    return new ACL(xattr.getSync.call($, path, 'system.posix_acl_access'));
}
export async function set($, path, acl) {
    await xattr.set.call($, path, 'system.posix_acl_access', serialize(acl));
}
export function setSync($, path, acl) {
    xattr.setSync.call($, path, 'system.posix_acl_access', serialize(acl));
}
export let shouldCheck = true;
export function setChecks(enabled) {
    shouldCheck = enabled;
}
/**
 * Checks if a given user/group has access to this item
 * @param access The requested access, combination of `W_OK`, `R_OK`, and `X_OK`
 */
export function check($, inode, access) {
    var _a, _b;
    if (!shouldCheck)
        return true;
    (_a = inode.attributes) !== null && _a !== void 0 ? _a : (inode.attributes = new Attributes());
    const { euid, egid } = (_b = $ === null || $ === void 0 ? void 0 : $.credentials) !== null && _b !== void 0 ? _b : defaultContext.credentials;
    const attr = inode.attributes.get('system.posix_acl_access');
    if (!attr)
        return true;
    const acl = new ACL(attr.value);
    let mask = R_OK | W_OK | X_OK;
    let result = false;
    for (const entry of acl.entries) {
        switch (entry.tag) {
            case Tag.UserObj:
                if (inode.uid == euid && (entry.perm & access) === access)
                    result = true;
                break;
            case Tag.User:
                if (entry.id == euid && (entry.perm & mask & access) === access)
                    result = true;
                break;
            case Tag.GroupObj:
                if (inode.gid == egid && (entry.perm & mask & access) === access)
                    result = true;
                break;
            case Tag.Group:
                if (entry.id == egid && (entry.perm & mask & access) === access)
                    result = true;
                break;
            case Tag.Mask:
                mask = entry.perm;
                break;
            case Tag.Other:
                if ((entry.perm & mask & access) === access)
                    result = true;
                break;
            case Tag._None:
                continue;
        }
    }
    return result;
}
