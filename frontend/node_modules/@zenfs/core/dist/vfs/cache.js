/* Experimental caching */
/**
 * Used for caching data
 * @internal
 */
export class Cache {
    constructor() {
        this.isEnabled = false;
        this.sync = new Map();
        this.async = new Map();
    }
    /**
     * Whether the data exists in the cache
     */
    has(path) {
        return this.isEnabled && this.sync.has(path);
    }
    /**
     * Gets data from the cache, if is exists and the cache is enabled.
     */
    get(path) {
        if (!this.isEnabled)
            return;
        return this.sync.get(path);
    }
    /**
     * Adds data if the cache is enabled
     */
    set(path, value) {
        if (!this.isEnabled)
            return;
        this.sync.set(path, value);
        this.async.set(path, Promise.resolve(value));
    }
    /**
     * Whether the data exists in the cache
     */
    hasAsync(path) {
        return this.isEnabled && this.async.has(path);
    }
    /**
     * Gets data from the cache, if it exists and the cache is enabled.
     */
    getAsync(path) {
        if (!this.isEnabled)
            return;
        return this.async.get(path);
    }
    /**
     * Adds data if the cache is enabled
     */
    setAsync(path, value) {
        if (!this.isEnabled)
            return;
        this.async.set(path, value);
        void value.then(v => this.sync.set(path, v));
    }
    /**
     * Clears the cache if it is enabled
     */
    clear() {
        if (!this.isEnabled)
            return;
        this.sync.clear();
        this.async.clear();
    }
}
/**
 * Used to cache
 */
export const stats = new Cache();
/**
 * Used to cache realpath lookups
 */
export const paths = new Cache();
