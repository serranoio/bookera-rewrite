import type { V_Context } from '../context.js';
import type { FileSystem, StreamOptions } from '../internal/filesystem.js';
import { type InodeLike } from '../internal/inode.js';
import '../polyfills.js';
/** @hidden */
export interface FileReadResult<T extends ArrayBufferView> {
    bytesRead: number;
    buffer: T;
}
/**
 * @internal
 */
export declare class SyncHandle {
    readonly context: V_Context;
    readonly path: string;
    readonly fs: FileSystem;
    readonly internalPath: string;
    readonly flag: number;
    readonly inode: InodeLike;
    protected _buffer?: Uint8Array;
    /**
     * Current position
     */
    protected _position: number;
    /**
     * Get the current file position.
     *
     * We emulate the following bug mentioned in the Node documentation:
     *
     * On Linux, positional writes don't work when the file is opened in append mode.
     * The kernel ignores the position argument and always appends the data to the end of the file.
     * @returns The current file position.
     */
    get position(): number;
    set position(value: number);
    /**
     * Whether the file has changes which have not been written to the FS
     */
    protected dirty: boolean;
    /**
     * Whether the file is open or closed
     */
    protected closed: boolean;
    /**
     * Creates a file with `path` and, optionally, the given contents.
     * Note that, if contents is specified, it will be mutated by the file.
     */
    constructor(context: V_Context, path: string, fs: FileSystem, internalPath: string, flag: number, inode: InodeLike);
    [Symbol.dispose](): void;
    private get _isSync();
    sync(): void;
    /**
     * Default implementation maps to `syncSync`.
     */
    datasync(): void;
    close(): void;
    /**
     * Cleans up. This will *not* sync the file data to the FS
     */
    protected dispose(force?: boolean): void;
    stat(): InodeLike;
    truncate(length: number): void;
    /**
     * Write buffer to the file.
     * @param buffer Uint8Array containing the data to write to the file.
     * @param offset Offset in the buffer to start reading data from.
     * @param length The amount of bytes to write to the file.
     * @param position Offset from the beginning of the file where this data should be written.
     * If position is null, the data will be written at  the current position.
     * @returns bytes written
     */
    write(buffer: Uint8Array, offset?: number, length?: number, position?: number): number;
    /**
     * Read data from the file.
     * @param buffer The buffer that the data will be written to.
     * @param offset The offset within the buffer where writing will start.
     * @param length An integer specifying the number of bytes to read.
     * @param position An integer specifying where to begin reading from in the file.
     * If position is null, data will be read from the current file position.
     * @returns number of bytes written
     */
    read(buffer: ArrayBufferView, offset?: number, length?: number, position?: number): number;
    chmod(mode: number): void;
    chown(uid: number, gid: number): void;
    /**
     * Change the file timestamps of the file.
     */
    utimes(atime: number, mtime: number): void;
    /**
     * Create a stream for reading the file.
     */
    streamRead(options: StreamOptions): ReadableStream;
    /**
     * Create a stream for writing the file.
     */
    streamWrite(options: StreamOptions): WritableStream;
}
/**
 * @internal @hidden
 */
export declare function toFD(file: SyncHandle): number;
/**
 * @internal @hidden
 */
export declare function fromFD($: V_Context, fd: number): SyncHandle;
export declare function deleteFD($: V_Context, fd: number): boolean;
