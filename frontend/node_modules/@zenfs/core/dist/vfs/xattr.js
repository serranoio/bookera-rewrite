import { Buffer } from 'buffer';
import { pick } from 'utilium';
import { Errno, ErrnoError } from '../internal/error.js';
import { Attributes, hasAccess } from '../internal/inode.js';
import { normalizePath } from '../utils.js';
import { checkAccess } from './config.js';
import { R_OK, W_OK } from './constants.js';
import { fixError, resolveMount } from './shared.js';
const _allowedRestrictedNames = [];
/**
 * Check permission for the attribute name.
 * For now, only attributes in the 'user' namespace are supported.
 * @throws EPERM for attributes in namespaces other than 'user'
 */
function checkName($, name, path, syscall) {
    if (!name.startsWith('user.') && !_allowedRestrictedNames.includes(name))
        throw new ErrnoError(Errno.EPERM, 'Only attributes in the user namespace are supported', path, syscall);
}
export async function get(path, name, opt = {}) {
    var _a;
    path = normalizePath(path);
    const { fs, path: resolved } = resolveMount(path, this);
    checkName(this, name, path, 'xattr.get');
    try {
        const inode = await fs.stat(resolved);
        if (checkAccess && !hasAccess(this, inode, R_OK)) {
            throw ErrnoError.With('EACCES', resolved, 'xattr.get');
        }
        (_a = inode.attributes) !== null && _a !== void 0 ? _a : (inode.attributes = new Attributes());
        const attr = inode.attributes.get(name);
        if (!attr)
            throw ErrnoError.With('ENODATA', resolved, 'xattr.get');
        const buffer = Buffer.from(attr.value);
        return opt.encoding == 'buffer' || !opt.encoding ? buffer : buffer.toString(opt.encoding);
    }
    catch (e) {
        throw fixError(e, { [resolved]: path });
    }
}
export function getSync(path, name, opt = {}) {
    var _a;
    path = normalizePath(path);
    checkName(this, name, path, 'xattr.get');
    const { fs, path: resolved } = resolveMount(path, this);
    try {
        const inode = fs.statSync(resolved);
        if (checkAccess && !hasAccess(this, inode, R_OK)) {
            throw ErrnoError.With('EACCES', resolved, 'xattr.get');
        }
        (_a = inode.attributes) !== null && _a !== void 0 ? _a : (inode.attributes = new Attributes());
        const attr = inode.attributes.get(name);
        if (!attr)
            throw ErrnoError.With('ENODATA', resolved, 'xattr.get');
        const buffer = Buffer.from(attr.value);
        return opt.encoding == 'buffer' || !opt.encoding ? buffer : buffer.toString(opt.encoding);
    }
    catch (e) {
        throw fixError(e, { [resolved]: path });
    }
}
/**
 * Sets the value of an extended attribute.
 *
 * @param path Path to the file
 * @param name Name of the attribute to set
 * @param value Value to set
 * @param opt Options for the operation
 */
export async function set(path, name, value, opt = {}) {
    var _a;
    path = normalizePath(path);
    const { fs, path: resolved } = resolveMount(path, this);
    checkName(this, name, path, 'xattr.set');
    try {
        const inode = await fs.stat(resolved);
        if (checkAccess && !hasAccess(this, inode, W_OK)) {
            throw ErrnoError.With('EACCES', resolved, 'xattr.set');
        }
        (_a = inode.attributes) !== null && _a !== void 0 ? _a : (inode.attributes = new Attributes());
        const attr = inode.attributes.get(name);
        if (opt.create && attr) {
            throw ErrnoError.With('EEXIST', resolved, 'xattr.set');
        }
        if (opt.replace && !attr) {
            throw ErrnoError.With('ENODATA', resolved, 'xattr.set');
        }
        inode.attributes.set(name, Buffer.from(value));
        await fs.touch(resolved, pick(inode, 'attributes'));
    }
    catch (e) {
        throw fixError(e, { [resolved]: path });
    }
}
/**
 * Synchronously sets the value of an extended attribute.
 *
 * @param path Path to the file
 * @param name Name of the attribute to set
 * @param value Value to set
 * @param opt Options for the operation
 */
export function setSync(path, name, value, opt = {}) {
    var _a;
    path = normalizePath(path);
    const { fs, path: resolved } = resolveMount(path, this);
    checkName(this, name, path, 'xattr.set');
    try {
        const inode = fs.statSync(resolved);
        if (checkAccess && !hasAccess(this, inode, W_OK)) {
            throw ErrnoError.With('EACCES', resolved, 'xattr.set');
        }
        (_a = inode.attributes) !== null && _a !== void 0 ? _a : (inode.attributes = new Attributes());
        const attr = inode.attributes.get(name);
        if (opt.create && attr) {
            throw ErrnoError.With('EEXIST', resolved, 'xattr.set');
        }
        if (opt.replace && !attr) {
            throw ErrnoError.With('ENODATA', resolved, 'xattr.set');
        }
        inode.attributes.set(name, Buffer.from(value));
        fs.touchSync(resolved, pick(inode, 'attributes'));
    }
    catch (e) {
        throw fixError(e, { [resolved]: path });
    }
}
/**
 * Removes an extended attribute from a file.
 *
 * @param path Path to the file
 * @param name Name of the attribute to remove
 */
export async function remove(path, name) {
    var _a;
    path = normalizePath(path);
    const { fs, path: resolved } = resolveMount(path, this);
    checkName(this, name, path, 'xattr.remove');
    try {
        const inode = await fs.stat(resolved);
        if (checkAccess && !hasAccess(this, inode, W_OK)) {
            throw ErrnoError.With('EACCES', resolved, 'xattr.remove');
        }
        (_a = inode.attributes) !== null && _a !== void 0 ? _a : (inode.attributes = new Attributes());
        const attr = inode.attributes.get(name);
        if (!attr)
            throw ErrnoError.With('ENODATA', resolved, 'xattr.remove');
        inode.attributes.remove(name);
        await fs.touch(resolved, pick(inode, 'attributes'));
    }
    catch (e) {
        throw fixError(e, { [resolved]: path });
    }
}
/**
 * Synchronously removes an extended attribute from a file.
 *
 * @param path Path to the file
 * @param name Name of the attribute to remove
 */
export function removeSync(path, name) {
    var _a;
    path = normalizePath(path);
    const { fs, path: resolved } = resolveMount(path, this);
    checkName(this, name, path, 'xattr.remove');
    try {
        const inode = fs.statSync(resolved);
        if (checkAccess && !hasAccess(this, inode, W_OK)) {
            throw ErrnoError.With('EACCES', resolved, 'xattr.remove');
        }
        (_a = inode.attributes) !== null && _a !== void 0 ? _a : (inode.attributes = new Attributes());
        const attr = inode.attributes.get(name);
        if (!attr)
            throw ErrnoError.With('ENODATA', resolved, 'xattr.remove');
        inode.attributes.remove(name);
        fs.touchSync(resolved, pick(inode, 'attributes'));
    }
    catch (e) {
        throw fixError(e, { [resolved]: path });
    }
}
/**
 * Lists all extended attributes of a file.
 *
 * @param path Path to the file
 * @returns Array of attribute names
 */
export async function list(path) {
    path = normalizePath(path);
    const { fs, path: resolved } = resolveMount(path, this);
    try {
        const inode = await fs.stat(resolved);
        if (!inode.attributes)
            return [];
        return inode.attributes.keys();
    }
    catch (e) {
        throw fixError(e, { [resolved]: path });
    }
}
/**
 * Synchronously lists all extended attributes of a file.
 *
 * @param path Path to the file
 * @returns Array of attribute names
 */
export function listSync(path) {
    path = normalizePath(path);
    const { fs, path: resolved } = resolveMount(path, this);
    try {
        const inode = fs.statSync(resolved);
        if (!inode.attributes)
            return [];
        return inode.attributes.keys();
    }
    catch (e) {
        throw fixError(e, { [resolved]: path });
    }
}
