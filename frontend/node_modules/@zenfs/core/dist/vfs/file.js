import { defaultContext } from '../internal/contexts.js';
import { Errno, ErrnoError } from '../internal/error.js';
import { InodeFlags, isBlockDevice, isCharacterDevice } from '../internal/inode.js';
import '../polyfills.js';
import * as c from './constants.js';
import { _chown } from './stats.js';
/**
 * @internal
 */
export class SyncHandle {
    /**
     * Get the current file position.
     *
     * We emulate the following bug mentioned in the Node documentation:
     *
     * On Linux, positional writes don't work when the file is opened in append mode.
     * The kernel ignores the position argument and always appends the data to the end of the file.
     * @returns The current file position.
     */
    get position() {
        return this.flag & c.O_APPEND ? this.inode.size : this._position;
    }
    set position(value) {
        this._position = value;
    }
    /**
     * Creates a file with `path` and, optionally, the given contents.
     * Note that, if contents is specified, it will be mutated by the file.
     */
    constructor(context, path, fs, internalPath, flag, inode) {
        this.context = context;
        this.path = path;
        this.fs = fs;
        this.internalPath = internalPath;
        this.flag = flag;
        this.inode = inode;
        /**
         * Current position
         */
        this._position = 0;
        /**
         * Whether the file has changes which have not been written to the FS
         */
        this.dirty = false;
        /**
         * Whether the file is open or closed
         */
        this.closed = false;
    }
    [Symbol.dispose]() {
        this.close();
    }
    get _isSync() {
        return !!(this.flag & c.O_SYNC || this.inode.flags & InodeFlags.Sync);
    }
    sync() {
        if (this.closed)
            throw ErrnoError.With('EBADF', this.path, 'sync');
        if (!this.dirty)
            return;
        if (!this.fs.attributes.has('no_write'))
            this.fs.touchSync(this.internalPath, this.inode);
        this.dirty = false;
    }
    /**
     * Default implementation maps to `syncSync`.
     */
    datasync() {
        return this.sync();
    }
    close() {
        if (this.closed)
            throw ErrnoError.With('EBADF', this.path, 'close');
        this.sync();
        this.dispose();
    }
    /**
     * Cleans up. This will *not* sync the file data to the FS
     */
    dispose(force) {
        if (this.closed)
            throw ErrnoError.With('EBADF', this.path, 'dispose');
        if (this.dirty && !force)
            throw ErrnoError.With('EBUSY', this.path, 'dispose');
        this.closed = true;
    }
    stat() {
        if (this.closed)
            throw ErrnoError.With('EBADF', this.path, 'stat');
        return this.inode;
    }
    truncate(length) {
        if (this.closed)
            throw ErrnoError.With('EBADF', this.path, 'truncate');
        this.dirty = true;
        if (!(this.flag & c.O_WRONLY || this.flag & c.O_RDWR)) {
            throw new ErrnoError(Errno.EPERM, 'File not opened with a writeable mode', this.path, 'truncate');
        }
        this.inode.mtimeMs = Date.now();
        this.inode.size = length;
        this.inode.ctimeMs = Date.now();
        if (this._isSync)
            this.sync();
    }
    /**
     * Write buffer to the file.
     * @param buffer Uint8Array containing the data to write to the file.
     * @param offset Offset in the buffer to start reading data from.
     * @param length The amount of bytes to write to the file.
     * @param position Offset from the beginning of the file where this data should be written.
     * If position is null, the data will be written at  the current position.
     * @returns bytes written
     */
    write(buffer, offset = 0, length = buffer.byteLength - offset, position = this.position) {
        if (this.closed)
            throw ErrnoError.With('EBADF', this.path, 'write');
        if (!(this.flag & c.O_WRONLY || this.flag & c.O_RDWR))
            throw new ErrnoError(Errno.EPERM, 'File not opened with a writeable mode');
        if (this.inode.flags & InodeFlags.Immutable)
            throw new ErrnoError(Errno.EPERM, 'File is immutable', this.path, 'write');
        this.dirty = true;
        const end = position + length;
        const slice = buffer.subarray(offset, offset + length);
        if (!isCharacterDevice(this.inode) && !isBlockDevice(this.inode) && end > this.inode.size)
            this.inode.size = end;
        this.inode.mtimeMs = Date.now();
        this.inode.ctimeMs = Date.now();
        this._position = position + slice.byteLength;
        this.fs.writeSync(this.internalPath, slice, position);
        if (this._isSync)
            this.sync();
        return slice.byteLength;
    }
    /**
     * Read data from the file.
     * @param buffer The buffer that the data will be written to.
     * @param offset The offset within the buffer where writing will start.
     * @param length An integer specifying the number of bytes to read.
     * @param position An integer specifying where to begin reading from in the file.
     * If position is null, data will be read from the current file position.
     * @returns number of bytes written
     */
    read(buffer, offset = 0, length = buffer.byteLength - offset, position = this.position) {
        if (this.closed)
            throw ErrnoError.With('EBADF', this.path, 'read');
        if (this.flag & c.O_WRONLY)
            throw new ErrnoError(Errno.EPERM, 'File not opened with a readable mode');
        if (!(this.inode.flags & InodeFlags.NoAtime)) {
            this.dirty = true;
            this.inode.atimeMs = Date.now();
        }
        let end = position + length;
        if (!isCharacterDevice(this.inode) && !isBlockDevice(this.inode) && end > this.inode.size) {
            end = position + Math.max(this.inode.size - position, 0);
        }
        this._position = end;
        const uint8 = new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);
        this.fs.readSync(this.internalPath, uint8.subarray(offset, offset + length), position, end);
        if (this._isSync)
            this.sync();
        return end - position;
    }
    chmod(mode) {
        if (this.closed)
            throw ErrnoError.With('EBADF', this.path, 'chmod');
        this.dirty = true;
        this.inode.mode = (this.inode.mode & (mode > c.S_IFMT ? ~c.S_IFMT : c.S_IFMT)) | mode;
        if (this._isSync || mode > c.S_IFMT)
            this.sync();
    }
    chown(uid, gid) {
        if (this.closed)
            throw ErrnoError.With('EBADF', this.path, 'chown');
        this.dirty = true;
        _chown(this.inode, uid, gid);
        if (this._isSync)
            this.sync();
    }
    /**
     * Change the file timestamps of the file.
     */
    utimes(atime, mtime) {
        if (this.closed)
            throw ErrnoError.With('EBADF', this.path, 'utimes');
        this.dirty = true;
        this.inode.atimeMs = atime;
        this.inode.mtimeMs = mtime;
        if (this._isSync)
            this.sync();
    }
    /**
     * Create a stream for reading the file.
     */
    streamRead(options) {
        if (this.closed)
            throw ErrnoError.With('EBADF', this.path, 'streamRead');
        return this.fs.streamRead(this.internalPath, options);
    }
    /**
     * Create a stream for writing the file.
     */
    streamWrite(options) {
        if (this.closed)
            throw ErrnoError.With('EBADF', this.path, 'streamWrite');
        if (this.inode.flags & InodeFlags.Immutable)
            throw new ErrnoError(Errno.EPERM, 'File is immutable', this.path, 'streamWrite');
        return this.fs.streamWrite(this.internalPath, options);
    }
}
// descriptors
/**
 * @internal @hidden
 */
export function toFD(file) {
    var _a, _b;
    const map = (_b = (_a = file.context) === null || _a === void 0 ? void 0 : _a.descriptors) !== null && _b !== void 0 ? _b : defaultContext.descriptors;
    const fd = Math.max(map.size ? Math.max(...map.keys()) + 1 : 0, 4);
    map.set(fd, file);
    return fd;
}
/**
 * @internal @hidden
 */
export function fromFD($, fd) {
    var _a;
    const map = (_a = $ === null || $ === void 0 ? void 0 : $.descriptors) !== null && _a !== void 0 ? _a : defaultContext.descriptors;
    const value = map.get(fd);
    if (!value)
        throw new ErrnoError(Errno.EBADF);
    return value;
}
export function deleteFD($, fd) {
    var _a;
    return ((_a = $ === null || $ === void 0 ? void 0 : $.descriptors) !== null && _a !== void 0 ? _a : defaultContext.descriptors).delete(fd);
}
