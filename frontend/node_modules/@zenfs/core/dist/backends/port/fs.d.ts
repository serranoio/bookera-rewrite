import type { FileReadResult } from 'node:fs/promises';
import type { ExtractProperties } from 'utilium';
import type { MountConfiguration } from '@zenfs/core/config.js';
import type { CreationOptions, FileSystemMetadata } from '@zenfs/core/filesystem.js';
import type { Backend, FilesystemOf } from '@zenfs/core/backends/backend.js';
import { File } from '@zenfs/core/file.js';
import { FileSystem } from '@zenfs/core/filesystem.js';
import { Stats } from '@zenfs/core/stats.js';
import * as RPC from '@zenfs/core/backends/port/rpc.js';
type FileMethods = Omit<ExtractProperties<File, (...args: any[]) => Promise<any>>, typeof Symbol.asyncDispose>;
type FileMethod = keyof FileMethods;
/** @internal */
export interface FileRequest<TMethod extends FileMethod = FileMethod> extends RPC.Request {
    fd: number;
    scope: 'file';
    method: TMethod;
    args: Parameters<FileMethods[TMethod]>;
}
export declare class PortFile extends File {
    fs: PortFS;
    readonly fd: number;
    position: number;
    constructor(fs: PortFS, fd: number, path: string, position: number);
    rpc<const T extends FileMethod>(method: T, ...args: Parameters<FileMethods[T]>): Promise<Awaited<ReturnType<FileMethods[T]>>>;
    protected _throwNoSync(syscall: string): never;
    stat(): Promise<Stats>;
    statSync(): Stats;
    truncate(len: number): Promise<void>;
    truncateSync(): void;
    write(buffer: Uint8Array, offset?: number, length?: number, position?: number): Promise<number>;
    writeSync(): number;
    read<TBuffer extends NodeJS.ArrayBufferView>(buffer: TBuffer, offset?: number, length?: number, position?: number): Promise<FileReadResult<TBuffer>>;
    readSync(): number;
    chown(uid: number, gid: number): Promise<void>;
    chownSync(): void;
    chmod(mode: number): Promise<void>;
    chmodSync(): void;
    utimes(atime: Date, mtime: Date): Promise<void>;
    utimesSync(): void;
    _setTypeSync(): void;
    close(): Promise<void>;
    closeSync(): void;
    sync(): Promise<void>;
    syncSync(): void;
}
type FSMethods = ExtractProperties<FileSystem, (...args: any[]) => Promise<any> | FileSystemMetadata>;
type FSMethod = keyof FSMethods;
/** @internal */
export interface FSRequest<TMethod extends FSMethod = FSMethod> extends RPC.Request {
    scope: 'fs';
    method: TMethod;
    args: Parameters<FSMethods[TMethod]>;
}
declare const PortFS_base: import("@zenfs/core").Mixin<typeof FileSystem, import("@zenfs/core/mixins/async.js").AsyncMixin>;
/**
 * PortFS lets you access an FS instance that is running in a port, or the other way around.
 *
 * Note that *direct* synchronous operations are not permitted on the PortFS,
 * regardless of the configuration option of the remote FS.
 */
export declare class PortFS extends PortFS_base {
    readonly options: RPC.Options;
    readonly port: RPC.Port;
    /**
     * @hidden
     */
    _sync: import("@zenfs/core/backends/index.js").StoreFS<import("@zenfs/core/backends/memory.js").InMemoryStore>;
    /**
     * Constructs a new PortFS instance that connects with the FS running on `options.port`.
     */
    constructor(options: RPC.Options);
    metadata(): FileSystemMetadata;
    protected rpc<const T extends FSMethod>(method: T, ...args: Parameters<FSMethods[T]>): Promise<Awaited<ReturnType<FSMethods[T]>>>;
    ready(): Promise<void>;
    rename(oldPath: string, newPath: string): Promise<void>;
    stat(path: string): Promise<Stats>;
    sync(path: string, data: Uint8Array, stats: Readonly<Stats>): Promise<void>;
    openFile(path: string, flag: string): Promise<File>;
    createFile(path: string, flag: string, mode: number, options: CreationOptions): Promise<File>;
    unlink(path: string): Promise<void>;
    rmdir(path: string): Promise<void>;
    mkdir(path: string, mode: number, options: CreationOptions): Promise<void>;
    readdir(path: string): Promise<string[]>;
    exists(path: string): Promise<boolean>;
    link(srcpath: string, dstpath: string): Promise<void>;
}
/** @internal */
export type FileOrFSRequest = FSRequest | FileRequest;
/** @internal */
export declare function handleRequest(port: RPC.Port, fs: FileSystem, request: FileOrFSRequest): Promise<void>;
export declare function attachFS(port: RPC.Port, fs: FileSystem): void;
export declare function detachFS(port: RPC.Port, fs: FileSystem): void;
declare const _Port: {
    name: string;
    options: {
        port: {
            type: "object";
            required: true;
            validator(port: RPC.Port): void;
        };
        timeout: {
            type: "number";
            required: false;
        };
    };
    create(options: RPC.Options): PortFS;
};
type _Port = typeof _Port;
export interface Port extends _Port {
}
export declare const Port: Port;
export declare function resolveRemoteMount<T extends Backend>(port: RPC.Port, config: MountConfiguration<T>, _depth?: number): Promise<FilesystemOf<T>>;
export {};
