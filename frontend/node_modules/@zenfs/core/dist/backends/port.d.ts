import type { TransferListItem } from 'node:worker_threads';
import type { MountConfiguration } from '../config.js';
import type { CreationOptions, UsageInfo } from '../internal/filesystem.js';
import type { InodeLike } from '../internal/inode.js';
import type { Backend, FilesystemOf } from './backend.js';
import { FileSystem } from '../internal/filesystem.js';
import { Inode } from '../internal/inode.js';
import '../polyfills.js';
type _MessageEvent<T = any> = T | {
    data: T;
};
/** @internal */
export interface RPCPort {
    postMessage(value: unknown, transfer?: TransferListItem[]): void;
    on?(event: 'message' | 'online', listener: (value: unknown) => void): this;
    off?(event: 'message', listener: (value: unknown) => void): this;
    addEventListener?(type: 'message', listener: (ev: _MessageEvent) => void): void;
    removeEventListener?(type: 'message', listener: (ev: _MessageEvent) => void): void;
}
/**
 * The options for the Port backend
 * @category Backends and Configuration
 */
export interface PortOptions {
    /**
     * The target port that you want to connect to, or the current port if in a port context.
     */
    port: RPCPort;
    /**
     * How long to wait for a request to complete
     */
    timeout?: number;
}
/**
 * The API for remote procedure calls
 * @category Internals
 * @internal
 */
export interface RPCMethods {
    usage(): UsageInfo;
    ready(): void;
    rename(oldPath: string, newPath: string): void;
    createFile(path: string, options: CreationOptions): Uint8Array;
    unlink(path: string): void;
    rmdir(path: string): void;
    mkdir(path: string, options: CreationOptions): Uint8Array;
    readdir(path: string): string[];
    touch(path: string, metadata: Uint8Array): void;
    exists(path: string): boolean;
    link(target: string, link: string): void;
    sync(path: string): void;
    read(path: string, buffer: Uint8Array, start: number, end: number): Uint8Array;
    write(path: string, buffer: Uint8Array, offset: number): void;
    stat(path: string): Uint8Array;
}
/**
 * The methods that can be called on the RPC port
 * @category Internals
 * @internal
 */
export type RPCMethod = keyof RPCMethods;
/**
 * An RPC message
 * @category Internals
 * @internal
 */
export interface RPCMessage {
    _zenfs: true;
    id: string;
    method: RPCMethod;
    stack: string;
}
interface RPCRequest<TMethod extends RPCMethod = RPCMethod> extends RPCMessage {
    method: TMethod;
    args: Parameters<RPCMethods[TMethod]>;
}
export declare function attach<T extends RPCMessage>(port: RPCPort, handler: (message: T) => unknown): void;
export declare function detach<T extends RPCMessage>(port: RPCPort, handler: (message: T) => unknown): void;
export declare function catchMessages<T extends Backend>(port: RPCPort): (fs: FilesystemOf<T>) => Promise<void>;
/**
 * @internal
 */
export declare function waitOnline(port: RPCPort): Promise<void>;
declare const PortFS_base: import("../index.js").Mixin<typeof FileSystem, import("../mixins/async.js").AsyncMixin>;
/**
 * PortFS lets you access an FS instance that is running in a port, or the other way around.
 *
 * Note that *direct* synchronous operations are not permitted on the PortFS,
 * regardless of the configuration option of the remote FS.
 * @category Internals
 * @internal
 */
export declare class PortFS extends PortFS_base {
    readonly options: PortOptions;
    readonly port: RPCPort;
    /**`
     * @hidden
     */
    _sync: import("./index.js").StoreFS<import("./memory.js").InMemoryStore>;
    /**
     * Constructs a new PortFS instance that connects with the FS running on `options.port`.
     */
    constructor(options: PortOptions);
    protected rpc<const T extends RPCMethod>(method: T, ...args: Parameters<RPCMethods[T]>): Promise<Awaited<ReturnType<RPCMethods[T]>>>;
    ready(): Promise<void>;
    rename(oldPath: string, newPath: string): Promise<void>;
    stat(path: string): Promise<Inode>;
    touch(path: string, metadata: InodeLike | Inode): Promise<void>;
    sync(path: string): Promise<void>;
    createFile(path: string, options: CreationOptions): Promise<Inode>;
    unlink(path: string): Promise<void>;
    rmdir(path: string): Promise<void>;
    mkdir(path: string, options: CreationOptions): Promise<Inode>;
    readdir(path: string): Promise<string[]>;
    exists(path: string): Promise<boolean>;
    link(srcpath: string, dstpath: string): Promise<void>;
    read(path: string, buffer: Uint8Array, start: number, end: number): Promise<void>;
    write(path: string, buffer: Uint8Array, offset: number): Promise<void>;
}
/** @internal */
export declare function handleRequest(port: RPCPort, fs: FileSystem & {
    _descriptors?: Map<number, File>;
}, request: RPCRequest): Promise<void>;
export declare function attachFS(port: RPCPort, fs: FileSystem): void;
export declare function detachFS(port: RPCPort, fs: FileSystem): void;
declare const _Port: {
    name: string;
    options: {
        port: {
            type: (arg: RPCPort) => boolean;
            required: true;
        };
        timeout: {
            type: string;
            required: false;
        };
    };
    create(options: PortOptions): PortFS;
};
type _Port = typeof _Port;
/**
 * @category Backends and Configuration
 */
export interface Port extends _Port {
}
/**
 * A backend for usage with ports and workers. See the examples below.
 *
 * #### Accessing an FS on a remote Worker from the main thread
 *
 * Main:
 *
 * ```ts
 * import { configure } from '@zenfs/core';
 * import { Port } from '@zenfs/port';
 * import { Worker } from 'node:worker_threads';
 *
 * const worker = new Worker('worker.js');
 *
 * await configure({
 * 	mounts: {
 * 		'/worker': {
 * 			backend: Port,
 * 			port: worker,
 * 		},
 * 	},
 * });
 * ```
 *
 * Worker:
 *
 * ```ts
 * import { InMemory, resolveRemoteMount, attachFS } from '@zenfs/core';
 * import { parentPort } from 'node:worker_threads';
 *
 * await resolveRemoteMount(parentPort, { backend: InMemory, name: 'tmp' });
 * ```
 *
 * If you are using using web workers, you would use `self` instead of importing `parentPort` in the worker, and would not need to import `Worker` in the main thread.
 *
 * #### Using with multiple ports on the same thread
 *
 * ```ts
 * import { InMemory, fs, resolveMountConfig, resolveRemoteMount, Port } from '@zenfs/core';
 * import { MessageChannel } from 'node:worker_threads';
 *
 * const { port1: localPort, port2: remotePort } = new MessageChannel();
 *
 * fs.mount('/remote', await resolveRemoteMount(remotePort, { backend: InMemory, name: 'tmp' }));
 * fs.mount('/port', await resolveMountConfig({ backend: Port, port: localPort }));
 *
 * const content = 'FS is in a port';
 *
 * await fs.promises.writeFile('/port/test', content);
 *
 * fs.readFileSync('/remote/test', 'utf8'); // FS is in a port
 * await fs.promises.readFile('/port/test', 'utf8'); // FS is in a port
 * ```
 *
 * @category Backends and Configuration
 */
export declare const Port: Port;
/**
 * @category Backends and Configuration
 */
export declare function resolveRemoteMount<T extends Backend>(port: RPCPort, config: MountConfiguration<T>, _depth?: number): Promise<FilesystemOf<T>>;
export {};
