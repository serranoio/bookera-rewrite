import { SyncTransaction, type Store } from '@zenfs/core/backends/store/store.js';
/**
 * An interface for simple synchronous stores that don't have special support for transactions and such.
 */
export interface SimpleSyncStore extends Store {
    keys(): Iterable<bigint>;
    get(id: bigint): Uint8Array | undefined;
    set(id: bigint, data: Uint8Array): void;
    delete(id: bigint): void;
}
/**
 * An interface for simple asynchronous stores that don't have special support for transactions and such.
 * This class adds caching at the store level.
 */
export declare abstract class SimpleAsyncStore implements SimpleSyncStore {
    abstract name: string;
    protected cache: Map<bigint, Uint8Array>;
    protected queue: Set<Promise<unknown>>;
    protected abstract entries(): Promise<Iterable<[bigint, Uint8Array]>>;
    keys(): Iterable<bigint>;
    get(id: bigint): Uint8Array | undefined;
    set(id: bigint, data: Uint8Array): void;
    protected abstract _set(ino: bigint, data: Uint8Array): Promise<void>;
    delete(id: bigint): void;
    protected abstract _delete(ino: bigint): Promise<void>;
    clearSync(): void;
    abstract clear(): Promise<void>;
    sync(): Promise<void>;
    transaction(): SimpleTransaction;
}
/**
 * Transaction for simple stores.
 * @see SimpleSyncStore
 * @see SimpleAsyncStore
 */
export declare class SimpleTransaction extends SyncTransaction<SimpleSyncStore> {
    /**
     * Stores data in the keys we modify prior to modifying them.
     * Allows us to roll back commits.
     */
    protected originalData: Map<bigint, Uint8Array | void>;
    /**
     * List of keys modified in this transaction, if any.
     */
    protected modifiedKeys: Set<bigint>;
    protected store: SimpleSyncStore;
    keysSync(): Iterable<bigint>;
    getSync(id: bigint): Uint8Array;
    setSync(id: bigint, data: Uint8Array): void;
    removeSync(id: bigint): void;
    commitSync(): void;
    abortSync(): void;
    /**
     * Stashes given key value pair into `originalData` if it doesn't already
     * exist. Allows us to stash values the program is requesting anyway to
     * prevent needless `get` requests if the program modifies the data later
     * on during the transaction.
     */
    protected stashOldValue(id: bigint, value?: Uint8Array): void;
    /**
     * Marks `ino` as modified, and stashes its value if it has not been
     * stashed already.
     */
    protected markModified(id: bigint): void;
}
