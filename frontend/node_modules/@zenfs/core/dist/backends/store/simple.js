import { SyncTransaction } from './store.js';
/**
 * An interface for simple asynchronous stores that don't have special support for transactions and such.
 * This class adds caching at the store level.
 */
export class SimpleAsyncStore {
    constructor() {
        this.cache = new Map();
        this.queue = new Set();
    }
    keys() {
        return this.cache.keys();
    }
    get(id) {
        return this.cache.get(id);
    }
    set(id, data) {
        this.cache.set(id, data);
        this.queue.add(this._set(id, data));
    }
    delete(id) {
        this.cache.delete(id);
        this.queue.add(this._delete(id));
    }
    clearSync() {
        this.cache.clear();
        this.queue.add(this.clear());
    }
    async sync() {
        for (const [ino, data] of await this.entries()) {
            if (!this.cache.has(ino)) {
                this.cache.set(ino, data);
            }
        }
        for (const promise of this.queue) {
            await promise;
        }
    }
    transaction() {
        return new SimpleTransaction(this);
    }
}
/**
 * Transaction for simple stores.
 * @see SimpleSyncStore
 * @see SimpleAsyncStore
 */
export class SimpleTransaction extends SyncTransaction {
    constructor() {
        super(...arguments);
        /**
         * Stores data in the keys we modify prior to modifying them.
         * Allows us to roll back commits.
         */
        this.originalData = new Map();
        /**
         * List of keys modified in this transaction, if any.
         */
        this.modifiedKeys = new Set();
    }
    keysSync() {
        return this.store.keys();
    }
    getSync(id) {
        const val = this.store.get(id);
        this.stashOldValue(id, val);
        return val;
    }
    setSync(id, data) {
        this.markModified(id);
        return this.store.set(id, data);
    }
    removeSync(id) {
        this.markModified(id);
        this.store.delete(id);
    }
    commitSync() {
        this.done = true;
    }
    abortSync() {
        if (!this.done) {
            return;
        }
        // Rollback old values.
        for (const key of this.modifiedKeys) {
            const value = this.originalData.get(key);
            if (!value) {
                // Key didn't exist.
                this.store.delete(key);
            }
            else {
                // Key existed. Store old value.
                this.store.set(key, value);
            }
        }
        this.done = true;
    }
    /**
     * Stashes given key value pair into `originalData` if it doesn't already
     * exist. Allows us to stash values the program is requesting anyway to
     * prevent needless `get` requests if the program modifies the data later
     * on during the transaction.
     */
    stashOldValue(id, value) {
        // Keep only the earliest value in the transaction.
        if (!this.originalData.has(id)) {
            this.originalData.set(id, value);
        }
    }
    /**
     * Marks `ino` as modified, and stashes its value if it has not been
     * stashed already.
     */
    markModified(id) {
        this.modifiedKeys.add(id);
        if (!this.originalData.has(id)) {
            this.originalData.set(id, this.store.get(id));
        }
    }
}
