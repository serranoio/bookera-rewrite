var __addDisposableResource = (this && this.__addDisposableResource) || function (env, value, async) {
    if (value !== null && value !== void 0) {
        if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
        var dispose, inner;
        if (async) {
            if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
            dispose = value[Symbol.asyncDispose];
        }
        if (dispose === void 0) {
            if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
            dispose = value[Symbol.dispose];
            if (async) inner = dispose;
        }
        if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
        if (inner) dispose = function() { try { inner.call(this); } catch (e) { return Promise.reject(e); } };
        env.stack.push({ value: value, dispose: dispose, async: async });
    }
    else if (async) {
        env.stack.push({ async: true });
    }
    return value;
};
var __disposeResources = (this && this.__disposeResources) || (function (SuppressedError) {
    return function (env) {
        function fail(e) {
            env.error = env.hasError ? new SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
            env.hasError = true;
        }
        var r, s = 0;
        function next() {
            while (r = env.stack.pop()) {
                try {
                    if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);
                    if (r.dispose) {
                        var result = r.dispose.call(r.value);
                        if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) { fail(e); return next(); });
                    }
                    else s |= 1;
                }
                catch (e) {
                    fail(e);
                }
            }
            if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
            if (env.hasError) throw env.error;
        }
        return next();
    };
})(typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
});
import { credentials } from '../../credentials.js';
import { S_IFDIR, S_IFREG, S_ISGID, S_ISUID } from '../../vfs/constants.js';
import { basename, dirname, parse, resolve } from '../../vfs/path.js';
import { Errno, ErrnoError } from '../../error.js';
import { PreloadFile } from '../../file.js';
import { FileSystem } from '../../filesystem.js';
import { Inode, rootIno } from './inode.js';
import { decodeDirListing, encodeDirListing, encodeUTF8, randomBigInt } from '../../utils.js';
import { serialize } from 'utilium';
const maxInodeAllocTries = 5;
/**
 * A file system which uses a key-value store.
 *
 * We use a unique ID for each node in the file system. The root node has a fixed ID.
 * @todo Introduce Node ID caching.
 * @todo Check modes.
 * @internal
 */
export class StoreFS extends FileSystem {
    async ready() {
        if (this._initialized) {
            return;
        }
        await this.checkRoot();
        this._initialized = true;
    }
    constructor(store) {
        super();
        this.store = store;
        this._initialized = false;
    }
    metadata() {
        return {
            ...super.metadata(),
            name: this.store.name,
            features: ['setid'],
        };
    }
    /**
     * Delete all contents stored in the file system.
     * @deprecated
     */
    async empty() {
        await this.store.clear();
        // Root always exists.
        await this.checkRoot();
    }
    /**
     * Delete all contents stored in the file system.
     * @deprecated
     */
    emptySync() {
        this.store.clearSync();
        // Root always exists.
        this.checkRootSync();
    }
    /**
     * @todo Make rename compatible with the cache.
     */
    async rename(oldPath, newPath) {
        const env_1 = { stack: [], error: void 0, hasError: false };
        try {
            const tx = __addDisposableResource(env_1, this.store.transaction(), true);
            const _old = parse(oldPath), _new = parse(newPath), 
            // Remove oldPath from parent's directory listing.
            oldDirNode = await this.findInode(tx, _old.dir, 'rename'), oldDirList = decodeDirListing(await this.get(tx, oldDirNode.data, _old.dir, 'rename'));
            if (!oldDirList[_old.base]) {
                throw ErrnoError.With('ENOENT', oldPath, 'rename');
            }
            const ino = oldDirList[_old.base];
            delete oldDirList[_old.base];
            /*
                Can't move a folder inside itself.
                This ensures that the check passes only if `oldPath` is a subpath of `_new.dir`.
                We append '/' to avoid matching folders that are a substring of the bottom-most folder in the path.
            */
            if ((_new.dir + '/').indexOf(oldPath + '/') === 0) {
                throw new ErrnoError(Errno.EBUSY, _old.dir);
            }
            // Add newPath to parent's directory listing.
            const sameParent = _new.dir == _old.dir;
            // Prevent us from re-grabbing the same directory listing, which still contains `old_path.base.`
            const newDirNode = sameParent ? oldDirNode : await this.findInode(tx, _new.dir, 'rename');
            const newDirList = sameParent ? oldDirList : decodeDirListing(await this.get(tx, newDirNode.data, _new.dir, 'rename'));
            if (newDirList[_new.base]) {
                // If it's a file, delete it, if it's a directory, throw a permissions error.
                const existing = new Inode(await this.get(tx, newDirList[_new.base], newPath, 'rename'));
                if (!existing.toStats().isFile()) {
                    throw ErrnoError.With('EPERM', newPath, 'rename');
                }
                await tx.remove(existing.data);
                await tx.remove(newDirList[_new.base]);
            }
            newDirList[_new.base] = ino;
            // Commit the two changed directory listings.
            await tx.set(oldDirNode.data, encodeDirListing(oldDirList));
            await tx.set(newDirNode.data, encodeDirListing(newDirList));
            await tx.commit();
        }
        catch (e_1) {
            env_1.error = e_1;
            env_1.hasError = true;
        }
        finally {
            const result_1 = __disposeResources(env_1);
            if (result_1)
                await result_1;
        }
    }
    renameSync(oldPath, newPath) {
        const env_2 = { stack: [], error: void 0, hasError: false };
        try {
            const tx = __addDisposableResource(env_2, this.store.transaction(), false);
            const _old = parse(oldPath), _new = parse(newPath), 
            // Remove oldPath from parent's directory listing.
            oldDirNode = this.findInodeSync(tx, _old.dir, 'rename'), oldDirList = decodeDirListing(this.getSync(tx, oldDirNode.data, _old.dir, 'rename'));
            if (!oldDirList[_old.base]) {
                throw ErrnoError.With('ENOENT', oldPath, 'rename');
            }
            const ino = oldDirList[_old.base];
            delete oldDirList[_old.base];
            /*
                Can't move a folder inside itself.
                This ensures that the check passes only if `oldPath` is a subpath of `_new.dir`.
                We append '/' to avoid matching folders that are a substring of the bottom-most folder in the path.
            */
            if ((_new.dir + '/').indexOf(oldPath + '/') == 0) {
                throw new ErrnoError(Errno.EBUSY, _old.dir);
            }
            // Add newPath to parent's directory listing.
            const sameParent = _new.dir === _old.dir;
            // Prevent us from re-grabbing the same directory listing, which still contains `old_path.base.`
            const newDirNode = sameParent ? oldDirNode : this.findInodeSync(tx, _new.dir, 'rename');
            const newDirList = sameParent ? oldDirList : decodeDirListing(this.getSync(tx, newDirNode.data, _new.dir, 'rename'));
            if (newDirList[_new.base]) {
                // If it's a file, delete it, if it's a directory, throw a permissions error.
                const existing = new Inode(this.getSync(tx, newDirList[_new.base], newPath, 'rename'));
                if (!existing.toStats().isFile()) {
                    throw ErrnoError.With('EPERM', newPath, 'rename');
                }
                tx.removeSync(existing.data);
                tx.removeSync(newDirList[_new.base]);
            }
            newDirList[_new.base] = ino;
            // Commit the two changed directory listings.
            tx.setSync(oldDirNode.data, encodeDirListing(oldDirList));
            tx.setSync(newDirNode.data, encodeDirListing(newDirList));
            tx.commitSync();
        }
        catch (e_2) {
            env_2.error = e_2;
            env_2.hasError = true;
        }
        finally {
            __disposeResources(env_2);
        }
    }
    async stat(path) {
        const env_3 = { stack: [], error: void 0, hasError: false };
        try {
            const tx = __addDisposableResource(env_3, this.store.transaction(), true);
            return (await this.findInode(tx, path, 'stat')).toStats();
        }
        catch (e_3) {
            env_3.error = e_3;
            env_3.hasError = true;
        }
        finally {
            const result_2 = __disposeResources(env_3);
            if (result_2)
                await result_2;
        }
    }
    statSync(path) {
        const env_4 = { stack: [], error: void 0, hasError: false };
        try {
            const tx = __addDisposableResource(env_4, this.store.transaction(), false);
            return this.findInodeSync(tx, path, 'stat').toStats();
        }
        catch (e_4) {
            env_4.error = e_4;
            env_4.hasError = true;
        }
        finally {
            __disposeResources(env_4);
        }
    }
    async createFile(path, flag, mode) {
        const node = await this.commitNew(path, S_IFREG, mode, new Uint8Array(), 'createFile');
        return new PreloadFile(this, path, flag, node.toStats(), new Uint8Array());
    }
    createFileSync(path, flag, mode) {
        const node = this.commitNewSync(path, S_IFREG, mode, new Uint8Array(), 'createFile');
        return new PreloadFile(this, path, flag, node.toStats(), new Uint8Array());
    }
    async openFile(path, flag) {
        const env_5 = { stack: [], error: void 0, hasError: false };
        try {
            const tx = __addDisposableResource(env_5, this.store.transaction(), true);
            const node = await this.findInode(tx, path, 'openFile');
            const data = await this.get(tx, node.data, path, 'openFile');
            return new PreloadFile(this, path, flag, node.toStats(), data);
        }
        catch (e_5) {
            env_5.error = e_5;
            env_5.hasError = true;
        }
        finally {
            const result_3 = __disposeResources(env_5);
            if (result_3)
                await result_3;
        }
    }
    openFileSync(path, flag) {
        const env_6 = { stack: [], error: void 0, hasError: false };
        try {
            const tx = __addDisposableResource(env_6, this.store.transaction(), false);
            const node = this.findInodeSync(tx, path, 'openFile');
            const data = this.getSync(tx, node.data, path, 'openFile');
            return new PreloadFile(this, path, flag, node.toStats(), data);
        }
        catch (e_6) {
            env_6.error = e_6;
            env_6.hasError = true;
        }
        finally {
            __disposeResources(env_6);
        }
    }
    async unlink(path) {
        return this.remove(path, false, 'unlink');
    }
    unlinkSync(path) {
        this.removeSync(path, false, 'unlink');
    }
    async rmdir(path) {
        if ((await this.readdir(path)).length) {
            throw ErrnoError.With('ENOTEMPTY', path, 'rmdir');
        }
        await this.remove(path, true, 'rmdir');
    }
    rmdirSync(path) {
        if (this.readdirSync(path).length) {
            throw ErrnoError.With('ENOTEMPTY', path, 'rmdir');
        }
        this.removeSync(path, true, 'rmdir');
    }
    async mkdir(path, mode) {
        await this.commitNew(path, S_IFDIR, mode, encodeUTF8('{}'), 'mkdir');
    }
    mkdirSync(path, mode) {
        this.commitNewSync(path, S_IFDIR, mode, encodeUTF8('{}'), 'mkdir');
    }
    async readdir(path) {
        const env_7 = { stack: [], error: void 0, hasError: false };
        try {
            const tx = __addDisposableResource(env_7, this.store.transaction(), true);
            const node = await this.findInode(tx, path, 'readdir');
            return Object.keys(decodeDirListing(await this.get(tx, node.data, path, 'readdir')));
        }
        catch (e_7) {
            env_7.error = e_7;
            env_7.hasError = true;
        }
        finally {
            const result_4 = __disposeResources(env_7);
            if (result_4)
                await result_4;
        }
    }
    readdirSync(path) {
        const env_8 = { stack: [], error: void 0, hasError: false };
        try {
            const tx = __addDisposableResource(env_8, this.store.transaction(), false);
            const node = this.findInodeSync(tx, path, 'readdir');
            return Object.keys(decodeDirListing(this.getSync(tx, node.data, path, 'readdir')));
        }
        catch (e_8) {
            env_8.error = e_8;
            env_8.hasError = true;
        }
        finally {
            __disposeResources(env_8);
        }
    }
    /**
     * Updated the inode and data node at `path`
     * @todo Ensure mtime updates properly, and use that to determine if a data update is required.
     */
    async sync(path, data, stats) {
        const env_9 = { stack: [], error: void 0, hasError: false };
        try {
            const tx = __addDisposableResource(env_9, this.store.transaction(), true);
            // We use _findInode because we actually need the INode id.
            const fileInodeId = await this._findInode(tx, path, 'sync'), fileInode = new Inode(await this.get(tx, fileInodeId, path, 'sync')), inodeChanged = fileInode.update(stats);
            // Sync data.
            await tx.set(fileInode.data, data);
            // Sync metadata.
            if (inodeChanged) {
                await tx.set(fileInodeId, serialize(fileInode));
            }
            await tx.commit();
        }
        catch (e_9) {
            env_9.error = e_9;
            env_9.hasError = true;
        }
        finally {
            const result_5 = __disposeResources(env_9);
            if (result_5)
                await result_5;
        }
    }
    /**
     * Updated the inode and data node at `path`
     * @todo Ensure mtime updates properly, and use that to determine if a data update is required.
     */
    syncSync(path, data, stats) {
        const env_10 = { stack: [], error: void 0, hasError: false };
        try {
            const tx = __addDisposableResource(env_10, this.store.transaction(), false);
            // We use _findInode because we actually need the INode id.
            const fileInodeId = this._findInodeSync(tx, path, 'sync'), fileInode = new Inode(this.getSync(tx, fileInodeId, path, 'sync')), inodeChanged = fileInode.update(stats);
            // Sync data.
            tx.setSync(fileInode.data, data);
            // Sync metadata.
            if (inodeChanged) {
                tx.setSync(fileInodeId, serialize(fileInode));
            }
            tx.commitSync();
        }
        catch (e_10) {
            env_10.error = e_10;
            env_10.hasError = true;
        }
        finally {
            __disposeResources(env_10);
        }
    }
    async link(target, link) {
        const env_11 = { stack: [], error: void 0, hasError: false };
        try {
            const tx = __addDisposableResource(env_11, this.store.transaction(), true);
            const newDir = dirname(link), newDirNode = await this.findInode(tx, newDir, 'link'), listing = decodeDirListing(await this.get(tx, newDirNode.data, newDir, 'link'));
            const ino = await this._findInode(tx, target, 'link');
            const node = new Inode(await this.get(tx, ino, target, 'link'));
            node.nlink++;
            listing[basename(link)] = ino;
            tx.setSync(ino, serialize(node));
            tx.setSync(newDirNode.data, encodeDirListing(listing));
            tx.commitSync();
        }
        catch (e_11) {
            env_11.error = e_11;
            env_11.hasError = true;
        }
        finally {
            const result_6 = __disposeResources(env_11);
            if (result_6)
                await result_6;
        }
    }
    linkSync(target, link) {
        const env_12 = { stack: [], error: void 0, hasError: false };
        try {
            const tx = __addDisposableResource(env_12, this.store.transaction(), false);
            const newDir = dirname(link), newDirNode = this.findInodeSync(tx, newDir, 'link'), listing = decodeDirListing(this.getSync(tx, newDirNode.data, newDir, 'link'));
            const ino = this._findInodeSync(tx, target, 'link');
            const node = new Inode(this.getSync(tx, ino, target, 'link'));
            node.nlink++;
            listing[basename(link)] = ino;
            tx.setSync(ino, serialize(node));
            tx.setSync(newDirNode.data, encodeDirListing(listing));
            tx.commitSync();
        }
        catch (e_12) {
            env_12.error = e_12;
            env_12.hasError = true;
        }
        finally {
            __disposeResources(env_12);
        }
    }
    /**
     * Checks if the root directory exists. Creates it if it doesn't.
     */
    async checkRoot() {
        const env_13 = { stack: [], error: void 0, hasError: false };
        try {
            const tx = __addDisposableResource(env_13, this.store.transaction(), true);
            if (await tx.get(rootIno)) {
                return;
            }
            // Create new inode. o777, owned by root:root
            const inode = new Inode();
            inode.ino = rootIno;
            inode.mode = 0o777 | S_IFDIR;
            // If the root doesn't exist, the first random ID shouldn't exist either.
            await tx.set(inode.data, encodeUTF8('{}'));
            await tx.set(rootIno, serialize(inode));
            await tx.commit();
        }
        catch (e_13) {
            env_13.error = e_13;
            env_13.hasError = true;
        }
        finally {
            const result_7 = __disposeResources(env_13);
            if (result_7)
                await result_7;
        }
    }
    /**
     * Checks if the root directory exists. Creates it if it doesn't.
     */
    checkRootSync() {
        const env_14 = { stack: [], error: void 0, hasError: false };
        try {
            const tx = __addDisposableResource(env_14, this.store.transaction(), false);
            if (tx.getSync(rootIno)) {
                return;
            }
            // Create new inode, mode o777, owned by root:root
            const inode = new Inode();
            inode.ino = rootIno;
            inode.mode = 0o777 | S_IFDIR;
            // If the root doesn't exist, the first random ID shouldn't exist either.
            tx.setSync(inode.data, encodeUTF8('{}'));
            tx.setSync(rootIno, serialize(inode));
            tx.commitSync();
        }
        catch (e_14) {
            env_14.error = e_14;
            env_14.hasError = true;
        }
        finally {
            __disposeResources(env_14);
        }
    }
    /**
     * Helper function for findINode.
     * @param parent The parent directory of the file we are attempting to find.
     * @param filename The filename of the inode we are attempting to find, minus
     *   the parent.
     */
    async _findInode(tx, path, syscall, visited = new Set()) {
        if (visited.has(path)) {
            throw new ErrnoError(Errno.EIO, 'Infinite loop detected while finding inode', path);
        }
        visited.add(path);
        if (path == '/') {
            return rootIno;
        }
        const { dir: parent, base: filename } = parse(path);
        const inode = parent == '/' ? new Inode(await this.get(tx, rootIno, parent, syscall)) : await this.findInode(tx, parent, syscall, visited);
        const dirList = decodeDirListing(await this.get(tx, inode.data, parent, syscall));
        if (!(filename in dirList)) {
            throw ErrnoError.With('ENOENT', resolve(parent, filename), syscall);
        }
        return dirList[filename];
    }
    /**
     * Helper function for findINode.
     * @param parent The parent directory of the file we are attempting to find.
     * @param filename The filename of the inode we are attempting to find, minus
     *   the parent.
     * @return string The ID of the file's inode in the file system.
     */
    _findInodeSync(tx, path, syscall, visited = new Set()) {
        if (visited.has(path)) {
            throw new ErrnoError(Errno.EIO, 'Infinite loop detected while finding inode', path);
        }
        visited.add(path);
        if (path == '/') {
            return rootIno;
        }
        const { dir: parent, base: filename } = parse(path);
        const inode = parent == '/' ? new Inode(this.getSync(tx, rootIno, parent, syscall)) : this.findInodeSync(tx, parent, syscall, visited);
        const dir = decodeDirListing(this.getSync(tx, inode.data, parent, syscall));
        if (!(filename in dir)) {
            throw ErrnoError.With('ENOENT', resolve(parent, filename), syscall);
        }
        return dir[filename];
    }
    /**
     * Finds the Inode of `path`.
     * @param path The path to look up.
     * @todo memoize/cache
     */
    async findInode(tx, path, syscall, visited = new Set()) {
        const ino = await this._findInode(tx, path, syscall, visited);
        return new Inode(await this.get(tx, ino, path, syscall));
    }
    /**
     * Finds the Inode of `path`.
     * @param path The path to look up.
     * @return The Inode of the path p.
     * @todo memoize/cache
     */
    findInodeSync(tx, path, syscall, visited = new Set()) {
        const ino = this._findInodeSync(tx, path, syscall, visited);
        return new Inode(this.getSync(tx, ino, path, syscall));
    }
    /**
     * Given an ID, retrieves the corresponding data.
     * @param tx The transaction to use.
     * @param path The corresponding path to the file (used for error messages).
     * @param id The ID to look up.
     */
    async get(tx, id, path, syscall) {
        const data = await tx.get(id);
        if (!data) {
            throw ErrnoError.With('ENOENT', path, syscall);
        }
        return data;
    }
    /**
     * Given an ID, retrieves the corresponding data.
     * @param tx The transaction to use.
     * @param path The corresponding path to the file (used for error messages).
     * @param id The ID to look up.
     */
    getSync(tx, id, path, syscall) {
        const data = tx.getSync(id);
        if (!data) {
            throw ErrnoError.With('ENOENT', path, syscall);
        }
        return data;
    }
    /**
     * Adds a new node under a random ID. Retries before giving up in
     * the exceedingly unlikely chance that we try to reuse a random id.
     */
    async allocNew(tx, path, syscall) {
        for (let i = 0; i < maxInodeAllocTries; i++) {
            const ino = randomBigInt();
            if (await tx.get(ino)) {
                continue;
            }
            return ino;
        }
        throw new ErrnoError(Errno.ENOSPC, 'No IDs available', path, syscall);
    }
    /**
     * Creates a new node under a random ID. Retries before giving up in
     * the exceedingly unlikely chance that we try to reuse a random id.
     * @return The ino that the data was stored under.
     */
    allocNewSync(tx, path, syscall) {
        for (let i = 0; i < maxInodeAllocTries; i++) {
            const ino = randomBigInt();
            if (tx.getSync(ino)) {
                continue;
            }
            return ino;
        }
        throw new ErrnoError(Errno.ENOSPC, 'No IDs available', path, syscall);
    }
    /**
     * Commits a new file (well, a FILE or a DIRECTORY) to the file system with `mode`.
     * Note: This will commit the transaction.
     * @param path The path to the new file.
     * @param type The type of the new file.
     * @param mode The mode to create the new file with.
     * @param data The data to store at the file's data node.
     */
    async commitNew(path, type, mode, data, syscall) {
        const env_15 = { stack: [], error: void 0, hasError: false };
        try {
            /*
                The root always exists.
                If we don't check this prior to taking steps below,
                we will create a file with name '' in root if path is '/'.
            */
            if (path == '/') {
                throw ErrnoError.With('EEXIST', path, syscall);
            }
            const tx = __addDisposableResource(env_15, this.store.transaction(), true);
            const { dir: parentPath, base: fname } = parse(path);
            const parent = await this.findInode(tx, parentPath, syscall);
            const listing = decodeDirListing(await this.get(tx, parent.data, parentPath, syscall));
            // Check if file already exists.
            if (listing[fname]) {
                throw ErrnoError.With('EEXIST', path, syscall);
            }
            // Commit data.
            const inode = new Inode();
            inode.ino = await this.allocNew(tx, path, syscall);
            inode.data = await this.allocNew(tx, path, syscall);
            inode.mode = mode | type;
            inode.uid = parent.mode & S_ISUID ? parent.uid : credentials.uid;
            inode.gid = parent.mode & S_ISGID ? parent.gid : credentials.gid;
            inode.size = data.length;
            await tx.set(inode.ino, serialize(inode));
            await tx.set(inode.data, data);
            // Update and commit parent directory listing.
            listing[fname] = inode.ino;
            await tx.set(parent.data, encodeDirListing(listing));
            await tx.commit();
            return inode;
        }
        catch (e_15) {
            env_15.error = e_15;
            env_15.hasError = true;
        }
        finally {
            const result_8 = __disposeResources(env_15);
            if (result_8)
                await result_8;
        }
    }
    /**
     * Commits a new file (well, a FILE or a DIRECTORY) to the file system with `mode`.
     * Note: This will commit the transaction.
     * @param path The path to the new file.
     * @param type The type of the new file.
     * @param mode The mode to create the new file with.
     * @param data The data to store at the file's data node.
     * @return The Inode for the new file.
     */
    commitNewSync(path, type, mode, data, syscall) {
        const env_16 = { stack: [], error: void 0, hasError: false };
        try {
            /*
                The root always exists.
                If we don't check this prior to taking steps below,
                we will create a file with name '' in root if path is '/'.
            */
            if (path == '/') {
                throw ErrnoError.With('EEXIST', path, syscall);
            }
            const tx = __addDisposableResource(env_16, this.store.transaction(), false);
            const { dir: parentPath, base: fname } = parse(path);
            const parent = this.findInodeSync(tx, parentPath, syscall);
            const listing = decodeDirListing(this.getSync(tx, parent.data, parentPath, syscall));
            // Check if file already exists.
            if (listing[fname]) {
                throw ErrnoError.With('EEXIST', path, syscall);
            }
            // Commit data.
            const inode = new Inode();
            inode.ino = this.allocNewSync(tx, path, syscall);
            inode.data = this.allocNewSync(tx, path, syscall);
            inode.size = data.length;
            inode.mode = mode | type;
            inode.uid = parent.mode & S_ISUID ? parent.uid : credentials.uid;
            inode.gid = parent.mode & S_ISGID ? parent.gid : credentials.gid;
            // Update and commit parent directory listing.
            tx.setSync(inode.ino, serialize(inode));
            tx.setSync(inode.data, data);
            listing[fname] = inode.ino;
            tx.setSync(parent.data, encodeDirListing(listing));
            tx.commitSync();
            return inode;
        }
        catch (e_16) {
            env_16.error = e_16;
            env_16.hasError = true;
        }
        finally {
            __disposeResources(env_16);
        }
    }
    /**
     * Remove all traces of `path` from the file system.
     * @param path The path to remove from the file system.
     * @param isDir Does the path belong to a directory, or a file?
     * @todo Update mtime.
     */
    async remove(path, isDir, syscall) {
        const env_17 = { stack: [], error: void 0, hasError: false };
        try {
            const tx = __addDisposableResource(env_17, this.store.transaction(), true);
            const { dir: parent, base: fileName } = parse(path), parentNode = await this.findInode(tx, parent, syscall), listing = decodeDirListing(await this.get(tx, parentNode.data, parent, syscall));
            if (!listing[fileName]) {
                throw ErrnoError.With('ENOENT', path, 'remove');
            }
            const fileIno = listing[fileName];
            // Get file inode.
            const fileNode = new Inode(await this.get(tx, fileIno, path, syscall));
            // Remove from directory listing of parent.
            delete listing[fileName];
            if (!isDir && fileNode.toStats().isDirectory()) {
                throw ErrnoError.With('EISDIR', path, 'remove');
            }
            await tx.set(parentNode.data, encodeDirListing(listing));
            if (--fileNode.nlink < 1) {
                // remove file
                await tx.remove(fileNode.data);
                await tx.remove(fileIno);
            }
            // Success.
            await tx.commit();
        }
        catch (e_17) {
            env_17.error = e_17;
            env_17.hasError = true;
        }
        finally {
            const result_9 = __disposeResources(env_17);
            if (result_9)
                await result_9;
        }
    }
    /**
     * Remove all traces of `path` from the file system.
     * @param path The path to remove from the file system.
     * @param isDir Does the path belong to a directory, or a file?
     * @todo Update mtime.
     */
    removeSync(path, isDir, syscall) {
        const env_18 = { stack: [], error: void 0, hasError: false };
        try {
            const tx = __addDisposableResource(env_18, this.store.transaction(), false);
            const { dir: parent, base: fileName } = parse(path), parentNode = this.findInodeSync(tx, parent, syscall), listing = decodeDirListing(this.getSync(tx, parentNode.data, parent, syscall)), fileIno = listing[fileName];
            if (!fileIno) {
                throw ErrnoError.With('ENOENT', path, 'remove');
            }
            // Get file inode.
            const fileNode = new Inode(this.getSync(tx, fileIno, path, syscall));
            // Remove from directory listing of parent.
            delete listing[fileName];
            if (!isDir && fileNode.toStats().isDirectory()) {
                throw ErrnoError.With('EISDIR', path, 'remove');
            }
            // Update directory listing.
            tx.setSync(parentNode.data, encodeDirListing(listing));
            if (--fileNode.nlink < 1) {
                // remove file
                tx.removeSync(fileNode.data);
                tx.removeSync(fileIno);
            }
            // Success.
            tx.commitSync();
        }
        catch (e_18) {
            env_18.error = e_18;
            env_18.hasError = true;
        }
        finally {
            __disposeResources(env_18);
        }
    }
}
