import { pick, serialize } from 'utilium';
import { resolveMountConfig } from '../config.js';
import { Errno, ErrnoError } from '../internal/error.js';
import { FileSystem } from '../internal/filesystem.js';
import { Inode } from '../internal/inode.js';
import { err, info } from '../internal/log.js';
import { Async } from '../mixins/async.js';
import '../polyfills.js';
import { _fnOpt } from './backend.js';
import { InMemory } from './memory.js';
function isRPCMessage(arg) {
    return typeof arg == 'object' && arg != null && '_zenfs' in arg && !!arg._zenfs;
}
const executors = new Map();
function request(request, { port, timeout = 1000, fs } = {}) {
    const stack = '\n' + new Error().stack.slice('Error:'.length);
    if (!port)
        throw err(new ErrnoError(Errno.EINVAL, 'Can not make an RPC request without a port'));
    const { resolve, reject, promise } = Promise.withResolvers();
    const id = Math.random().toString(16).slice(10);
    executors.set(id, { resolve, reject, promise, fs });
    port.postMessage({ ...request, _zenfs: true, id, stack });
    const _ = setTimeout(() => {
        const error = err(new ErrnoError(Errno.EIO, 'RPC Failed', typeof request.args[0] == 'string' ? request.args[0] : '', request.method), {
            fs,
        });
        error.stack += stack;
        reject(error);
        if (typeof _ == 'object')
            _.unref();
    }, timeout);
    return promise;
}
// Why Typescript, WHY does the type need to be asserted even when the method is explicitly checked?
function __requestMethod(req) { }
function __responseMethod(res, ...t) {
    return t.includes(res.method);
}
function handleResponse(response) {
    if (!isRPCMessage(response))
        return;
    if (!executors.has(response.id)) {
        const error = err(new ErrnoError(Errno.EIO, 'Invalid RPC id:' + response.id));
        error.stack += response.stack;
        throw error;
    }
    const { resolve, reject } = executors.get(response.id);
    if (response.error) {
        const e = ErrnoError.fromJSON({ code: 'EIO', errno: Errno.EIO, ...response.error });
        e.stack += response.stack;
        reject(e);
        executors.delete(response.id);
        return;
    }
    resolve(__responseMethod(response, 'stat', 'createFile', 'mkdir') ? new Inode(response.value) : response.value);
    executors.delete(response.id);
    return;
}
export function attach(port, handler) {
    if (!port)
        throw err(new ErrnoError(Errno.EINVAL, 'Cannot attach to non-existent port'));
    info('Attached handler to port: ' + handler.name);
    port['on' in port ? 'on' : 'addEventListener']('message', (message) => {
        handler(typeof message == 'object' && message !== null && 'data' in message ? message.data : message);
    });
}
export function detach(port, handler) {
    if (!port)
        throw err(new ErrnoError(Errno.EINVAL, 'Cannot detach from non-existent port'));
    info('Detached handler from port: ' + handler.name);
    port['off' in port ? 'off' : 'removeEventListener']('message', (message) => {
        handler(typeof message == 'object' && message !== null && 'data' in message ? message.data : message);
    });
}
export function catchMessages(port) {
    const events = [];
    const handler = events.push.bind(events);
    attach(port, handler);
    return async function (fs) {
        detach(port, handler);
        for (const event of events) {
            const request = 'data' in event ? event.data : event;
            await handleRequest(port, fs, request);
        }
    };
}
/**
 * @internal
 */
export async function waitOnline(port) {
    if (!('on' in port))
        return; // Only need to wait in Node.js
    const online = Promise.withResolvers();
    setTimeout(online.reject, 500);
    port.on('online', online.resolve);
    await online.promise;
}
/**
 * PortFS lets you access an FS instance that is running in a port, or the other way around.
 *
 * Note that *direct* synchronous operations are not permitted on the PortFS,
 * regardless of the configuration option of the remote FS.
 * @category Internals
 * @internal
 */
export class PortFS extends Async(FileSystem) {
    /**
     * Constructs a new PortFS instance that connects with the FS running on `options.port`.
     */
    constructor(options) {
        super(0x706f7274, 'portfs');
        this.options = options;
        /**`
         * @hidden
         */
        this._sync = InMemory.create({ label: 'tmpfs:port' });
        this.port = options.port;
        attach(this.port, handleResponse);
    }
    rpc(method, ...args) {
        return request({ method, args }, {
            ...this.options,
            fs: this,
        });
    }
    async ready() {
        await this.rpc('ready');
        await super.ready();
    }
    rename(oldPath, newPath) {
        return this.rpc('rename', oldPath, newPath);
    }
    async stat(path) {
        return new Inode(await this.rpc('stat', path));
    }
    async touch(path, metadata) {
        await this.rpc('touch', path, serialize(metadata instanceof Inode ? metadata : new Inode(metadata)));
    }
    sync(path) {
        return this.rpc('sync', path);
    }
    async createFile(path, options) {
        return new Inode(await this.rpc('createFile', path, options));
    }
    unlink(path) {
        return this.rpc('unlink', path);
    }
    rmdir(path) {
        return this.rpc('rmdir', path);
    }
    async mkdir(path, options) {
        return new Inode(await this.rpc('mkdir', path, options));
    }
    readdir(path) {
        return this.rpc('readdir', path);
    }
    exists(path) {
        return this.rpc('exists', path);
    }
    link(srcpath, dstpath) {
        return this.rpc('link', srcpath, dstpath);
    }
    async read(path, buffer, start, end) {
        buffer.set(await this.rpc('read', path, buffer, start, end));
    }
    write(path, buffer, offset) {
        return this.rpc('write', path, buffer, offset);
    }
}
/** @internal */
export async function handleRequest(port, fs, request) {
    if (!isRPCMessage(request))
        return;
    let value, error;
    const transferList = [];
    try {
        switch (request.method) {
            case 'read': {
                __requestMethod(request);
                const [path, buffer, start, end] = request.args;
                await fs.read(path, buffer, start, end);
                value = buffer;
                break;
            }
            case 'stat':
            case 'createFile':
            case 'mkdir': {
                __requestMethod(request);
                // @ts-expect-error 2556
                const inode = await fs[request.method](...request.args);
                value = serialize(inode instanceof Inode ? inode : new Inode(inode));
                break;
            }
            case 'touch': {
                __requestMethod(request);
                const [path, metadata] = request.args;
                await fs.touch(path, new Inode(metadata));
                value = undefined;
                break;
            }
            default:
                // @ts-expect-error 2556
                value = (await fs[request.method](...request.args));
        }
    }
    catch (e) {
        error = e instanceof ErrnoError ? e.toJSON() : pick(e, 'message', 'stack');
    }
    port.postMessage({ _zenfs: true, ...pick(request, 'id', 'method', 'stack'), error, value }, transferList);
}
export function attachFS(port, fs) {
    attach(port, request => handleRequest(port, fs, request));
}
export function detachFS(port, fs) {
    detach(port, request => handleRequest(port, fs, request));
}
const _Port = {
    name: 'Port',
    options: {
        port: {
            type: _fnOpt('RPCPort', (port) => typeof (port === null || port === void 0 ? void 0 : port.postMessage) == 'function'),
            required: true,
        },
        timeout: { type: 'number', required: false },
    },
    create(options) {
        return new PortFS(options);
    },
};
/**
 * A backend for usage with ports and workers. See the examples below.
 *
 * #### Accessing an FS on a remote Worker from the main thread
 *
 * Main:
 *
 * ```ts
 * import { configure } from '@zenfs/core';
 * import { Port } from '@zenfs/port';
 * import { Worker } from 'node:worker_threads';
 *
 * const worker = new Worker('worker.js');
 *
 * await configure({
 * 	mounts: {
 * 		'/worker': {
 * 			backend: Port,
 * 			port: worker,
 * 		},
 * 	},
 * });
 * ```
 *
 * Worker:
 *
 * ```ts
 * import { InMemory, resolveRemoteMount, attachFS } from '@zenfs/core';
 * import { parentPort } from 'node:worker_threads';
 *
 * await resolveRemoteMount(parentPort, { backend: InMemory, name: 'tmp' });
 * ```
 *
 * If you are using using web workers, you would use `self` instead of importing `parentPort` in the worker, and would not need to import `Worker` in the main thread.
 *
 * #### Using with multiple ports on the same thread
 *
 * ```ts
 * import { InMemory, fs, resolveMountConfig, resolveRemoteMount, Port } from '@zenfs/core';
 * import { MessageChannel } from 'node:worker_threads';
 *
 * const { port1: localPort, port2: remotePort } = new MessageChannel();
 *
 * fs.mount('/remote', await resolveRemoteMount(remotePort, { backend: InMemory, name: 'tmp' }));
 * fs.mount('/port', await resolveMountConfig({ backend: Port, port: localPort }));
 *
 * const content = 'FS is in a port';
 *
 * await fs.promises.writeFile('/port/test', content);
 *
 * fs.readFileSync('/remote/test', 'utf8'); // FS is in a port
 * await fs.promises.readFile('/port/test', 'utf8'); // FS is in a port
 * ```
 *
 * @category Backends and Configuration
 */
export const Port = _Port;
/**
 * @category Backends and Configuration
 */
export async function resolveRemoteMount(port, config, _depth = 0) {
    const stopAndReplay = catchMessages(port);
    const fs = await resolveMountConfig(config, _depth);
    attachFS(port, fs);
    await stopAndReplay(fs);
    info('Resolved remote mount: ' + fs.toString());
    return fs;
}
