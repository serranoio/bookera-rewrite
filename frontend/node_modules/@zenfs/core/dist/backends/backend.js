import { Errno, ErrnoError } from '../internal/error.js';
import { debug, err } from '../internal/log.js';
/**
 * @category Backends and Configuration
 * @internal
 */
export function isBackend(arg) {
    return arg != null && typeof arg == 'object' && 'create' in arg && typeof arg.create == 'function';
}
/**
 * Use a function as the type of an option, but don't treat it as a class.
 *
 * Optionally sets the name of a function, useful for error messages.
 * @category Backends and Configuration
 * @internal
 */
export function _fnOpt(name, fn) {
    Object.defineProperty(fn, 'prototype', { value: undefined });
    if (name)
        Object.defineProperty(fn, 'name', { value: name });
    return fn;
}
/**
 * Checks that `options` object is valid for the file system options.
 * @category Backends and Configuration
 * @internal
 */
export function checkOptions(backend, options) {
    if (typeof options != 'object' || options === null) {
        throw err(new ErrnoError(Errno.EINVAL, 'Invalid options'));
    }
    // Check for required options.
    for (const [optName, opt] of Object.entries(backend.options)) {
        const value = options === null || options === void 0 ? void 0 : options[optName];
        if (value === undefined || value === null) {
            if (!opt.required) {
                debug('Using default for option: ' + optName);
                continue;
            }
            throw err(new ErrnoError(Errno.EINVAL, 'Missing required option: ' + optName));
        }
        const isType = (type, _ = value) => {
            var _a;
            return typeof type == 'function'
                ? Symbol.hasInstance in type && type.prototype
                    ? value instanceof type
                    : type(value)
                : typeof value === type || ((_a = value === null || value === void 0 ? void 0 : value.constructor) === null || _a === void 0 ? void 0 : _a.name) === type;
        };
        if (Array.isArray(opt.type) ? opt.type.some(v => isType(v)) : isType(opt.type))
            continue;
        // The type of the value as a string
        const type = typeof value == 'object' && 'constructor' in value ? value.constructor.name : typeof value;
        // The expected type (as a string)
        const name = (type) => (typeof type == 'function' ? (type.name != 'type' ? type.name : type.toString()) : type);
        const expected = Array.isArray(opt.type) ? `one of ${opt.type.map(name).join(', ')}` : name(opt.type);
        throw err(new ErrnoError(Errno.EINVAL, `Incorrect type for "${optName}": ${type} (expected ${expected})`));
    }
}
/**
 * @internal
 * @category Backends and Configuration
 */
export function isBackendConfig(arg) {
    return arg != null && typeof arg == 'object' && 'backend' in arg && isBackend(arg.backend);
}
