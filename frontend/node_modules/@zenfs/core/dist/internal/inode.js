var __esDecorate = (this && this.__esDecorate) || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for (var i = decorators.length - 1; i >= 0; i--) {
        var context = {};
        for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access) context.access[p] = contextIn.access[p];
        context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
            if (result === void 0) continue;
            if (result === null || typeof result !== "object") throw new TypeError("Object expected");
            if (_ = accept(result.get)) descriptor.get = _;
            if (_ = accept(result.set)) descriptor.set = _;
            if (_ = accept(result.init)) initializers.unshift(_);
        }
        else if (_ = accept(result)) {
            if (kind === "field") initializers.unshift(_);
            else descriptor[key] = _;
        }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
};
var __runInitializers = (this && this.__runInitializers) || function (thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i = 0; i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    }
    return useValue ? value : void 0;
};
var __setFunctionName = (this && this.__setFunctionName) || function (f, name, prefix) {
    if (typeof name === "symbol") name = name.description ? "[".concat(name.description, "]") : "";
    return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
};
import { deserialize, member, pick, randomInt, sizeof, struct, types as t } from 'utilium';
import * as c from '../vfs/constants.js';
import { size_max } from '../vfs/constants.js';
import { Stats } from '../vfs/stats.js';
import { defaultContext } from './contexts.js';
import { Errno, ErrnoError } from './error.js';
import { crit } from './log.js';
/**
 * Root inode
 * @hidden
 */
export const rootIno = 0;
const maxAttributeValueSize = 1024;
let Attribute = (() => {
    var _a, _b;
    let _classDecorators = [struct()];
    let _classDescriptor;
    let _classExtraInitializers = [];
    let _classThis;
    let _keySize_decorators;
    let _keySize_initializers = [];
    let _keySize_extraInitializers = [];
    let _valueSize_decorators;
    let _valueSize_initializers = [];
    let _valueSize_extraInitializers = [];
    let __key_decorators;
    let __key_initializers = [];
    let __key_extraInitializers = [];
    let __value_decorators;
    let __value_initializers = [];
    let __value_extraInitializers = [];
    var Attribute = _classThis = class {
        get key() {
            return this._key;
        }
        set key(value) {
            this._key = value;
            this.keySize = value.length;
        }
        get value() {
            return this._value.subarray(0, this.valueSize);
        }
        set value(value) {
            this._value = value;
            this.valueSize = value.length;
        }
        constructor(key, value) {
            this.keySize = __runInitializers(this, _keySize_initializers, 0);
            this.valueSize = (__runInitializers(this, _keySize_extraInitializers), __runInitializers(this, _valueSize_initializers, 0));
            this._key = (__runInitializers(this, _valueSize_extraInitializers), __runInitializers(this, __key_initializers, ''));
            this._value = (__runInitializers(this, __key_extraInitializers), __runInitializers(this, __value_initializers, new Uint8Array(maxAttributeValueSize)));
            __runInitializers(this, __value_extraInitializers);
            if (key)
                this.key = key;
            if (value)
                this.value = value;
        }
    };
    __setFunctionName(_classThis, "Attribute");
    (() => {
        const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(null) : void 0;
        _keySize_decorators = [(_a = t).uint32.bind(_a)];
        _valueSize_decorators = [(_b = t).uint32.bind(_b)];
        __key_decorators = [t.char('keySize')];
        __value_decorators = [t.uint8('valueSize')];
        __esDecorate(null, null, _keySize_decorators, { kind: "field", name: "keySize", static: false, private: false, access: { has: obj => "keySize" in obj, get: obj => obj.keySize, set: (obj, value) => { obj.keySize = value; } }, metadata: _metadata }, _keySize_initializers, _keySize_extraInitializers);
        __esDecorate(null, null, _valueSize_decorators, { kind: "field", name: "valueSize", static: false, private: false, access: { has: obj => "valueSize" in obj, get: obj => obj.valueSize, set: (obj, value) => { obj.valueSize = value; } }, metadata: _metadata }, _valueSize_initializers, _valueSize_extraInitializers);
        __esDecorate(null, null, __key_decorators, { kind: "field", name: "_key", static: false, private: false, access: { has: obj => "_key" in obj, get: obj => obj._key, set: (obj, value) => { obj._key = value; } }, metadata: _metadata }, __key_initializers, __key_extraInitializers);
        __esDecorate(null, null, __value_decorators, { kind: "field", name: "_value", static: false, private: false, access: { has: obj => "_value" in obj, get: obj => obj._value, set: (obj, value) => { obj._value = value; } }, metadata: _metadata }, __value_initializers, __value_extraInitializers);
        __esDecorate(null, _classDescriptor = { value: _classThis }, _classDecorators, { kind: "class", name: _classThis.name, metadata: _metadata }, null, _classExtraInitializers);
        Attribute = _classThis = _classDescriptor.value;
        if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
        __runInitializers(_classThis, _classExtraInitializers);
    })();
    return Attribute = _classThis;
})();
/**
 * Extended attributes
 * @category Internals
 * @internal
 */
let Attributes = (() => {
    var _a;
    let _classDecorators = [struct()];
    let _classDescriptor;
    let _classExtraInitializers = [];
    let _classThis;
    let _size_decorators;
    let _size_initializers = [];
    let _size_extraInitializers = [];
    let _data_decorators;
    let _data_initializers = [];
    let _data_extraInitializers = [];
    var Attributes = _classThis = class {
        has(name) {
            return this.data.some(entry => entry.key == name);
        }
        get(name) {
            return this.data.find(entry => entry.key == name);
        }
        set(name, value) {
            const attr = this.get(name);
            if (attr) {
                attr.value = value;
                return;
            }
            this.data.push(new Attribute(name, value));
            this.size++;
        }
        remove(name) {
            const index = this.data.findIndex(entry => entry.key == name);
            if (index === -1)
                return false;
            this.data.splice(index, 1);
            this.size--;
            return true;
        }
        keys() {
            return this.data.map(entry => entry.key);
        }
        values() {
            return this.data.map(entry => entry.value);
        }
        entries() {
            return this.data.map(entry => [entry.key, entry.value]);
        }
        constructor() {
            this.size = __runInitializers(this, _size_initializers, 0);
            this.data = (__runInitializers(this, _size_extraInitializers), __runInitializers(this, _data_initializers, []));
            __runInitializers(this, _data_extraInitializers);
        }
    };
    __setFunctionName(_classThis, "Attributes");
    (() => {
        const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(null) : void 0;
        _size_decorators = [(_a = t).uint32.bind(_a)];
        _data_decorators = [member(Attribute, 'size')];
        __esDecorate(null, null, _size_decorators, { kind: "field", name: "size", static: false, private: false, access: { has: obj => "size" in obj, get: obj => obj.size, set: (obj, value) => { obj.size = value; } }, metadata: _metadata }, _size_initializers, _size_extraInitializers);
        __esDecorate(null, null, _data_decorators, { kind: "field", name: "data", static: false, private: false, access: { has: obj => "data" in obj, get: obj => obj.data, set: (obj, value) => { obj.data = value; } }, metadata: _metadata }, _data_initializers, _data_extraInitializers);
        __esDecorate(null, _classDescriptor = { value: _classThis }, _classDecorators, { kind: "class", name: _classThis.name, metadata: _metadata }, null, _classExtraInitializers);
        Attributes = _classThis = _classDescriptor.value;
        if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
        __runInitializers(_classThis, _classExtraInitializers);
    })();
    return Attributes = _classThis;
})();
export { Attributes };
/**
 * @internal @hidden
 */
export const _inode_fields = [
    'ino',
    'data',
    'size',
    'mode',
    'flags',
    'nlink',
    'uid',
    'gid',
    'atimeMs',
    'birthtimeMs',
    'mtimeMs',
    'ctimeMs',
    'version',
];
/**
 * Represents which version of the `Inode` format we are on.
 * 1. 58 bytes. The first member was called `ino` but used as the ID for data.
 * 2. 66 bytes. Renamed the first member from `ino` to `data` and added a separate `ino` field
 * 3. 72 bytes. Changed the ID fields from 64 to 32 bits and added `flags`.
 * 4. (current) Added extended attributes. At least 128 bytes.
 * @internal @hidden
 */
export const _inode_version = 4;
/**
 * Inode flags (FS_IOC_GETFLAGS / FS_IOC_SETFLAGS)
 * @see `FS_*_FL` in `include/uapi/linux/fs.h` (around L250)
 * @experimental
 */
export var InodeFlags;
(function (InodeFlags) {
    /** Secure deletion */
    InodeFlags[InodeFlags["SecureRm"] = 1] = "SecureRm";
    /** Undelete */
    InodeFlags[InodeFlags["Undelete"] = 2] = "Undelete";
    /** Compress file */
    InodeFlags[InodeFlags["Compress"] = 4] = "Compress";
    /** Synchronous updates */
    InodeFlags[InodeFlags["Sync"] = 8] = "Sync";
    /** Immutable file */
    InodeFlags[InodeFlags["Immutable"] = 16] = "Immutable";
    /** Writes to file may only append */
    InodeFlags[InodeFlags["Append"] = 32] = "Append";
    /** do not dump file */
    InodeFlags[InodeFlags["NoDump"] = 64] = "NoDump";
    /** do not update atime */
    InodeFlags[InodeFlags["NoAtime"] = 128] = "NoAtime";
    // Reserved for compression usage...
    InodeFlags[InodeFlags["Dirty"] = 256] = "Dirty";
    /** One or more compressed clusters */
    InodeFlags[InodeFlags["CompressBlk"] = 512] = "CompressBlk";
    /** Don't compress */
    InodeFlags[InodeFlags["NoCompress"] = 1024] = "NoCompress";
    // End compression flags --- maybe not all used
    /** Encrypted file */
    InodeFlags[InodeFlags["Encrypt"] = 2048] = "Encrypt";
    /** btree format dir */
    InodeFlags[InodeFlags["Btree"] = 4096] = "Btree";
    /** hash-indexed directory */
    // eslint-disable-next-line @typescript-eslint/no-duplicate-enum-values
    InodeFlags[InodeFlags["Index"] = 4096] = "Index";
    /** AFS directory */
    InodeFlags[InodeFlags["IMagic"] = 8192] = "IMagic";
    /** Reserved for ext3 */
    InodeFlags[InodeFlags["JournalData"] = 16384] = "JournalData";
    /** file tail should not be merged */
    InodeFlags[InodeFlags["NoTail"] = 32768] = "NoTail";
    /** dirsync behaviour (directories only) */
    InodeFlags[InodeFlags["DirSync"] = 65536] = "DirSync";
    /** Top of directory hierarchies*/
    InodeFlags[InodeFlags["TopDir"] = 131072] = "TopDir";
    /** Reserved for ext4 */
    InodeFlags[InodeFlags["HugeFile"] = 262144] = "HugeFile";
    /** Extents */
    InodeFlags[InodeFlags["Extent"] = 524288] = "Extent";
    /** Verity protected inode */
    InodeFlags[InodeFlags["Verity"] = 1048576] = "Verity";
    /** Inode used for large EA */
    InodeFlags[InodeFlags["EaInode"] = 2097152] = "EaInode";
    /** Reserved for ext4 */
    InodeFlags[InodeFlags["EofBlocks"] = 4194304] = "EofBlocks";
    /** Do not cow file */
    InodeFlags[InodeFlags["NoCow"] = 8388608] = "NoCow";
    /** Inode is DAX */
    InodeFlags[InodeFlags["Dax"] = 33554432] = "Dax";
    /** Reserved for ext4 */
    InodeFlags[InodeFlags["InlineData"] = 268435456] = "InlineData";
    /** Create with parents projid */
    InodeFlags[InodeFlags["ProjInherit"] = 536870912] = "ProjInherit";
    /** Folder is case insensitive */
    InodeFlags[InodeFlags["CaseFold"] = 1073741824] = "CaseFold";
    /** reserved for ext2 lib */
    InodeFlags[InodeFlags["Reserved"] = 2147483648] = "Reserved";
})(InodeFlags || (InodeFlags = {}));
/** User visible flags */
export const userVisibleFlags = 0x0003dfff;
/** User modifiable flags */
export const userModifiableFlags = 0x000380ff;
/**
 * Generic inode definition that can easily be serialized.
 * @category Internals
 * @internal
 */
let Inode = (() => {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r;
    let _classDecorators = [struct()];
    let _classDescriptor;
    let _classExtraInitializers = [];
    let _classThis;
    let _data_decorators;
    let _data_initializers = [];
    let _data_extraInitializers = [];
    let ___data_old_decorators;
    let ___data_old_initializers = [];
    let ___data_old_extraInitializers = [];
    let _size_decorators;
    let _size_initializers = [];
    let _size_extraInitializers = [];
    let _mode_decorators;
    let _mode_initializers = [];
    let _mode_extraInitializers = [];
    let _nlink_decorators;
    let _nlink_initializers = [];
    let _nlink_extraInitializers = [];
    let _uid_decorators;
    let _uid_initializers = [];
    let _uid_extraInitializers = [];
    let _gid_decorators;
    let _gid_initializers = [];
    let _gid_extraInitializers = [];
    let _atimeMs_decorators;
    let _atimeMs_initializers = [];
    let _atimeMs_extraInitializers = [];
    let _birthtimeMs_decorators;
    let _birthtimeMs_initializers = [];
    let _birthtimeMs_extraInitializers = [];
    let _mtimeMs_decorators;
    let _mtimeMs_initializers = [];
    let _mtimeMs_extraInitializers = [];
    let _ctimeMs_decorators;
    let _ctimeMs_initializers = [];
    let _ctimeMs_extraInitializers = [];
    let _ino_decorators;
    let _ino_initializers = [];
    let _ino_extraInitializers = [];
    let ___ino_old_decorators;
    let ___ino_old_initializers = [];
    let ___ino_old_extraInitializers = [];
    let _flags_decorators;
    let _flags_initializers = [];
    let _flags_extraInitializers = [];
    let ___after_flags_decorators;
    let ___after_flags_initializers = [];
    let ___after_flags_extraInitializers = [];
    let _version_decorators;
    let _version_initializers = [];
    let _version_extraInitializers = [];
    let ___padding_decorators;
    let ___padding_initializers = [];
    let ___padding_extraInitializers = [];
    let _attributes_decorators;
    let _attributes_initializers = [];
    let _attributes_extraInitializers = [];
    var Inode = _classThis = class {
        constructor(data) {
            this.data = __runInitializers(this, _data_initializers, randomInt(0, size_max));
            /** For future use */
            this.__data_old = (__runInitializers(this, _data_extraInitializers), __runInitializers(this, ___data_old_initializers, 0));
            this.size = (__runInitializers(this, ___data_old_extraInitializers), __runInitializers(this, _size_initializers, 0));
            this.mode = (__runInitializers(this, _size_extraInitializers), __runInitializers(this, _mode_initializers, 0));
            this.nlink = (__runInitializers(this, _mode_extraInitializers), __runInitializers(this, _nlink_initializers, 1));
            this.uid = (__runInitializers(this, _nlink_extraInitializers), __runInitializers(this, _uid_initializers, 0));
            this.gid = (__runInitializers(this, _uid_extraInitializers), __runInitializers(this, _gid_initializers, 0));
            this.atimeMs = (__runInitializers(this, _gid_extraInitializers), __runInitializers(this, _atimeMs_initializers, Date.now()));
            this.birthtimeMs = (__runInitializers(this, _atimeMs_extraInitializers), __runInitializers(this, _birthtimeMs_initializers, Date.now()));
            this.mtimeMs = (__runInitializers(this, _birthtimeMs_extraInitializers), __runInitializers(this, _mtimeMs_initializers, Date.now()));
            /**
             * The time the inode was changed.
             *
             * This is automatically updated whenever changed are made using `update()`.
             */
            this.ctimeMs = (__runInitializers(this, _mtimeMs_extraInitializers), __runInitializers(this, _ctimeMs_initializers, Date.now()));
            this.ino = (__runInitializers(this, _ctimeMs_extraInitializers), __runInitializers(this, _ino_initializers, randomInt(0, size_max)));
            /** For future use */
            this.__ino_old = (__runInitializers(this, _ino_extraInitializers), __runInitializers(this, ___ino_old_initializers, 0));
            this.flags = (__runInitializers(this, ___ino_old_extraInitializers), __runInitializers(this, _flags_initializers, 0));
            /** For future use */
            this.__after_flags = (__runInitializers(this, _flags_extraInitializers), __runInitializers(this, ___after_flags_initializers, 0));
            /**
             * The "version" of the inode/data.
             *
             * Unrelated to the inode format!
             */
            this.version = (__runInitializers(this, ___after_flags_extraInitializers), __runInitializers(this, _version_initializers, 0));
            /** Pad to 128 bytes */
            this.__padding = (__runInitializers(this, _version_extraInitializers), __runInitializers(this, ___padding_initializers, []));
            this.attributes = (__runInitializers(this, ___padding_extraInitializers), __runInitializers(this, _attributes_initializers, new Attributes()));
            __runInitializers(this, _attributes_extraInitializers);
            if (!data)
                return;
            if (!('byteLength' in data)) {
                Object.assign(this, data);
                return;
            }
            if (data.byteLength < sizeof(Inode))
                throw crit(new ErrnoError(Errno.EIO, 'Buffer is too small to create an inode'));
            deserialize(this, data);
        }
        toString() {
            return `<Inode ${this.ino}>`;
        }
        toJSON() {
            return {
                ...pick(this, _inode_fields),
                attributes: this.attributes,
            };
        }
        /**
         * Handy function that converts the Inode to a Node Stats object.
         */
        toStats() {
            return new Stats(this);
        }
        /**
         * Updates the Inode using information from the stats object. Used by file
         * systems at sync time, e.g.:
         * - Program opens file and gets a File object.
         * - Program mutates file. File object is responsible for maintaining
         *   metadata changes locally -- typically in a Stats object.
         * - Program closes file. File object's metadata changes are synced with the
         *   file system.
         * @returns whether any changes have occurred.
         */
        update(data) {
            if (!data)
                return false;
            let hasChanged = false;
            for (const key of _inode_fields) {
                if (data[key] === undefined)
                    continue;
                // When multiple StoreFSes are used in a single stack, the differing IDs end up here.
                if (key == 'ino' || key == 'data')
                    continue;
                if (this[key] === data[key])
                    continue;
                if (key == 'atimeMs' && this.flags & InodeFlags.NoAtime)
                    continue;
                this[key] = data[key];
                hasChanged = true;
            }
            if (data.attributes) {
                this.attributes = data.attributes;
                hasChanged = true;
            }
            if (hasChanged)
                this.ctimeMs = Date.now();
            return hasChanged;
        }
    };
    __setFunctionName(_classThis, "Inode");
    (() => {
        const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(null) : void 0;
        _data_decorators = [(_a = t).uint32.bind(_a)];
        ___data_old_decorators = [(_b = t).uint32.bind(_b)];
        _size_decorators = [(_c = t).uint32.bind(_c)];
        _mode_decorators = [(_d = t).uint16.bind(_d)];
        _nlink_decorators = [(_e = t).uint32.bind(_e)];
        _uid_decorators = [(_f = t).uint32.bind(_f)];
        _gid_decorators = [(_g = t).uint32.bind(_g)];
        _atimeMs_decorators = [(_h = t).float64.bind(_h)];
        _birthtimeMs_decorators = [(_j = t).float64.bind(_j)];
        _mtimeMs_decorators = [(_k = t).float64.bind(_k)];
        _ctimeMs_decorators = [(_l = t).float64.bind(_l)];
        _ino_decorators = [(_m = t).uint32.bind(_m)];
        ___ino_old_decorators = [(_o = t).uint32.bind(_o)];
        _flags_decorators = [(_p = t).uint32.bind(_p)];
        ___after_flags_decorators = [(_q = t).uint16.bind(_q)];
        _version_decorators = [(_r = t).uint32.bind(_r)];
        ___padding_decorators = [t.uint8(48)];
        _attributes_decorators = [member(Attributes)];
        __esDecorate(null, null, _data_decorators, { kind: "field", name: "data", static: false, private: false, access: { has: obj => "data" in obj, get: obj => obj.data, set: (obj, value) => { obj.data = value; } }, metadata: _metadata }, _data_initializers, _data_extraInitializers);
        __esDecorate(null, null, ___data_old_decorators, { kind: "field", name: "__data_old", static: false, private: false, access: { has: obj => "__data_old" in obj, get: obj => obj.__data_old, set: (obj, value) => { obj.__data_old = value; } }, metadata: _metadata }, ___data_old_initializers, ___data_old_extraInitializers);
        __esDecorate(null, null, _size_decorators, { kind: "field", name: "size", static: false, private: false, access: { has: obj => "size" in obj, get: obj => obj.size, set: (obj, value) => { obj.size = value; } }, metadata: _metadata }, _size_initializers, _size_extraInitializers);
        __esDecorate(null, null, _mode_decorators, { kind: "field", name: "mode", static: false, private: false, access: { has: obj => "mode" in obj, get: obj => obj.mode, set: (obj, value) => { obj.mode = value; } }, metadata: _metadata }, _mode_initializers, _mode_extraInitializers);
        __esDecorate(null, null, _nlink_decorators, { kind: "field", name: "nlink", static: false, private: false, access: { has: obj => "nlink" in obj, get: obj => obj.nlink, set: (obj, value) => { obj.nlink = value; } }, metadata: _metadata }, _nlink_initializers, _nlink_extraInitializers);
        __esDecorate(null, null, _uid_decorators, { kind: "field", name: "uid", static: false, private: false, access: { has: obj => "uid" in obj, get: obj => obj.uid, set: (obj, value) => { obj.uid = value; } }, metadata: _metadata }, _uid_initializers, _uid_extraInitializers);
        __esDecorate(null, null, _gid_decorators, { kind: "field", name: "gid", static: false, private: false, access: { has: obj => "gid" in obj, get: obj => obj.gid, set: (obj, value) => { obj.gid = value; } }, metadata: _metadata }, _gid_initializers, _gid_extraInitializers);
        __esDecorate(null, null, _atimeMs_decorators, { kind: "field", name: "atimeMs", static: false, private: false, access: { has: obj => "atimeMs" in obj, get: obj => obj.atimeMs, set: (obj, value) => { obj.atimeMs = value; } }, metadata: _metadata }, _atimeMs_initializers, _atimeMs_extraInitializers);
        __esDecorate(null, null, _birthtimeMs_decorators, { kind: "field", name: "birthtimeMs", static: false, private: false, access: { has: obj => "birthtimeMs" in obj, get: obj => obj.birthtimeMs, set: (obj, value) => { obj.birthtimeMs = value; } }, metadata: _metadata }, _birthtimeMs_initializers, _birthtimeMs_extraInitializers);
        __esDecorate(null, null, _mtimeMs_decorators, { kind: "field", name: "mtimeMs", static: false, private: false, access: { has: obj => "mtimeMs" in obj, get: obj => obj.mtimeMs, set: (obj, value) => { obj.mtimeMs = value; } }, metadata: _metadata }, _mtimeMs_initializers, _mtimeMs_extraInitializers);
        __esDecorate(null, null, _ctimeMs_decorators, { kind: "field", name: "ctimeMs", static: false, private: false, access: { has: obj => "ctimeMs" in obj, get: obj => obj.ctimeMs, set: (obj, value) => { obj.ctimeMs = value; } }, metadata: _metadata }, _ctimeMs_initializers, _ctimeMs_extraInitializers);
        __esDecorate(null, null, _ino_decorators, { kind: "field", name: "ino", static: false, private: false, access: { has: obj => "ino" in obj, get: obj => obj.ino, set: (obj, value) => { obj.ino = value; } }, metadata: _metadata }, _ino_initializers, _ino_extraInitializers);
        __esDecorate(null, null, ___ino_old_decorators, { kind: "field", name: "__ino_old", static: false, private: false, access: { has: obj => "__ino_old" in obj, get: obj => obj.__ino_old, set: (obj, value) => { obj.__ino_old = value; } }, metadata: _metadata }, ___ino_old_initializers, ___ino_old_extraInitializers);
        __esDecorate(null, null, _flags_decorators, { kind: "field", name: "flags", static: false, private: false, access: { has: obj => "flags" in obj, get: obj => obj.flags, set: (obj, value) => { obj.flags = value; } }, metadata: _metadata }, _flags_initializers, _flags_extraInitializers);
        __esDecorate(null, null, ___after_flags_decorators, { kind: "field", name: "__after_flags", static: false, private: false, access: { has: obj => "__after_flags" in obj, get: obj => obj.__after_flags, set: (obj, value) => { obj.__after_flags = value; } }, metadata: _metadata }, ___after_flags_initializers, ___after_flags_extraInitializers);
        __esDecorate(null, null, _version_decorators, { kind: "field", name: "version", static: false, private: false, access: { has: obj => "version" in obj, get: obj => obj.version, set: (obj, value) => { obj.version = value; } }, metadata: _metadata }, _version_initializers, _version_extraInitializers);
        __esDecorate(null, null, ___padding_decorators, { kind: "field", name: "__padding", static: false, private: false, access: { has: obj => "__padding" in obj, get: obj => obj.__padding, set: (obj, value) => { obj.__padding = value; } }, metadata: _metadata }, ___padding_initializers, ___padding_extraInitializers);
        __esDecorate(null, null, _attributes_decorators, { kind: "field", name: "attributes", static: false, private: false, access: { has: obj => "attributes" in obj, get: obj => obj.attributes, set: (obj, value) => { obj.attributes = value; } }, metadata: _metadata }, _attributes_initializers, _attributes_extraInitializers);
        __esDecorate(null, _classDescriptor = { value: _classThis }, _classDecorators, { kind: "class", name: _classThis.name, metadata: _metadata }, null, _classExtraInitializers);
        Inode = _classThis = _classDescriptor.value;
        if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
        __runInitializers(_classThis, _classExtraInitializers);
    })();
    return Inode = _classThis;
})();
export { Inode };
export function isFile(metadata) {
    return (metadata.mode & c.S_IFMT) === c.S_IFREG;
}
export function isDirectory(metadata) {
    return (metadata.mode & c.S_IFMT) === c.S_IFDIR;
}
export function isSymbolicLink(metadata) {
    return (metadata.mode & c.S_IFMT) === c.S_IFLNK;
}
export function isSocket(metadata) {
    return (metadata.mode & c.S_IFMT) === c.S_IFSOCK;
}
export function isBlockDevice(metadata) {
    return (metadata.mode & c.S_IFMT) === c.S_IFBLK;
}
export function isCharacterDevice(metadata) {
    return (metadata.mode & c.S_IFMT) === c.S_IFCHR;
}
export function isFIFO(metadata) {
    return (metadata.mode & c.S_IFMT) === c.S_IFIFO;
}
/**
 * Checks if a given user/group has access to this item
 * @param access The requested access, combination of `W_OK`, `R_OK`, and `X_OK`
 * @internal
 */
export function hasAccess($, inode, access) {
    const credentials = ($ === null || $ === void 0 ? void 0 : $.credentials) || defaultContext.credentials;
    if (isSymbolicLink(inode) || credentials.euid === 0 || credentials.egid === 0)
        return true;
    let perm = 0;
    if (credentials.uid === inode.uid) {
        if (inode.mode & c.S_IRUSR)
            perm |= c.R_OK;
        if (inode.mode & c.S_IWUSR)
            perm |= c.W_OK;
        if (inode.mode & c.S_IXUSR)
            perm |= c.X_OK;
    }
    if (credentials.gid === inode.gid || credentials.groups.includes(Number(inode.gid))) {
        if (inode.mode & c.S_IRGRP)
            perm |= c.R_OK;
        if (inode.mode & c.S_IWGRP)
            perm |= c.W_OK;
        if (inode.mode & c.S_IXGRP)
            perm |= c.X_OK;
    }
    if (inode.mode & c.S_IROTH)
        perm |= c.R_OK;
    if (inode.mode & c.S_IWOTH)
        perm |= c.W_OK;
    if (inode.mode & c.S_IXOTH)
        perm |= c.X_OK;
    return (perm & access) === access;
}
