/* eslint-disable @typescript-eslint/require-await */
import { _throw } from 'utilium';
import { S_IFDIR, S_IFMT, S_IFREG, S_ISGID, S_ISUID } from '../vfs/constants.js';
import { dirname, join, relative } from '../path.js';
import { ErrnoError } from './error.js';
import { Index } from './file_index.js';
import { FileSystem } from './filesystem.js';
import { Inode } from './inode.js';
/**
 * A file system that uses an `Index` for metadata.
 * @category Internals
 * @internal
 */
export class IndexFS extends FileSystem {
    constructor(id, name, index = new Index()) {
        super(id, name);
        this.index = index;
    }
    usage() {
        return this.index.usage();
    }
    /**
     * Finds all the paths in the index that need to be moved for a rename
     */
    pathsForRename(oldPath, newPath) {
        if (!this.index.has(oldPath))
            throw ErrnoError.With('ENOENT', oldPath, 'rename');
        if ((dirname(newPath) + '/').startsWith(oldPath + '/'))
            throw ErrnoError.With('EBUSY', dirname(oldPath), 'rename');
        const toRename = [];
        for (const [from, inode] of this.index.entries()) {
            const rel = relative(oldPath, from);
            if (rel.startsWith('..'))
                continue;
            let to = join(newPath, rel);
            if (to.endsWith('/'))
                to = to.slice(0, -1);
            toRename.push({ from, to, inode });
        }
        return toRename;
    }
    async rename(oldPath, newPath) {
        if (oldPath == newPath)
            return;
        for (const { from, to, inode } of this.pathsForRename(oldPath, newPath)) {
            const data = new Uint8Array(inode.size);
            await this.read(from, data, 0, inode.size);
            this.index.delete(from);
            this.index.set(to, inode);
            await this.write(to, data, 0);
        }
        await this.remove(oldPath);
    }
    renameSync(oldPath, newPath) {
        if (oldPath == newPath)
            return;
        for (const { from, to, inode } of this.pathsForRename(oldPath, newPath)) {
            const data = new Uint8Array(inode.size);
            this.readSync(from, data, 0, inode.size);
            this.index.delete(from);
            this.index.set(to, inode);
            this.writeSync(to, data, 0);
        }
        this.removeSync(oldPath);
    }
    async stat(path) {
        const inode = this.index.get(path);
        if (!inode)
            throw ErrnoError.With('ENOENT', path, 'stat');
        return inode;
    }
    statSync(path) {
        const inode = this.index.get(path);
        if (!inode)
            throw ErrnoError.With('ENOENT', path, 'stat');
        return inode;
    }
    async touch(path, metadata) {
        var _a;
        const inode = (_a = this.index.get(path)) !== null && _a !== void 0 ? _a : _throw(ErrnoError.With('ENOENT', path, 'touch'));
        inode.update(metadata);
    }
    touchSync(path, metadata) {
        var _a;
        const inode = (_a = this.index.get(path)) !== null && _a !== void 0 ? _a : _throw(ErrnoError.With('ENOENT', path, 'touch'));
        inode.update(metadata);
    }
    _remove(path, isUnlink) {
        const syscall = isUnlink ? 'unlink' : 'rmdir';
        const inode = this.index.get(path);
        if (!inode)
            throw ErrnoError.With('ENOENT', path, syscall);
        const isDir = (inode.mode & S_IFMT) == S_IFDIR;
        if (!isDir && !isUnlink)
            throw ErrnoError.With('ENOTDIR', path, syscall);
        if (isDir && isUnlink)
            throw ErrnoError.With('EISDIR', path, syscall);
        this.index.delete(path);
    }
    async unlink(path) {
        this._remove(path, true);
        await this.remove(path);
    }
    unlinkSync(path) {
        this._remove(path, true);
        this.removeSync(path);
    }
    async rmdir(path) {
        this._remove(path, false);
        await this.remove(path);
    }
    rmdirSync(path) {
        this._remove(path, false);
        this.removeSync(path);
    }
    create(path, options) {
        const syscall = (options.mode & S_IFMT) == S_IFDIR ? 'mkdir' : 'createFile';
        if (this.index.has(path))
            throw ErrnoError.With('EEXIST', path, syscall);
        const parent = this.index.get(dirname(path));
        if (!parent)
            throw ErrnoError.With('ENOENT', dirname(path), syscall);
        const id = this.index._alloc();
        const inode = new Inode({
            ino: id,
            data: id + 1,
            mode: options.mode,
            size: 0,
            uid: parent.mode & S_ISUID ? parent.uid : options.uid,
            gid: parent.mode & S_ISGID ? parent.gid : options.gid,
        });
        this.index.set(path, inode);
        return inode;
    }
    async createFile(path, options) {
        options.mode |= S_IFREG;
        return this.create(path, options);
    }
    createFileSync(path, options) {
        options.mode |= S_IFREG;
        return this.create(path, options);
    }
    async mkdir(path, options) {
        options.mode |= S_IFDIR;
        return this.create(path, options);
    }
    mkdirSync(path, options) {
        options.mode |= S_IFDIR;
        return this.create(path, options);
    }
    link(target, link) {
        throw ErrnoError.With('ENOSYS', link, 'link');
    }
    linkSync(target, link) {
        throw ErrnoError.With('ENOSYS', link, 'link');
    }
    async readdir(path) {
        return Object.keys(this.index.directoryEntries(path));
    }
    readdirSync(path) {
        return Object.keys(this.index.directoryEntries(path));
    }
    async sync(path) { }
    syncSync(path) { }
}
