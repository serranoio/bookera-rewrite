import { getAllPrototypes } from 'utilium';
import { StoreFS } from '../backends/store/fs.js';
import { Errno, ErrnoError } from '../internal/error.js';
import { isDirectory } from '../internal/inode.js';
import { crit, debug, err } from '../internal/log.js';
import { join } from '../path.js';
/**
 * Async() implements synchronous methods on an asynchronous file system
 *
 * Implementing classes must define `_sync` for the synchronous file system used as a cache.
 *
 * Synchronous methods on an asynchronous FS are implemented by performing operations over the in-memory copy,
 * while asynchronously pipelining them to the backing store.
 * During loading, the contents of the async file system are preloaded into the synchronous store.
 * @category Internals
 */
export function Async(FS) {
    class AsyncFS extends FS {
        async done() {
            await this._promise;
        }
        queueDone() {
            return this.done();
        }
        _async(promise) {
            this._promise = this._promise.then(() => promise);
        }
        constructor(...args) {
            super(...args);
            this._promise = Promise.resolve();
            this._isInitialized = false;
            /** Tracks how many updates to the sync. cache we skipped during initialization */
            this._skippedCacheUpdates = 0;
            this._patchAsync();
        }
        async ready() {
            await super.ready();
            await this.queueDone();
            if (this._isInitialized || this.attributes.has('no_async'))
                return;
            this.checkSync();
            await this._sync.ready();
            // optimization: for 2 storeFS', we copy at a lower abstraction level.
            if (this._sync instanceof StoreFS && this instanceof StoreFS) {
                const sync = this._sync.transaction();
                const async = this.transaction();
                const promises = [];
                for (const key of await async.keys()) {
                    promises.push(async.get(key).then(data => sync.setSync(key, data)));
                }
                await Promise.all(promises);
                this._isInitialized = true;
                return;
            }
            try {
                await this.crossCopy('/');
                debug(`Skipped ${this._skippedCacheUpdates} updates to the sync cache during initialization`);
                this._isInitialized = true;
            }
            catch (e) {
                this._isInitialized = false;
                throw crit(e, { fs: this });
            }
        }
        checkSync(path, syscall) {
            if (this.attributes.has('no_async')) {
                throw new ErrnoError(Errno.ENOTSUP, 'Sync preloading has been disabled for this async file system', path, syscall);
            }
            if (!this._sync) {
                throw crit(new ErrnoError(Errno.ENOTSUP, 'No sync cache is attached to this async file system', path, syscall), { fs: this });
            }
        }
        renameSync(oldPath, newPath) {
            this.checkSync(oldPath, 'rename');
            this._sync.renameSync(oldPath, newPath);
            this._async(this.rename(oldPath, newPath));
        }
        statSync(path) {
            this.checkSync(path, 'stat');
            return this._sync.statSync(path);
        }
        touchSync(path, metadata) {
            this.checkSync(path, 'touch');
            this._sync.touchSync(path, metadata);
            this._async(this.touch(path, metadata));
        }
        createFileSync(path, options) {
            this.checkSync(path, 'createFile');
            this._async(this.createFile(path, options));
            return this._sync.createFileSync(path, options);
        }
        unlinkSync(path) {
            this.checkSync(path, 'unlinkSync');
            this._sync.unlinkSync(path);
            this._async(this.unlink(path));
        }
        rmdirSync(path) {
            this.checkSync(path, 'rmdir');
            this._sync.rmdirSync(path);
            this._async(this.rmdir(path));
        }
        mkdirSync(path, options) {
            this.checkSync(path, 'mkdir');
            this._async(this.mkdir(path, options));
            return this._sync.mkdirSync(path, options);
        }
        readdirSync(path) {
            this.checkSync(path, 'readdir');
            return this._sync.readdirSync(path);
        }
        linkSync(srcpath, dstpath) {
            this.checkSync(srcpath, 'link');
            this._sync.linkSync(srcpath, dstpath);
            this._async(this.link(srcpath, dstpath));
        }
        syncSync(path) {
            this.checkSync(path, 'sync');
            this._sync.syncSync(path);
            this._async(this.sync(path));
        }
        existsSync(path) {
            this.checkSync(path, 'exists');
            return this._sync.existsSync(path);
        }
        readSync(path, buffer, offset, end) {
            this.checkSync(path, 'read');
            this._sync.readSync(path, buffer, offset, end);
        }
        writeSync(path, buffer, offset) {
            this.checkSync(path, 'write');
            this._sync.writeSync(path, buffer, offset);
            this._async(this.write(path, buffer, offset));
        }
        streamWrite(path, options) {
            this.checkSync(path, 'streamWrite');
            const sync = this._sync.streamWrite(path, options).getWriter();
            const async = super.streamWrite(path, options).getWriter();
            return new WritableStream({
                async write(chunk, controller) {
                    await Promise.all([sync.write(chunk), async.write(chunk)]).catch(controller.error.bind(controller));
                },
                async close() {
                    await Promise.all([sync.close(), async.close()]);
                },
                async abort(reason) {
                    await Promise.all([sync.abort(reason), async.abort(reason)]);
                },
            });
        }
        /**
         * @internal
         */
        async crossCopy(path) {
            this.checkSync(path, 'crossCopy');
            const stats = await this.stat(path);
            if (!isDirectory(stats)) {
                this._sync.createFileSync(path, stats);
                const buffer = new Uint8Array(stats.size);
                await this.read(path, buffer, 0, stats.size);
                this._sync.writeSync(path, buffer, 0);
                this._sync.touchSync(path, stats);
                return;
            }
            if (path !== '/') {
                this._sync.mkdirSync(path, stats);
                this._sync.touchSync(path, stats);
            }
            const promises = [];
            for (const file of await this.readdir(path)) {
                promises.push(this.crossCopy(join(path, file)));
            }
            await Promise.all(promises);
        }
        /**
         * @internal
         * Patch all async methods to also call their synchronous counterparts unless called from themselves (either sync or async)
         */
        _patchAsync() {
            const methods = Array.from(getAllPrototypes(this))
                .flatMap(Object.getOwnPropertyNames)
                .filter(key => typeof this[key] == 'function' && `${key}Sync` in this);
            debug('Async: patching methods: ' + methods.join(', '));
            for (const key of methods) {
                // TS does not narrow the union based on the key
                const originalMethod = this[key];
                this[key] = async (...args) => {
                    var _a, _b, _c;
                    const result = await originalMethod.apply(this, args);
                    const stack = (_a = new Error().stack) === null || _a === void 0 ? void 0 : _a.split('\n').slice(2).join('\n');
                    // !stack == From the async queue
                    if ((stack === null || stack === void 0 ? void 0 : stack.includes(`at <computed> [as ${key}]`)) || (stack === null || stack === void 0 ? void 0 : stack.includes(`${key}Sync `)) || !stack)
                        return result;
                    if (!this._isInitialized) {
                        this._skippedCacheUpdates++;
                        return result;
                    }
                    try {
                        // @ts-expect-error 2556 - The type of `args` is not narrowed
                        (_c = (_b = this._sync) === null || _b === void 0 ? void 0 : _b[`${key}Sync`]) === null || _c === void 0 ? void 0 : _c.call(_b, ...args);
                    }
                    catch (e) {
                        throw err(new ErrnoError(e.errno, e.message + ' (Out of sync!)', e.path, key), { fs: this });
                    }
                    return result;
                };
            }
        }
    }
    return AsyncFS;
}
