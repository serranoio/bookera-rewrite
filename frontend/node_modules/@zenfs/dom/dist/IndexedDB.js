import { Async, AsyncTransaction, ErrnoError, InMemory, StoreFS } from '@zenfs/core';
import { convertException } from './utils.js';
function wrap(request) {
    return new Promise((resolve, reject) => {
        request.onsuccess = () => resolve(request.result);
        request.onerror = e => {
            e.preventDefault();
            reject(convertException(request.error));
        };
    });
}
/**
 * @hidden
 */
export class IndexedDBTransaction extends AsyncTransaction {
    constructor(tx, store) {
        super(store);
        this.tx = tx;
        this.store = store;
        this._idb = tx.objectStore(store.name);
    }
    async keys() {
        return (await wrap(this._idb.getAllKeys())).filter(k => typeof k == 'string').map(k => BigInt(k));
    }
    get(key) {
        return wrap(this._idb.get(key.toString()));
    }
    async set(key, data) {
        await wrap(this._idb.put(data, key.toString()));
    }
    remove(key) {
        return wrap(this._idb.delete(key.toString()));
    }
    async commit() {
        if (this.done) {
            return;
        }
        const { promise, resolve, reject } = Promise.withResolvers();
        this.done = true;
        this.tx.oncomplete = () => resolve();
        this.tx.onerror = () => reject(convertException(this.tx.error));
        this.tx.commit();
        return promise;
    }
    async abort() {
        if (this.done) {
            return;
        }
        this.done = true;
        const { promise, resolve, reject } = Promise.withResolvers();
        this.tx.onabort = () => resolve();
        this.tx.onerror = () => reject(convertException(this.tx.error));
        this.tx.abort();
        return promise;
    }
}
async function createDB(name, indexedDB = globalThis.indexedDB) {
    const req = indexedDB.open(name);
    req.onupgradeneeded = () => {
        const db = req.result;
        // This should never happen; we're at version 1. Why does another database exist?
        if (db.objectStoreNames.contains(name)) {
            db.deleteObjectStore(name);
        }
        db.createObjectStore(name);
    };
    const result = await wrap(req);
    return result;
}
export class IndexedDBStore {
    constructor(db) {
        this.db = db;
    }
    sync() {
        throw ErrnoError.With('ENOSYS', undefined, 'IndexedDBStore.sync');
    }
    get name() {
        return this.db.name;
    }
    clear() {
        return wrap(this.db.transaction(this.name, 'readwrite').objectStore(this.name).clear());
    }
    clearSync() {
        throw ErrnoError.With('ENOSYS', undefined, 'IndexedDBStore.clearSync');
    }
    transaction() {
        const tx = this.db.transaction(this.name, 'readwrite');
        return new IndexedDBTransaction(tx, this);
    }
}
/**
 * A file system that uses the IndexedDB key value file system.
 */
const _IndexedDB = {
    name: 'IndexedDB',
    options: {
        storeName: {
            type: 'string',
            required: false,
        },
        idbFactory: {
            type: 'object',
            required: false,
        },
    },
    async isAvailable(idbFactory = globalThis.indexedDB) {
        try {
            if (!(idbFactory instanceof IDBFactory)) {
                return false;
            }
            const req = idbFactory.open('__zenfs_test');
            await wrap(req);
            return true;
        }
        catch {
            return false;
        }
        finally {
            idbFactory.deleteDatabase('__zenfs_test');
        }
    },
    async create(options) {
        const db = await createDB(options.storeName || 'zenfs', options.idbFactory);
        const store = new IndexedDBStore(db);
        const fs = new (Async(StoreFS))(store);
        if (!options?.disableAsyncCache) {
            fs._sync = InMemory.create({ name: 'idb-cache' });
        }
        return fs;
    },
};
export const IndexedDB = _IndexedDB;
