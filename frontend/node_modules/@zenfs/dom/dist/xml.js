import { _inode_fields, constants, Errno, ErrnoError, FileSystem, Inode, Sync } from '@zenfs/core';
import { basename, dirname } from '@zenfs/core/path.js';
import { decodeASCII, encodeASCII } from 'utilium';
function get_stats(node) {
    const stats = {};
    for (const key of _inode_fields) {
        const value = node.getAttribute(key);
        if (value !== null && value !== undefined)
            stats[key] = parseInt(value, 16);
    }
    return new Inode(stats);
}
function set_stats(node, stats) {
    for (const key of Object.keys(stats)) {
        if (!(key in _inode_fields) || stats[key] === undefined)
            continue;
        node.setAttribute(key, stats[key].toString(16));
    }
}
function get_paths(node, contents = false) {
    let paths;
    try {
        const raw = contents ? node.textContent : node.getAttribute('paths');
        paths = JSON.parse(raw || '[]');
    }
    catch {
        paths = [];
    }
    return paths;
}
export class XMLFS extends Sync(FileSystem) {
    constructor(
    /**
     * @inheritDoc XMLOptions.root
     */
    root = new DOMParser().parseFromString('<fs></fs>', 'application/xml').documentElement) {
        super(0x20786d6c, 'xmltmpfs');
        this.root = root;
        try {
            this.mkdirSync('/', { uid: 0, gid: 0, mode: 0o777 });
        }
        catch (e) {
            const error = e;
            if (error.code != 'EEXIST')
                throw error;
        }
    }
    renameSync(oldPath, newPath) {
        const node = this.get('rename', oldPath);
        this.remove('rename', node, oldPath);
        this.add('rename', node, newPath);
    }
    statSync(path) {
        return get_stats(this.get('stat', path));
    }
    createFileSync(path, options) {
        const parent = this.statSync(dirname(path));
        const inode = new Inode({
            mode: options.mode | constants.S_IFREG,
            uid: parent.mode & constants.S_ISUID ? parent.uid : options.uid,
            gid: parent.mode & constants.S_ISGID ? parent.gid : options.gid,
        });
        this.create('createFile', path, inode);
        return inode;
    }
    unlinkSync(path) {
        const node = this.get('unlink', path);
        if (get_stats(node).mode & constants.S_IFDIR)
            throw ErrnoError.With('EISDIR', path, 'unlink');
        this.remove('unlink', node, path);
    }
    rmdirSync(path) {
        const node = this.get('rmdir', path);
        if (node.textContent?.length)
            throw ErrnoError.With('ENOTEMPTY', path, 'rmdir');
        if (!(get_stats(node).mode & constants.S_IFDIR))
            throw ErrnoError.With('ENOTDIR', path, 'rmdir');
        this.remove('rmdir', node, path);
    }
    mkdirSync(path, options) {
        const parent = this.statSync(dirname(path));
        const inode = new Inode({
            mode: options.mode | constants.S_IFDIR,
            uid: parent.mode & constants.S_ISUID ? parent.uid : options.uid,
            gid: parent.mode & constants.S_ISGID ? parent.gid : options.gid,
        });
        this.create('mkdir', path, inode).textContent = '[]';
        return inode;
    }
    readdirSync(path) {
        const node = this.get('readdir', path);
        if (!(get_stats(node).mode & constants.S_IFDIR))
            throw ErrnoError.With('ENOTDIR', path, 'rmdir');
        try {
            return JSON.parse(node.textContent);
        }
        catch (e) {
            throw new ErrnoError(Errno.EIO, 'Invalid directory listing: ' + e, path, 'readdir');
        }
    }
    linkSync(target, link) {
        const node = this.get('link', target);
        this.add('link', node, link);
    }
    touchSync(path, metadata) {
        const node = this.get('touch', path);
        set_stats(node, metadata);
    }
    syncSync() { }
    readSync(path, buffer, offset, end) {
        const node = this.get('read', path);
        const raw = encodeASCII(node.textContent.slice(offset, end));
        buffer.set(raw);
    }
    writeSync(path, buffer, offset) {
        const node = this.get('write', path);
        const data = decodeASCII(buffer);
        const after = node.textContent.slice(offset + data.length);
        node.textContent = node.textContent.slice(0, offset) + data + after;
    }
    toString() {
        return new XMLSerializer().serializeToString(this.root);
    }
    get(syscall, path) {
        const nodes = this.root.children;
        if (!nodes)
            throw ErrnoError.With('EIO', path, syscall);
        for (let i = 0; i < nodes.length; i++) {
            if (get_paths(nodes[i]).includes(path))
                return nodes[i];
        }
        throw ErrnoError.With('ENOENT', path, syscall);
    }
    create(syscall, path, stats) {
        if (this.existsSync(path))
            throw ErrnoError.With('EEXIST', path, syscall);
        const node = document.createElement('file');
        this.add(syscall, node, path);
        set_stats(node, new Inode({
            ...stats,
            uid: stats.mode,
        }));
        this.root.append(node);
        return node;
    }
    add(syscall, node, path, contents = false) {
        const paths = get_paths(node, contents);
        paths.push(path);
        if (contents) {
            node.textContent = JSON.stringify(paths);
            return;
        }
        node.setAttribute('paths', JSON.stringify(paths));
        node.setAttribute('nlink', paths.length.toString(16));
        if (path != '/') {
            const parent = this.get(syscall, dirname(path));
            this.add(syscall, parent, basename(path), true);
        }
    }
    remove(syscall, node, path, contents = false) {
        const paths = get_paths(node, contents);
        const i = paths.indexOf(path);
        if (i == -1)
            return;
        paths.splice(i, 1);
        if (contents) {
            node.textContent = JSON.stringify(paths);
            return;
        }
        if (!paths.length) {
            node.remove();
        }
        else {
            node.setAttribute('paths', JSON.stringify(paths));
            node.setAttribute('nlink', paths.length.toString(16));
        }
        if (path != '/') {
            const parent = this.get(syscall, dirname(path));
            this.remove(syscall, parent, basename(path), true);
        }
    }
}
const _XML = {
    name: 'XML',
    options: {
        root: { type: 'object', required: false },
    },
    isAvailable() {
        return true;
    },
    create(options) {
        return new XMLFS(options.root);
    },
};
/**
 * @experimental
 */
export const XML = _XML;
