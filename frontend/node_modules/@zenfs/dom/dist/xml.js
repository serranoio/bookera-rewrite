import { constants, decodeRaw, encodeRaw, Errno, ErrnoError, FileSystem, PreloadFile, Stats, Sync } from '@zenfs/core';
import { basename, dirname } from '@zenfs/core/vfs/path.js';
const statsLikeKeys = ['size', 'mode', 'atimeMs', 'mtimeMs', 'ctimeMs', 'birthtimeMs', 'uid', 'gid', 'ino', 'nlink'];
function get_stats(node) {
    const stats = {};
    for (const key of statsLikeKeys) {
        const value = node.getAttribute(key);
        stats[key] = value != null ? parseInt(value, 16) : undefined;
    }
    return new Stats(stats);
}
function set_stats(node, stats) {
    for (const key of statsLikeKeys) {
        if (stats[key] != undefined) {
            node.setAttribute(key, stats[key].toString(16));
        }
    }
}
function get_paths(node, contents = false) {
    let paths;
    try {
        const raw = contents ? node.textContent : node.getAttribute('paths');
        paths = JSON.parse(raw || '[]');
    }
    catch {
        paths = [];
    }
    return paths;
}
export class XMLFS extends Sync(FileSystem) {
    constructor(
    /**
     * @inheritdoc XMLOptions.root
     */
    root = new DOMParser().parseFromString('<fs></fs>', 'application/xml').documentElement) {
        super();
        this.root = root;
        try {
            this.mkdirSync('/', 0o777, { uid: 0, gid: 0 });
        }
        catch (e) {
            const error = e;
            if (error.code != 'EEXIST')
                throw error;
        }
    }
    metadata() {
        return { ...super.metadata(), features: ['setid'] };
    }
    renameSync(oldPath, newPath) {
        const node = this.get('rename', oldPath);
        this.remove('rename', node, oldPath);
        this.add('rename', node, newPath);
    }
    statSync(path) {
        return get_stats(this.get('stat', path));
    }
    openFileSync(path, flag) {
        const node = this.get('openFile', path);
        return new PreloadFile(this, path, flag, get_stats(node), encodeRaw(node.textContent));
    }
    createFileSync(path, flag, mode, { uid, gid }) {
        const parent = this.statSync(dirname(path));
        const stats = new Stats({
            mode: mode | constants.S_IFREG,
            uid: parent.mode & constants.S_ISUID ? parent.uid : uid,
            gid: parent.mode & constants.S_ISGID ? parent.gid : gid,
        });
        this.create('createFile', path, stats);
        return new PreloadFile(this, path, flag, stats);
    }
    unlinkSync(path) {
        const node = this.get('unlink', path);
        if (get_stats(node).isDirectory())
            throw ErrnoError.With('EISDIR', path, 'unlink');
        this.remove('unlink', node, path);
    }
    rmdirSync(path) {
        const node = this.get('rmdir', path);
        if (node.textContent?.length)
            throw ErrnoError.With('ENOTEMPTY', path, 'rmdir');
        if (!get_stats(node).isDirectory())
            throw ErrnoError.With('ENOTDIR', path, 'rmdir');
        this.remove('rmdir', node, path);
    }
    mkdirSync(path, mode, { uid, gid }) {
        const parent = this.statSync(dirname(path));
        const node = this.create('mkdir', path, {
            mode: mode | constants.S_IFDIR,
            uid: parent.mode & constants.S_ISUID ? parent.uid : uid,
            gid: parent.mode & constants.S_ISGID ? parent.gid : gid,
        });
        node.textContent = '[]';
    }
    readdirSync(path) {
        const node = this.get('readdir', path);
        if (!get_stats(node).isDirectory())
            throw ErrnoError.With('ENOTDIR', path, 'rmdir');
        try {
            return JSON.parse(node.textContent);
        }
        catch (e) {
            throw new ErrnoError(Errno.EIO, 'Invalid directory listing: ' + e, path, 'readdir');
        }
    }
    linkSync(target, link) {
        const node = this.get('link', target);
        this.add('link', node, link);
    }
    syncSync(path, data, stats) {
        const node = this.get('sync', path);
        node.textContent = decodeRaw(data);
        set_stats(node, stats);
    }
    toString() {
        return new XMLSerializer().serializeToString(this.root);
    }
    get(syscall, path) {
        const nodes = this.root.children;
        if (!nodes)
            throw ErrnoError.With('EIO', path, syscall);
        for (let i = 0; i < nodes.length; i++) {
            if (get_paths(nodes[i]).includes(path))
                return nodes[i];
        }
        throw ErrnoError.With('ENOENT', path, syscall);
    }
    create(syscall, path, stats) {
        if (this.existsSync(path))
            throw ErrnoError.With('EEXIST', path, syscall);
        const node = document.createElement('file');
        this.add(syscall, node, path);
        set_stats(node, new Stats({
            ...stats,
            uid: stats.mode,
        }));
        this.root.append(node);
        return node;
    }
    add(syscall, node, path, contents = false) {
        const paths = get_paths(node, contents);
        paths.push(path);
        if (contents) {
            node.textContent = JSON.stringify(paths);
            return;
        }
        node.setAttribute('paths', JSON.stringify(paths));
        node.setAttribute('nlink', paths.length.toString(16));
        if (path != '/') {
            const parent = this.get(syscall, dirname(path));
            this.add(syscall, parent, basename(path), true);
        }
    }
    remove(syscall, node, path, contents = false) {
        const paths = get_paths(node, contents);
        const i = paths.indexOf(path);
        if (i == -1)
            return;
        paths.splice(i, 1);
        if (contents) {
            node.textContent = JSON.stringify(paths);
            return;
        }
        if (!paths.length) {
            node.remove();
        }
        else {
            node.setAttribute('paths', JSON.stringify(paths));
            node.setAttribute('nlink', paths.length.toString(16));
        }
        if (path != '/') {
            const parent = this.get(syscall, dirname(path));
            this.remove(syscall, parent, basename(path), true);
        }
    }
}
const _XML = {
    name: 'XML',
    options: {
        root: { type: 'object', required: false },
    },
    isAvailable() {
        return true;
    },
    create(options) {
        return new XMLFS(options.root);
    },
};
/**
 * @experimental
 */
export const XML = _XML;
