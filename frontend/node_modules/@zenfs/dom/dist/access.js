import { Async, constants, Errno, ErrnoError, FileSystem, InMemory, PreloadFile, Stats } from '@zenfs/core';
import { basename, dirname, join } from '@zenfs/core/vfs/path.js';
import { convertException } from './utils.js';
function isResizable(buffer) {
    if (buffer instanceof ArrayBuffer)
        return buffer.resizable;
    if (buffer instanceof SharedArrayBuffer)
        return buffer.growable;
    return false;
}
export class WebAccessFS extends Async(FileSystem) {
    constructor(handle) {
        super();
        this._handles = new Map();
        /**
         * @hidden
         */
        this._sync = InMemory.create({ name: 'accessfs-cache' });
        this._handles.set('/', handle);
    }
    metadata() {
        return {
            ...super.metadata(),
            name: 'WebAccess',
            noResizableBuffers: true,
            // Not really, but we don't support opening directories so this prevent the VFS from trying
            features: ['setid'],
        };
    }
    async sync(path, data) {
        await this.writeFile(path, data);
    }
    async rename(oldPath, newPath) {
        const handle = await this.getHandle(oldPath);
        if (handle instanceof FileSystemDirectoryHandle) {
            const files = await this.readdir(oldPath);
            await this.mkdir(newPath);
            if (!files.length) {
                await this.unlink(oldPath);
                return;
            }
            for (const file of files) {
                await this.rename(join(oldPath, file), join(newPath, file));
                await this.unlink(oldPath);
            }
            return;
        }
        if (!(handle instanceof FileSystemFileHandle)) {
            throw new ErrnoError(Errno.ENOTSUP, 'Not a file or directory handle', oldPath, 'rename');
        }
        const oldFile = await handle.getFile().catch((ex) => {
            throw convertException(ex, oldPath, 'rename');
        }), destFolder = await this.getHandle(dirname(newPath));
        if (!(destFolder instanceof FileSystemDirectoryHandle)) {
            return;
        }
        const newFile = await destFolder.getFileHandle(basename(newPath), { create: true }).catch((ex) => {
            throw convertException(ex, newPath, 'rename');
        });
        const writable = await newFile.createWritable();
        await writable.write(await oldFile.arrayBuffer());
        await writable.close();
        await this.unlink(oldPath);
    }
    async writeFile(path, data) {
        if (isResizable(data.buffer)) {
            throw new ErrnoError(Errno.EINVAL, 'Resizable buffers can not be written', path, 'write');
        }
        const handle = await this.getHandle(dirname(path));
        if (!(handle instanceof FileSystemDirectoryHandle)) {
            return;
        }
        const file = await handle.getFileHandle(basename(path), { create: true });
        const writable = await file.createWritable();
        await writable.write(data);
        await writable.close();
    }
    async createFile(path, flag) {
        await this.writeFile(path, new Uint8Array());
        return this.openFile(path, flag);
    }
    async stat(path) {
        const handle = await this.getHandle(path);
        if (!handle) {
            throw ErrnoError.With('ENOENT', path, 'stat');
        }
        if (handle instanceof FileSystemDirectoryHandle) {
            return new Stats({ mode: 0o777 | constants.S_IFDIR, size: 4096 });
        }
        if (handle instanceof FileSystemFileHandle) {
            const { lastModified, size } = await handle.getFile();
            return new Stats({ mode: 0o777 | constants.S_IFREG, size, mtimeMs: lastModified });
        }
        throw new ErrnoError(Errno.EBADE, 'Handle is not a directory or file', path, 'stat');
    }
    async openFile(path, flag) {
        const handle = await this.getHandle(path);
        if (!(handle instanceof FileSystemFileHandle)) {
            throw ErrnoError.With('EISDIR', path, 'openFile');
        }
        const file = await handle.getFile().catch((ex) => {
            throw convertException(ex, path, 'openFile');
        });
        const data = new Uint8Array(await file.arrayBuffer());
        const stats = new Stats({ mode: 0o777 | constants.S_IFREG, size: file.size, mtimeMs: file.lastModified });
        return new PreloadFile(this, path, flag, stats, data);
    }
    async unlink(path) {
        const handle = await this.getHandle(dirname(path));
        if (!(handle instanceof FileSystemDirectoryHandle)) {
            throw ErrnoError.With('ENOTDIR', dirname(path), 'unlink');
        }
        await handle.removeEntry(basename(path), { recursive: true }).catch((ex) => {
            throw convertException(ex, path, 'unlink');
        });
    }
    // eslint-disable-next-line @typescript-eslint/require-await
    async link(srcpath) {
        return;
    }
    async rmdir(path) {
        return this.unlink(path);
    }
    async mkdir(path, mode, options) {
        const existingHandle = await this.getHandle(path).catch((ex) => {
            if (ex.code != 'ENOENT') {
                throw ex;
            }
        });
        if (existingHandle) {
            throw ErrnoError.With('EEXIST', path, 'mkdir');
        }
        const handle = await this.getHandle(dirname(path));
        if (!(handle instanceof FileSystemDirectoryHandle)) {
            throw ErrnoError.With('ENOTDIR', path, 'mkdir');
        }
        await handle.getDirectoryHandle(basename(path), { create: true });
    }
    async readdir(path) {
        const handle = await this.getHandle(path);
        if (!(handle instanceof FileSystemDirectoryHandle)) {
            throw ErrnoError.With('ENOTDIR', path, 'readdir');
        }
        const entries = [];
        for await (const k of handle.keys()) {
            entries.push(k);
        }
        return entries;
    }
    async getHandle(path) {
        if (this._handles.has(path)) {
            return this._handles.get(path);
        }
        let walked = '/';
        for (const part of path.split('/').slice(1)) {
            const handle = this._handles.get(walked);
            if (!(handle instanceof FileSystemDirectoryHandle)) {
                throw ErrnoError.With('ENOTDIR', walked, 'getHandle');
            }
            walked = join(walked, part);
            const child = await handle.getDirectoryHandle(part).catch((ex) => {
                switch (ex.name) {
                    case 'TypeMismatchError':
                        return handle.getFileHandle(part).catch((ex) => {
                            //throw convertException(ex, walked, 'getHandle');
                        });
                    case 'TypeError':
                        throw new ErrnoError(Errno.ENOENT, ex.message, walked, 'getHandle');
                    default:
                        throw convertException(ex, walked, 'getHandle');
                }
            });
            if (child)
                this._handles.set(walked, child);
        }
        return this._handles.get(path);
    }
}
const _WebAccess = {
    name: 'WebAccess',
    options: {
        handle: { type: 'object', required: true },
    },
    isAvailable() {
        return typeof FileSystemHandle == 'function';
    },
    create(options) {
        return new WebAccessFS(options.handle);
    },
};
export const WebAccess = _WebAccess;
