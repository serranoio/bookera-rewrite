import { Async, constants, Errno, ErrnoError, IndexFS, InMemory, Inode, log } from '@zenfs/core';
import { basename, dirname, join } from '@zenfs/core/path.js';
import { S_IFDIR, S_IFMT } from '@zenfs/core/vfs/constants.js';
import { _throw } from 'utilium';
import { convertException } from './utils.js';
function isResizable(buffer) {
    if (buffer instanceof ArrayBuffer)
        return buffer.resizable;
    if (buffer instanceof SharedArrayBuffer)
        return buffer.growable;
    return false;
}
/**
 * Since `FileSystemHandle.kind` doesn't have correct type support
 */
function isKind(handle, kind) {
    return handle.kind == kind;
}
export class WebAccessFS extends Async(IndexFS) {
    /**
     * Loads all of the handles.
     * @internal @hidden
     */
    async _loadHandles(path, handle) {
        for await (const [key, child] of handle.entries()) {
            const p = join(path, key);
            this._handles.set(p, child);
            if (isKind(child, 'directory'))
                await this._loadHandles(p, child);
        }
    }
    /**
     * Loads metadata
     * @internal @hidden
     */
    async _loadMetadata(metadataPath) {
        if (metadataPath) {
            const handle = this.get('file', metadataPath);
            const file = await handle.getFile();
            const raw = await file.text();
            const data = JSON.parse(raw);
            this.index.fromJSON(data);
            return;
        }
        for (const [path, handle] of this._handles) {
            if (isKind(handle, 'file')) {
                const { lastModified, size } = await handle.getFile();
                this.index.set(path, new Inode({ mode: 0o644 | constants.S_IFREG, size, mtimeMs: lastModified }));
                continue;
            }
            if (!isKind(handle, 'directory'))
                throw new ErrnoError(Errno.EIO, 'Invalid handle', path);
            this.index.set(path, new Inode({ mode: 0o777 | constants.S_IFDIR, size: 0 }));
        }
    }
    constructor(handle) {
        super(0x77656261, 'webaccessfs');
        this._handles = new Map();
        /**
         * @hidden
         */
        this._sync = InMemory.create({ label: 'accessfs-cache' });
        this.attributes.set('no_buffer_resize');
        this._handles.set('/', handle);
    }
    async remove(path) {
        const handle = this.get('directory', dirname(path));
        await handle.removeEntry(basename(path), { recursive: true }).catch(ex => _throw(convertException(ex, path)));
    }
    removeSync(path) {
        throw log.crit(ErrnoError.With('ENOSYS', path));
    }
    async read(path, buffer, offset, end) {
        if (end <= offset)
            return;
        const handle = this.get('file', path, 'write');
        const file = await handle.getFile();
        const data = await file.arrayBuffer();
        if (data.byteLength < end - offset)
            throw ErrnoError.With('ENODATA', path, 'read');
        buffer.set(new Uint8Array(data, offset, end - offset));
    }
    async write(path, buffer, offset) {
        if (isResizable(buffer.buffer)) {
            const newBuffer = new Uint8Array(new ArrayBuffer(buffer.byteLength), buffer.byteOffset, buffer.byteLength);
            newBuffer.set(buffer);
            buffer = newBuffer;
        }
        const inode = this.index.get(path);
        if (!inode)
            throw ErrnoError.With('ENOENT', path, 'write');
        const isDir = (inode.mode & S_IFMT) == S_IFDIR;
        let handle;
        try {
            handle = this.get(isDir ? 'directory' : 'file', path, 'write');
        }
        catch {
            const parent = this.get('directory', dirname(path), 'write');
            handle = await parent[isDir ? 'getDirectoryHandle' : 'getFileHandle'](basename(path), { create: true }).catch((ex) => _throw(convertException(ex, path)));
            this._handles.set(path, handle);
        }
        if (isDir)
            return;
        if (isKind(handle, 'directory')) {
            log.crit(new ErrnoError(Errno.EIO, 'Mismatch in entry kind on write', path, 'write'));
            return;
        }
        const writable = await handle.createWritable();
        try {
            await writable.seek(offset);
        }
        catch {
            await writable.write({ type: 'seek', position: offset });
        }
        await writable.write(buffer);
        await writable.close();
        const { size, lastModified } = await handle.getFile();
        inode.update({ size, mtimeMs: lastModified });
        this.index.set(path, inode);
    }
    /**
     * Do not use!
     * @deprecated @internal @hidden
     */
    async writeFile(path, data) {
        return this.write(path, data, 0);
    }
    async mkdir(path, options) {
        const inode = await super.mkdir(path, options);
        const handle = this.get('directory', dirname(path), 'mkdir');
        const dir = await handle.getDirectoryHandle(basename(path), { create: true }).catch((ex) => _throw(convertException(ex, path)));
        this._handles.set(path, dir);
        return inode;
    }
    get(kind = null, path, syscall) {
        const handle = this._handles.get(path);
        if (!handle)
            throw ErrnoError.With('ENODATA', path, syscall);
        if (kind && !isKind(handle, kind))
            throw ErrnoError.With(kind == 'directory' ? 'ENOTDIR' : 'EISDIR', path, syscall);
        return handle;
    }
}
const _WebAccess = {
    name: 'WebAccess',
    options: {
        handle: { type: 'object', required: true },
        metadata: { type: 'string', required: false },
    },
    async create(options) {
        const fs = new WebAccessFS(options.handle);
        await fs._loadHandles('/', options.handle);
        await fs._loadMetadata(options.metadata);
        return fs;
    },
};
export const WebAccess = _WebAccess;
