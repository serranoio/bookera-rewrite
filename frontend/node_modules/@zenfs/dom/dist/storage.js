import { Errno, ErrnoError, StoreFS, SyncMapTransaction } from '@zenfs/core';
import { decodeASCII, encodeASCII } from 'utilium';
/**
 * A synchronous key-value store backed by Storage.
 */
export class WebStorageStore {
    get name() {
        return WebStorage.name;
    }
    constructor(storage) {
        this.storage = storage;
    }
    /* node:coverage ignore next 10 */
    clear() {
        this.storage.clear();
    }
    clearSync() {
        this.storage.clear();
    }
    async sync() { }
    transaction() {
        return new SyncMapTransaction(this);
    }
    keys() {
        return Object.keys(this.storage).map(k => Number(k));
    }
    get(key) {
        const data = this.storage.getItem(key.toString());
        if (typeof data != 'string') {
            return;
        }
        return encodeASCII(data);
    }
    set(key, data) {
        try {
            this.storage.setItem(key.toString(), decodeASCII(data));
        }
        catch {
            throw new ErrnoError(Errno.ENOSPC, 'Storage is full.');
        }
    }
    delete(key) {
        try {
            this.storage.removeItem(key.toString());
        }
        catch (e) {
            throw new ErrnoError(Errno.EIO, 'Unable to delete key ' + key + ': ' + e);
        }
    }
}
/**
 * A synchronous file system backed by a `Storage` (e.g. localStorage).
 */
const _WebStorage = {
    name: 'WebStorage',
    options: {
        storage: { type: 'object', required: false },
    },
    /**
     * @todo Consider replacing `instanceof` with a duck-typing check?
     */
    isAvailable(config) {
        return (config?.storage ?? globalThis.localStorage) instanceof globalThis.Storage;
    },
    create({ storage = globalThis.localStorage }) {
        return new StoreFS(new WebStorageStore(storage));
    },
};
export const WebStorage = _WebStorage;
